<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Liuyi Wen's Blog - Journey of Learning Computer Science</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website"><meta property="og:title" content="Liuyi Wen&#39;s Blog"><meta property="og:url" content="http://wenliuyi.github.io/page/2/index.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><meta property="article:author" content="Liuyi Wen"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Liuyi Wen's Blog",isHighlightShrink:!1,isToc:!1,pageType:"home"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="site-info"><h1 id="site-title">Liuyi Wen's Blog</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/3858f068.html" title="并行训练系列：2. 数据并行上篇（DP，DDP）">并行训练系列：2. 数据并行上篇（DP，DDP）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-16T07:43:28.000Z" title="发表于 2025-09-16 15:43:28">2025-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Parallelism/">Parallelism</a></span></div><div class="content">数据并行（DP） 思想：将模型复制到多个GPU上；在每个GPU上，对不同的micro batches执行前向/反向传播。 准备：在每个 GPU 上都拷贝一份完整的模型参数，将一个数据 batch 均分为多个 micro-batch，分别拷贝到不同 GPU 上（DP 分片）； 前向传播/反向传播：每个 GPU 上对不同的 micro-batch 分别执行前向/反向传播，计算得到梯度 G； 聚合并下发梯度（All-Reduce）： 每个 GPU 将本地梯度 G 发送给单个 GPU 做聚合（或者在不同的 GPU 上聚合梯度的某些部分）；再将平均后的梯度下发到所有 GPU； 本地参数更新：所有 GPU 利用下发的梯度完成本地参数更新。 实现 DP 的经典框架为参数服务器：计算 GPU 称为 Worker，梯度聚合 GPU 称为 Server。 Worker 和 Server 是逻辑概念，分别可以对应一块或多块物理意义上的 GPU（当前讨论的基本都是对应一张 GPU...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/ab0f7bb9.html" title="RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代">RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-15T08:22:53.000Z" title="发表于 2025-09-15 16:22:53">2025-09-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/RL/">RL</a></span></div><div class="content">看完策略迭代和价值迭代的定义后，我还是有点迷糊：为什么得到的策略一定会收敛呢？两种方法的本质区别是什么呢？ 于是搜罗了一些更“数学”的解释，来阐明这个问题。 Bellman 算子 定义状态空间：\(S={\{s_1, s_2, ..., s_n \}}\)；动作空间：\(A={\{a_1, a_2, ..., a_n \}}\) 贝尔曼期望方程： \[ V(s)=E_{a\sim\pi(a|s)}[r(s,a)+\gamma E_{s&#39;\sim p(s&#39;|s,a)}[V(s&#39;)]] \] 贝尔曼最优方程： \[ V(s)=\max_a(r(s,a)+\gamma E_{s&#39;\sim p(s&#39;|s,a)}[V(s&#39;)]) \] 根据以上方程，定义贝尔曼期望算子\(B_\pi\)和贝尔曼最优算子\(B_*\)，分别代表对当前价值函数集\(V\)利用贝尔曼方程更新的操作： \[ B_\pi V(s)=E_{a\sim\pi(a|s)}[r(s,a)+\gamma...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/ba1e1693.html" title="RL 系列：1. Markov 决策过程">RL 系列：1. Markov 决策过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-08T09:29:49.000Z" title="发表于 2025-09-08 17:29:49">2025-09-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/RL/">RL</a></span></div><div class="content">本文旨在阐述基于 Markov 决策过程的强化学习原理，聚焦于关键公式（省去一些繁杂的数学推导），快速领会 RL 的核心理念。 RL 概述 强化学习的理念：Agent 根据 Environment 输出的 \(S_t\) 和 \(R_t\) 综合判断，产生当前步骤的动作 \(A_t\)，放入 Environment 执行；Environment 根据 \(A_t\) 执行的结果，输出下一个状态 \(S_{t+1}\) 和当前动作带来的奖励 \(R_{t+1}\)，返回给 Agent。 强化学习和监督学习的区别： RL 得到的时序数据不满足独立同分布； RL 无实时明确反馈当前 Action 是否正确，奖励信号延迟。（通过 rollout 过程从当前帧对 Action 进行采样，得到多个 observation， 每个 observe 对应一条 trajectory，即一个 State 和 Action 的序列 τ=(s0,a0,s1,a1,…)；通过最终 reward 来观测当前 trajectory 是否合适） Markov...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/b1ea32a.html" title="并发系列：2. Go 的长连接">并发系列：2. Go 的长连接</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-03T03:20:39.000Z" title="发表于 2025-09-03 11:20:39">2025-09-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/High-Concurrency/">High Concurrency</a></span></div><div class="content">TCP 连接的建立和关闭 绝大多数网络连接的建立都是基于 TCP 协议的，我们往往知道一个原则：建立 TCP 连接需要三次握手，其具体过程也是面试的一个常考点。那么“为什么 TCP 建立连接需要三次握手？”呢？这个问题很少深究。首先回顾一下建立连接的过程： TCP 连接是什么？ 连接：用于保证可靠性和流控制的信息，包括 Socket、序列号和窗口大小。其中：Socket 由互联网地址标志符和端口组成；窗口大小主要用来做流控制；最后的序列号用于追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。 TCP 所有的协议状态如下图： 建立 TCP 连接的三次握手 抽象成通俗语言就是： 你能听到吗？ 我能听到，你听得到吗？ 我也能听到。 第一次握手：SYN 报文：客户端随机初始化序列号 client_isn，放进TCP⾸部序列号段，然后把SYN置1。把SYN报⽂发送给服务端，表示 发起连接，之后客户端处于...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/cda30c10.html" title="Go-内存分配器">Go-内存分配器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-18T13:37:10.000Z" title="发表于 2025-07-18 21:37:10">2025-07-18</time></span></div><div class="content">内存分配器 内存空间包含两个重要区域：栈区和堆区。不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。 设计原理 内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）；当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。 分配方法 线性分配器 使用线性分配器时，只需要在内存中维护一个指向特定位置的指针；用户程序申请内存时，移动指针。然而，这不利于在内存被释放时重用内存。如下图中红色部分难以利用： 因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/b1ea32a.html" title="Go-调度器">Go-调度器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-17T03:20:39.000Z" title="发表于 2025-07-17 11:20:39">2025-07-17</time></span></div><div class="content">Go-调度器 多个线程可以属于同一个进程并共享内存空间。因此它们也不需要内存管理单元处理上下文的切换，线程之间的通信是基于共享的内存进行的。 虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销。 Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。 设计原理 包括以下几个版本： 单线程调度器：程序中只能存在一个活跃线程，由G-M模型组成； 单线程调度器 0.x...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/d1f88670.html" title="并发系列：1. 自旋锁">并发系列：1. 自旋锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-14T11:21:14.000Z" title="发表于 2025-07-14 19:21:14">2025-07-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/High-Concurrency/">High Concurrency</a></span></div><div class="content">首先从乐观锁和悲观锁的设计思想开始。 乐观锁和悲观锁 悲观锁 悲观锁总认为最坏的情况可能会出现，即数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源或者数据锁住，其他线程想要请求这个资源时阻塞，直到悲观锁释放资源（读写操作均加锁）。传统的关系型数据库里边就用到了很多悲观锁机制，比如行锁，表锁等，读锁，写锁等，均在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。 Java 中的 Synchronized 和 ReentrantLock 等独占锁(排他锁)也是一种悲观锁思想的实现，因为 Synchronzied 和 ReetrantLock 不管是否持有资源，它都会尝试去加锁。 一个悲观锁的运用场景： select * from student where name="cxuan" for update 这条 sql 语句从 Student 表中选取 name =...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/e8d1fb4.html" title="Go-channel">Go-channel</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-11T10:41:20.000Z" title="发表于 2025-07-11 18:41:20">2025-07-11</time></span></div><div class="content">Go-Channel Channel是Go的核心数据结构和Goroutine之间的通信方式，支持Go的高性能并发编程模型。 设计原理 不通过共享内存的方式通信，而是通过通信的方式共享内存，采用的并发模式为：CSP（通信顺序进程）。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。 怎么理解“不通过共享内存的方式通信，而是通过通信的方式共享内存”这句话呢？ 前半句指通过 sync 包里的一些组件进行并发编程；后半句指使用 channel 进行并发编程。实际上，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。 上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。 FIFO Channel的收发操作遵循“先进先出”： 先从 Channel 读取数据的 Goroutine...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/4e29148d.html" title="Go-上下文Context">Go-上下文Context</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-07-09T09:16:57.000Z" title="发表于 2025-07-09 17:16:57">2025-07-09</time></span></div><div class="content">上下文context 上下文context是Go中较独特的设计，其他编程语言中较为少见，主要用于在Goroutine之间传递请求的截止时间、取消信号和其他跨API边界的值。 context.Context是Go在1.7版本中引入的标准库接口，定义了4个待实现的方法： Deadline：返回 context.Context 被取消的时间，也就是完成工作的截止日期（如果Context设置了截止时间，则返回ok=true，deadline返回该时间；如果没有设置截止时间，则返回ok=false，deadline为空） Done：返回一个Channel（在当前工作完成或者上下文被取消后关闭），作为对Context关联函数的取消信号。当Channel关闭时，关联函数终止工作并返回。 多次调用 Done...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/1e6a04d4.html" title="Transformer 系列：2. Attention机制，MHA，MQA 和 GQA">Transformer 系列：2. Attention机制，MHA，MQA 和 GQA</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-06-29T07:47:26.000Z" title="发表于 2025-06-29 15:47:26">2025-06-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Transformer/">Transformer</a></span></div><div class="content">Scaled Dot-Product Attention 只使用一个注意力头计算权重。 假设有输入序列\(X=(x_1, x_2,..., x_n)\)，对于每个词\(x_i\)（维度为\(d\)），计算其与所有其他词的相关性，并赋予不同的权重，最后对这些信息加权求和，得到新的表示。 输入矩阵：\(X\in\mathbb{R^{n\times d}}\). \[ Attention(Q, K, V)=softmax(\frac{QK^{T}}{\sqrt{d_k}})V \] 这里，\(Q\in\mathbb{R^{n\times d_k}}, K\in\mathbb{R^{m\times d_k}, V\in\mathbb{R^{m\times d_v}}}\)。实质上，一个Attention层是：将\([n, d_k]\)的序列\(Q\)编码成一个新的\(n\times d_v\)序列。 从向量角度看： \[ Attention(q_t, K, V)=\sum_{s=1}^m...</div></div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/WechatIMG105.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/390656db.html" title="深入 Parquet：从 Dremel 论文到列式存储的工程权衡">深入 Parquet：从 Dremel 论文到列式存储的工程权衡</a><time datetime="2025-09-30T07:45:57.000Z" title="发表于 2025-09-30 15:45:57">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2d0d7608.html" title="Transformer 系列：3. Encoder 和 Decoder 的架构">Transformer 系列：3. Encoder 和 Decoder 的架构</a><time datetime="2025-09-29T09:08:01.000Z" title="发表于 2025-09-29 17:08:01">2025-09-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d4ce6176.html" title="幂等性设计">幂等性设计</a><time datetime="2025-09-28T11:21:49.000Z" title="发表于 2025-09-28 19:21:49">2025-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7824989e.html" title="从 TCP 粘包到分帧">从 TCP 粘包到分帧</a><time datetime="2025-09-26T10:04:55.000Z" title="发表于 2025-09-26 18:04:55">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/eecc19a2.html" title="并行训练系列：5. Megatron 之分布式环境初始化">并行训练系列：5. Megatron 之分布式环境初始化</a><time datetime="2025-09-25T09:41:56.000Z" title="发表于 2025-09-25 17:41:56">2025-09-25</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline"><i class="fas fa-folder-open"></i> <span>分类</span> <a class="card-more-btn" href="/categories/" title="查看更多"><i class="fas fa-angle-right"></i></a></div><ul class="card-category-list" id="aside-cat-list"><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/Database/"><span class="card-category-list-name">Database</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/Distributed-System/"><span class="card-category-list-name">Distributed System</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/High-Concurrency/"><span class="card-category-list-name">High Concurrency</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/Network/"><span class="card-category-list-name">Network</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/OS/"><span class="card-category-list-name">OS</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/Parallelism/"><span class="card-category-list-name">Parallelism</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/RL/"><span class="card-category-list-name">RL</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item"><a class="card-category-list-link" href="/categories/Transformer/"><span class="card-category-list-name">Transformer</span><span class="card-category-list-count">4</span></a></li></ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/OOP/" style="font-size:1.1em;color:#999">OOP</a> <a href="/tags/Web-Platforms-Display/" style="font-size:1.3em;color:#99a1ac">Web Platforms Display</a> <a href="/tags/Go/" style="font-size:1.5em;color:#99a9bf">Go</a> <a href="/tags/C/" style="font-size:1.5em;color:#99a9bf">C++</a> <a href="/tags/KV-Cache/" style="font-size:1.1em;color:#999">KV Cache</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i> <span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025 </span><span class="card-archive-list-count">11</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025 </span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025 </span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025 </span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025 </span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025 </span><span class="card-archive-list-count">16</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">44</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastpushdate="2025-10-20T04:23:32.701Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>