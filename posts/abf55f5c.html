<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>《算法导论》笔记 | Liuyi Wen's Blog</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该篇为《算法导论》学习笔记，包含部分章节的理论阐释、典型问题、和代码实现。 算法 时间复杂度 1.渐近符号： θ--渐近紧确界； f(n)&#x3D;θ(g(n)):g(n)是f(n)的渐进紧确界. 定义:存在c1,c2,n0,对任意n&gt;&#x3D;n0,有：0&lt;&#x3D;c1g(n)&lt;&#x3D;f(n)&lt;&#x3D;c2g(n). f(n)&#x3D;θ(g(n)),当且仅当:f(n)&#x3D;O(g(n))且f(n)&#x3D;欧姆. O--"><meta property="og:type" content="article"><meta property="og:title" content="《算法导论》笔记"><meta property="og:url" content="http://wenliuyi.github.io/posts/abf55f5c.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:description" content="该篇为《算法导论》学习笔记，包含部分章节的理论阐释、典型问题、和代码实现。 算法 时间复杂度 1.渐近符号： θ--渐近紧确界； f(n)&#x3D;θ(g(n)):g(n)是f(n)的渐进紧确界. 定义:存在c1,c2,n0,对任意n&gt;&#x3D;n0,有：0&lt;&#x3D;c1g(n)&lt;&#x3D;f(n)&lt;&#x3D;c2g(n). f(n)&#x3D;θ(g(n)),当且仅当:f(n)&#x3D;O(g(n))且f(n)&#x3D;欧姆. O--"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/butterfly-icon.png"><meta property="article:published_time" content="2025-04-07T11:25:55.000Z"><meta property="article:modified_time" content="2025-05-20T03:42:08.000Z"><meta property="article:author" content="Liuyi Wen"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "《算法导论》笔记",
  "url": "http://wenliuyi.github.io/posts/abf55f5c.html",
  "image": "http://wenliuyi.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-07T11:25:55.000Z",
  "dateModified": "2025-05-20T03:42:08.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liuyi Wen",
      "url": "http://wenliuyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/posts/abf55f5c.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"《算法导论》笔记",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">《算法导论》笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">《算法导论》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-07T11:25:55.000Z" title="发表于 2025-04-07 19:25:55">2025-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-20T03:42:08.000Z" title="更新于 2025-05-20 11:42:08">2025-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithms/">Algorithms</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>该篇为《算法导论》学习笔记，包含部分章节的理论阐释、典型问题、和代码实现。</p><h1 id="算法">算法</h1><h2 id="时间复杂度">时间复杂度</h2><h3 id="渐近符号">1.渐近符号：</h3><p>θ--渐近紧确界； f(n)=θ(g(n)):g(n)是f(n)的渐进紧确界. 定义:存在c1,c2,n0,对任意n&gt;=n0,有：0&lt;=c1<em>g(n)&lt;=f(n)&lt;=c2</em>g(n). f(n)=θ(g(n)),当且仅当:f(n)=O(g(n))且f(n)=<a href="g(n)">欧姆</a>. O--渐近上界；[欧姆]--渐近下界 o--非紧确渐近上界；ω--非紧确渐近下界 f(n)=O(g(n))中,0&lt;=f(n)&lt;c<em>g(n)对某个常量c&gt;0成立； f(n)=o(g(n))中,0&lt;=f(n)&lt;c</em>g(n)对所有常量c&gt;0成立.</p><h3 id="主定理求时间复杂度">2.主定理求时间复杂度:</h3><p>T(n)=a<em>T(n/b)+f(n). 比较n<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>和f(n):选择多项式意义上更大的。 1.f(n)=O(n<sup>(logb(a)-ε)),则:T(n)=θ(n</sup>(logb(a)). 2.f(n)=0(n<sup>(logb(a))),则:T(n)=θ(n</sup>(logb(a)</em>lgn). 3.f(n)=<a href="n%5E(logb(a)+ε)">欧姆</a>,则:T(n)=θ(f(n)). 注意：T(n)=2T(n/2)+nlgn. nlgn非多项式意义大于n,落入2，3间隙,不适用主定理.</p><h2 id="快速幂质数">快速幂/质数</h2><h3 id="快速幂求ab.">1.快速幂：求a^b.</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fpm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b!=<span class="number">0</span>;b&gt;&gt;=<span class="number">1</span>,a=a*a%M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求矩阵n次幂:A<sup>n--θ(n</sup>3)-&gt;θ(n^2*logn).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 205</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Martix</span>&#123;</span></span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Martix <span class="title function_">multiply</span><span class="params">(Martix x, Martix y)</span>&#123;</span><br><span class="line">    Martix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            z.a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">                z.a[i][j] += x.a[i][k] * y.a[k][j];</span><br><span class="line">                z.a[i][j] %= p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Martix <span class="title function_">fpow</span><span class="params">(Martix x, ll k)</span>&#123;</span><br><span class="line">    Martix y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) y.a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> y.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) y = multiply(y, x);</span><br><span class="line">        x = multiply(x, x);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%&quot;</span>, &amp;n);k = n;</span><br><span class="line">        Martix x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x.a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x = fpow(x, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, x.a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="分解质因数">2.分解质因数</h3><p>质数个数:O(n/logn). (1)朴素算法:遍历i.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N],p[N],k=<span class="number">0</span>;      <span class="comment">//p记录n的质因数;a记录n的质因数的指数;k为不同质因数个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decompose</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p[k]=i;a[k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;a[k]++;n/=i;&#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">        p[k]=n;a[k]=<span class="number">1</span>;k++;</span><br><span class="line">    &#125;   <span class="comment">//此时p[0],...,p[k-1]为最初n的k个质数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>(2)优化：预先运用埃氏筛/欧氏筛打表出2~n的质数,改为遍历prime[i].<p></p><p>埃氏筛:O(n*loglogn) <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/abf55f5c/image.png"> 欧式筛:O(n) <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/abf55f5c/image-1.png"></p><h3 id="逆元若xy1mod-p则xy互为模p意义下的逆元.">3.逆元:若x*y=1(mod p),则x,y互为模p意义下的逆元.</h3><pre><code>由费马小定理:x^(-1)=x^(p-2)(mod p),p为质数.
求阶乘的逆元:
    递推实现(i!)^(-1)=((i+1)!)^(-1)*(i+1)(mod p).
    令:inv[i]表示i!的逆元,则:inv[i-1]=inv[i]*i(mod p).
    O(logn)求n!的逆元,O(n)递推得所有数的逆元.</code></pre><h3 id="秦九韶算法快速计算sigmaaixii0n.">4.秦九韶算法:快速计算sigma(ai*x^i)(i=0~n).</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">30005</span>],b[<span class="number">30005</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E 10007</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> m;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="type">int</span> q;<span class="type">long</span> <span class="type">long</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x%=E;y%=E;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum1=<span class="number">0</span>,mi=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1=(sum1%E+(a[i]%E)*(mi%E))%E;</span><br><span class="line">            mi=(mi*x)%E;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mi=<span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum2=(sum2%E+(b[i]%E)*(mi%E))%E;</span><br><span class="line">            mi=(mi*y)%E;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=((sum1%E)*(sum2%E))%E;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辗转相除法">5.辗转相除法:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a%b==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递推模拟">递推/模拟</h2><h3 id="卡特兰数">1.卡特兰数</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/abf55f5c/image-2.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卡特兰数存放在data中,进行n次查询</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> data[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> *now)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k=*now;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=(((data[i]%MAX)*(data[k<span class="number">-1</span>-i]%MAX))%MAX+sum)%MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        data[k]=sum%MAX;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    *now=k<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    data[<span class="number">0</span>]=data[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=now) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,data[num]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            calculate(num,&amp;now);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,data[num]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项式相加">2.多项式相加</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并同类项:O(n)</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>],b[<span class="number">100005</span>],A[<span class="number">100005</span>],B[<span class="number">100005</span>],c[<span class="number">200005</span>],C[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t,n,m;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);     <span class="comment">//系数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);     <span class="comment">//指数,非负递增</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);     <span class="comment">//系数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;B[i]);     <span class="comment">//指数,非负递增</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(合并后,不会出现和为0的项)</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                C[k]=A[i];c[k++]=a[i++]+b[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                C[k]=A[i];c[k++]=a[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                C[k]=B[j];c[k++]=b[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n) &#123;C[k]=A[i];c[k++]=a[i++];&#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m) &#123;C[k]=B[j];c[k++]=b[j++];&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;k;t++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,c[t]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;k;t++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,C[t]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*i);<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*i);</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*j);<span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*j);</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*k);<span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数乘法θmn">3.大数乘法:θ(m*n)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">multiply</span><span class="params">(<span class="type">char</span>* a,<span class="type">char</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len1=<span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="type">int</span> len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="type">int</span> *res=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(len1+len2+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1+len2;i++) res[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len2;j++)</span><br><span class="line">            res[i+j+<span class="number">1</span>]+=(a[i]-<span class="string">&#x27;0&#x27;</span>)*(b[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=len1+len2<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> (res[i]&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i<span class="number">-1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(res[i]==<span class="number">0</span>&amp;&amp;i&lt;len1+len2) i++;</span><br><span class="line">    <span class="keyword">if</span>(i==len1+len2) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len1+len2;j++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,res[j]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">//for(int j=i;j&lt;=len1+len2+1;j++) printf(&quot;%c&quot;,res[j]+&#x27;0&#x27;);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A[<span class="number">2005</span>],B[<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);getchar();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(A,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);<span class="built_in">memset</span>(B,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);</span><br><span class="line">        fgets(A,<span class="number">2004</span>,<span class="built_in">stdin</span>);fgets(B,<span class="number">2004</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="type">int</span> lenA=<span class="built_in">strlen</span>(A);<span class="type">int</span> lenB=<span class="built_in">strlen</span>(B);<span class="comment">//printf(&quot;%d&quot;,lenA);</span></span><br><span class="line">        A[lenA<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;B[lenB<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;%s&quot;,A);printf(&quot;%s&quot;,B);</span></span><br><span class="line">        multiply(A,B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度除法">4.高精度除法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">long</span> numerator,<span class="type">long</span> denominator)</span>&#123;</span><br><span class="line">    <span class="type">double</span> offset=<span class="number">1.0</span>;</span><br><span class="line">    <span class="type">double</span> q=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">long</span> a=numerator;</span><br><span class="line">    <span class="type">long</span> b=denominator;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            a=a-b;</span><br><span class="line">            q=q+offset;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            offset=offset*<span class="number">0.1</span>;</span><br><span class="line">            b=denominator*offset;</span><br><span class="line">            <span class="comment">//printf_s(&quot;%f\n&quot;,q);</span></span><br><span class="line">            <span class="comment">//printf_s(&quot;%d\n&quot;,b);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治">分治</h2><h3 id="最大子数组问题寻找a的和最大的非空连续子数组.">1.最大子数组问题:寻找A的和最大的非空连续子数组.</h3><p>朴素：O(n^2)；分治：O(nlgn).--买一次股票问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治思路:change数组储存相邻两天变化.change[low,high]的最大值(change[j]-change[i])来自:</span></span><br><span class="line"><span class="comment">//change[low,mid]最大值;change[mid+1,high]最大值;横跨mid的最大值.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY -2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxCrossingSubarray</span><span class="params">(<span class="type">int</span> *changes,<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left_sum=INFINITY,right_sum=INFINITY,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=low;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=changes[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;left_sum) left_sum=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=mid+<span class="number">1</span>;j&lt;=high;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=changes[j];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;right_sum) right_sum=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left_sum+right_sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxSubarray</span><span class="params">(<span class="type">int</span> *changes,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low==high) <span class="keyword">return</span> changes[low];</span><br><span class="line">    <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> leftSum=findMaxSubarray(changes,low,mid),rightSum=findMaxSubarray(changes,mid+<span class="number">1</span>,high),crossSum=findMaxCrossingSubarray(changes,low,mid,high);</span><br><span class="line">    <span class="keyword">if</span>(leftSum&gt;=rightSum&amp;&amp;leftSum&gt;=crossSum) <span class="keyword">return</span> leftSum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rightSum&gt;=leftSum&amp;&amp;rightSum&gt;=crossSum) <span class="keyword">return</span> rightSum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> crossSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> *prices,<span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pricesSize==<span class="number">0</span>||pricesSize==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *changes=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(pricesSize<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pricesSize<span class="number">-1</span>;i++) changes[i]=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">    <span class="keyword">return</span> findMaxSubarray(changes,<span class="number">0</span>,pricesSize<span class="number">-2</span>)&gt;<span class="number">0</span>?findMaxSubarray(changes,<span class="number">0</span>,pricesSize<span class="number">-2</span>):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="树状数组">2.树状数组:</h3><p>引入辅助数组C,C[i]管辖的元素个数：<span class="math inline">\(2^k\)</span>个（k为i的二进制末尾0的个数）.</p><p>求前缀和:求sum(A1+…+Am)：查询的m转为二进制，不断消除当前末尾1，直至全部为0停止。 例：7(0111)[C7] -&gt; 6(0110)[C6] -&gt; 4(0100)[C4] -&gt; 0. 故sum(A1+…+A7)=C4+C6+C7.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//如何求m的二进制表示的末尾1位置？</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m&amp;(-m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求前缀和：O(logn)</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(m&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                    ans+=C[m];</span><br><span class="line">                    m-=lowbit(m);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单点更新a[i]：i转为二进制，不断对当前末尾1 +1，直至达到数组下标的最大值n结束.</span></span><br><span class="line">    <span class="comment">//例：更新A[2](+value)：</span></span><br><span class="line">        <span class="comment">//更新 (+value)(0010)-&gt;更新C[4](+value)(0100)-&gt;更新C[8](+value)(1000).</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    A[i]+=value;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i]+=value;</span><br><span class="line">        i+=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：求逆序对数目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原数组A标记数i是否出现,A[i]=0未出现,A[i]=1出现.求前缀和,即为正序对数目</span></span><br><span class="line"><span class="type">int</span> lowbit[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">200010</span>];        <span class="comment">//树状数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200005</span>;i++) lowbit[i]=i&amp;(-i);</span><br><span class="line">    <span class="type">int</span> T,n,op;     <span class="comment">//T为数据组数，n为每组数据个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">200010</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;        <span class="comment">//ans记录逆序对数量之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);        <span class="comment">//op为当前a[i]</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> nowsum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//原数组A标记数i是否出现,A[i]=0未出现,A[i]=1出现.sum为A对应树状数组</span></span><br><span class="line">            <span class="comment">//求A[1]~A[op]前缀和.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=op;j&gt;<span class="number">0</span>;j-=lowbit[j]) nowsum+=sum[j];</span><br><span class="line">            </span><br><span class="line">            ans+=i-nowsum;          <span class="comment">//a[i]前有i个数,nowsum为小于a[i]=op的数个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新数组:A[op]=1.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=op;j&lt;=<span class="number">200000</span>;j+=lowbit[j]) sum[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 3.归并排序:O(n*lgn).<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并过程中求逆序对</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> s[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span><span class="comment">//将r数组分为两部分，排序后存到s数组中</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">    i=left;<span class="comment">//左数组的索引</span></span><br><span class="line">    j=mid+<span class="number">1</span>;<span class="comment">//右数组的索引</span></span><br><span class="line">    k=left;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=mid)&amp;&amp;(j&lt;=right))</span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">if</span>(r[i]&lt;=r[j]) s[k++] = r[i++];<span class="comment">//左半边的元素进入新数组，所以不用交换</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右半边的元素进入新数组，要交换</span></span><br><span class="line">        &#123;</span><br><span class="line">            num += j - k;</span><br><span class="line">            s[k++]=r[j++];</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) s[k++]=r[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) s[k++]=r[j++];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> s[],<span class="type">int</span> left,<span class="type">int</span> right)</span><span class="comment">//r[] 是原始数组, s[] 是用于存储结果的临时数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="type">int</span> t[<span class="number">100010</span>];<span class="comment">//一个用于临时存储数据的数组。</span></span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="comment">//如果 left 等于 right，说明子数组只包含一个元素，无需排序，直接将该元素放入 s 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        s[left]=r[right];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        ans+=merge_sort(r,t,left,mid);</span><br><span class="line">        ans+=merge_sort(r,t,mid+<span class="number">1</span>,right);</span><br><span class="line">        ans+=merge(t,s,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, a[<span class="number">100010</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, merge_sort(a,a,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 堆 ### 1.C语言实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.维护堆的性质:</span></span><br><span class="line"><span class="comment">//A[i]左右子树都是最大堆,调整以A[i]为根结点的二叉树为最大堆</span></span><br><span class="line"><span class="comment">//时间复杂度:T(n)&lt;=T(2n/3)+theta(1),T(n)=O(lgn).</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> heapsize,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">2</span>*i,r=<span class="number">2</span>*i+<span class="number">1</span>,largest;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=heapsize&amp;&amp;A[l]&gt;A[i]) largest=l;</span><br><span class="line">    <span class="keyword">else</span> largest=i;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=heapsize&amp;&amp;A[r]&gt;A[largest]) largest=r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(largest!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换A[i]与A[largest]</span></span><br><span class="line">        swap(&amp;A[i],&amp;A[largest]);</span><br><span class="line">        max_heapify(A,heapsize,largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.建堆:</span></span><br><span class="line"><span class="comment">//自底向上,用max_heapify将数组转为最大堆:A[len/2+1,...,len]为叶节点,每个叶节点看作一个元素的堆</span></span><br><span class="line"><span class="comment">//时间复杂度:非紧确界:O(n*lgn);紧确界:O(n).</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_maxHeap</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> heapsize=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--) max_heapify(A,heapsize,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.堆排序(升序):</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    build_maxHeap(A,len);       <span class="comment">//建立初始最大堆</span></span><br><span class="line">    <span class="type">int</span> heapsize=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;A[<span class="number">1</span>],&amp;A[i]);</span><br><span class="line">        heapsize-=<span class="number">1</span>;</span><br><span class="line">        max_heapify(A,heapsize,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.最大优先队列,去除最大元素:</span></span><br><span class="line"><span class="comment">//时间复杂度:O(logn)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">heap_extract_max</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *heapsize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*heapsize&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;       <span class="comment">//无效</span></span><br><span class="line">    <span class="type">int</span> max=A[<span class="number">1</span>];</span><br><span class="line">    A[<span class="number">1</span>]=A[*heapsize];</span><br><span class="line">    (*heapsize)--;</span><br><span class="line">    max_heapify(A,*heapsize,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.最大堆元素值增加后,调整最大堆</span></span><br><span class="line"><span class="comment">//时间复杂度:O(lgn)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_increase_key</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> i,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i]&gt;key) <span class="keyword">return</span>;</span><br><span class="line">    A[i]=key;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">1</span>&amp;&amp;A[i/<span class="number">2</span>]&lt;A[i])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;A[i/<span class="number">2</span>],&amp;A[i]);    <span class="comment">//上浮:与父节点交换</span></span><br><span class="line">        i=i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.最大堆插入元素</span></span><br><span class="line"><span class="comment">//时间复杂度:O(lgn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY -10000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">maxHeap_insert</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> key,<span class="type">int</span> *heapsize)</span>&#123;</span><br><span class="line">    (*heapsize)++;</span><br><span class="line">    A[*heapsize]=INFINITY;</span><br><span class="line">    heap_increase_key(A,*heapsize,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,op,x,heapsize=<span class="number">0</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            maxHeap_insert(A,x,&amp;heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) heap_extract_max(A,&amp;heapsize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(&amp;A[<span class="number">1</span>],heapsize,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=heapsize;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 2.C++实现:最大优先队列 最大优先队列:队首为最大元素<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//最大优先队列(底层实现:heap)</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>&gt;p;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt;p;</span><br><span class="line"><span class="comment">//最小优先队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;q;</span><br><span class="line"><span class="comment">//成员函数:</span></span><br><span class="line">p.push(<span class="number">1</span>);          <span class="comment">//插入元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.top();      <span class="comment">//访问队首元素</span></span><br><span class="line">p.pop();            <span class="comment">//移除队首元素</span></span><br><span class="line"><span class="keyword">if</span>(p.empty())       <span class="comment">//检查是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较函数:例--比较年龄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Person(<span class="type">const</span> <span class="built_in">string</span> &amp;n,<span class="type">int</span> a):name(n),age(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compareByAge</span>&#123;</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)</span><span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.age&gt;p2.age;       <span class="comment">//按年龄从小到大排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Person,<span class="built_in">vector</span>&lt;Person&gt;,compareByAge&gt;q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="快速排序">快速排序</h2><h3 id="性能分析">性能分析</h3><p>最坏划分：两子问题分别包括0和n-1个元素:T(n)=T(n-1)+θ(n),得T(n)=θ(n^2). 最好划分：T(n)=2<em>T(n/2)+θ(n),得T(n)=θ(n</em>lgn). 平衡划分:常数比例的划分,递归树深度为θ(lgn),每层工作量为O(n).总运行时间O(n<em>lgn). 使用RANDOMIZED-PARTITION,在输入元素互异时,快排的期望运行时间为O(n</em>lgn).</p><h3 id="c语言实现">C语言实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> *cnt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> last=left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*cnt)++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>[i]&lt;<span class="built_in">list</span>[left]) swap(&amp;<span class="built_in">list</span>[++last],&amp;<span class="built_in">list</span>[i]);  <span class="comment">//list[left]作为基准值：将小于基准值的元素，换至last以前</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;<span class="built_in">list</span>[left],&amp;<span class="built_in">list</span>[last]);</span><br><span class="line">    quickSort(<span class="built_in">list</span>,left,last<span class="number">-1</span>,cnt);</span><br><span class="line">    quickSort(<span class="built_in">list</span>,last+<span class="number">1</span>,right,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=A[r];     <span class="comment">//主元</span></span><br><span class="line">    <span class="type">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=p;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j]&lt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">            swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;A[i+<span class="number">1</span>],&amp;A[r]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Randomized_Partition</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=p+rand()%(r-p);</span><br><span class="line">    swap(&amp;A[i],&amp;A[r]);</span><br><span class="line">    <span class="keyword">return</span> partition(A,p,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=Randomized_Partition(A,p,r);</span><br><span class="line">        quicksort(A,p,q<span class="number">-1</span>);</span><br><span class="line">        quicksort(A,q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求顺序统计量">求顺序统计量</h3><p>求A[p,r]中第i小的元素--期望时间:θ(n);最坏时间:θ(n^2).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=A[r];     <span class="comment">//主元</span></span><br><span class="line">    <span class="type">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=p;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j]&lt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">            swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;A[i+<span class="number">1</span>],&amp;A[r]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Randomized_Partition</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=p+rand()%(r-p);           <span class="comment">//rand()返回0~32767间的随机数</span></span><br><span class="line">    swap(&amp;A[i],&amp;A[r]);</span><br><span class="line">    <span class="keyword">return</span> partition(A,p,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A[p...r]中,找第i小的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Randomized_Select</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> p,<span class="type">int</span> r,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==r) <span class="keyword">return</span> A[p];</span><br><span class="line">    <span class="type">int</span> q=Randomized_Partition(A,p,r);</span><br><span class="line">    <span class="comment">//int q= partition(A,p,r);</span></span><br><span class="line">    <span class="type">int</span> k=q-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==k) <span class="keyword">return</span> A[q];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;k) <span class="keyword">return</span> Randomized_Select(A,p,q<span class="number">-1</span>,i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Randomized_Select(A,q+<span class="number">1</span>,r,i-k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Randomized_Select(A,<span class="number">0</span>,<span class="number">9</span>,i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="线性时间排序">线性时间排序</h2><h3 id="比较排序算法">1.比较排序算法</h3><pre><code>O(n*lgn)时间内排序n个数:
    归并排序,堆排序--最坏情况达到θ(n*lgn);
    快速排序--平均情况达到θ(n*lgn).</code></pre><p>排序算法下界:最坏情况下，任何比较排序算法都需要<a href="n*lgn">欧姆</a>次比较. 推论:堆排序,归并排序都是渐近最优的比较排序算法.</p><h3 id="计数排序">2.计数排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序:n个元素为0~k之间的整数,当k=O(n)时,排序时间为O(n).</span></span><br><span class="line"><span class="comment">//A为原数组,B存放排序输出,C进行计数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> *A,<span class="type">int</span> *B,<span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *C=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) C[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) C[A[j]]+=<span class="number">1</span>;        <span class="comment">//C[i]记录等于i的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) C[i]=C[i]+C[i<span class="number">-1</span>]; <span class="comment">//C[i]记录小于等于i的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        B[C[A[j]]]=A[j];    <span class="comment">//C[A[j]]中为小于等于A[j]的元素个数,这些元素储存在下标0~C[A[j]]-1的位置</span></span><br><span class="line">        C[A[j]]--;          <span class="comment">//元素不完全互异时,将下一个等于A[j]的元素,置于A[j]前一个位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口">滑动窗口</h2><pre><code>例:求序列的所有长度为k的连续子序列中,最大的数字种类数.</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k,cnt,ans,a[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        s.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">int</span>)s.size!=k) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        m[a[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            m[a[i-k]]--;</span><br><span class="line">            <span class="keyword">if</span>(m[a[i-k]]==<span class="number">0</span>) m.erase(a[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,(<span class="type">int</span>)m.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划">动态规划:</h2><p>1.最优子结构：可由子问题最优解，构造原问题的最优解。（子问题无关，不共享资源，结果互不影响） 2.重叠子问题：反复求解相同的子问题，将解存入备忘录中。 （分治：每一步生成全新的子问题） ### 1.钢管切割：总长度固定，不同长度不同售价 r[n]=max(p[i]+r[n-i]).i=1~n. C语言实现:θ(n^2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY -2147483648</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_cut_rod_solution</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n,<span class="type">int</span> *s)</span>&#123;       <span class="comment">//打印长度为n的最优切割方案</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[n]);</span><br><span class="line">        n-=s[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3.自底向上递归:θ(n^2)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bottom_up_cut_rod</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *r=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));    <span class="comment">//辅助数组,r记录最大利润</span></span><br><span class="line">    <span class="type">int</span> *s=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));    <span class="comment">//s记录切割方案</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q&lt;p[i]+r[j-i])</span><br><span class="line">            &#123;</span><br><span class="line">                q=p[i]+r[j-i];</span><br><span class="line">                s[j]=i;     <span class="comment">//s[j]:规模为j的子问题中,第一段钢条的最优切割长度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//q=max(q,p[i]+r[j-i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[j]=q;</span><br><span class="line">    &#125;</span><br><span class="line">    print_cut_rod_solution(p,n,s);</span><br><span class="line">    <span class="keyword">return</span> r[n];        <span class="comment">//最大总利润</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> p[<span class="number">10005</span>];     <span class="comment">//p[i]:长度为i的钢管价格</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;p[i]);</span><br><span class="line">    bottom_up_cut_rod(p,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 变式：每次切割固定成本c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">modify_cut_rod</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *r=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q=p[j];         <span class="comment">//不切割,长度j整段出售</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=j<span class="number">-1</span>;i++) q=max(q,p[i]+r[j-i]-c);</span><br><span class="line">        r[j]=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 2.矩阵链乘法:求完全括号化方案，使得计算A1A2...An所需标量乘法次数最少. 括号化方案数量:卡特兰数 设:矩阵Ai的大小为：p[i-1]xp[i]. m[i,j]=min(m[i,k]+m[k+1,j]+p[i-1]<em>p[k]</em>p[j]),i&lt;j. #### (1)自底向上<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.自底向上</span></span><br><span class="line"><span class="comment">//p=&lt;p0,...,pn&gt;.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY_2 2147483647</span></span><br><span class="line"><span class="type">int</span> m[N][N],s[N][N];     <span class="comment">//m记录Ai...Aj结果,s[i][j]记录m[i][j]对应最优分割点k</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">matrix_chain_order</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)       <span class="comment">//长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=n-l+<span class="number">1</span>;    <span class="comment">//保持i~j长度为l</span></span><br><span class="line">            m[i][j]=INFINITY_2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> q=m[i][k]+m[k+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j]=q;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### (2)带备忘的自顶向下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lookup_chain</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[i][j]&lt;INFINITY_2) <span class="keyword">return</span> m[i][j];      <span class="comment">//查询是否记录</span></span><br><span class="line">    <span class="keyword">if</span>(i==j) m[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=lookup_chain(p,i,k)+lookup_chain(p,k+<span class="number">1</span>,j)+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">            <span class="keyword">if</span>(q&lt;m[i][j]) m[i][j]=q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memorized_matrix_chain</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++) m[i][j]=INFINITY_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lookup_chain(p,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 构造最优解：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s[i][j]记录m[i][j]对应最优分割点k</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_optimal_parens</span><span class="params">(<span class="type">int</span> **s,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) &#123;<span class="built_in">printf</span>(<span class="string">&quot;A%d&quot;</span>,i);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    print_optimal_parens(s,i,s[i][j]);</span><br><span class="line">    print_optimal_parens(s,s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="流水线调度">3.流水线调度</h3><p>dp[i][j]:在流水线上完成第j个步骤时的最小时间。 for(int k=0;k&lt;3;k++) dp[i][j] = min(dp[i][j],(j&gt;=1?dp[k][j-1]+t[k][i]:0LL)+p[i][j]);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 22</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN][MAXM], t[MAXN][MAXN];</span><br><span class="line"><span class="comment">//a[i][j]:流水线i处理j的时间; t[i][j]:流水线i-&gt;j的转移时间.</span></span><br><span class="line">ll dp[MAXN][MAXM],nxt[MAXN][MAXM]; <span class="comment">//dp[i][j]:在流水线i上完成j时的最小时间.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) &#123;</span><br><span class="line">        <span class="type">int</span> m,n;<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;      <span class="comment">//n条流水线,m个步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">cin</span> &gt;&gt; t[i][j];</span><br><span class="line">        <span class="comment">//for(int i = 1; i &lt;= n; i++) dp[i][m] = a[i][m];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j--)    <span class="comment">//逆推:从终点出发,0开始计时,前往起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = inf;             <span class="comment">//当前在第i条流水线完成j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)        <span class="comment">//遍历：在第k条流水线完成j+1.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ll p=(j&lt;=m<span class="number">-1</span>?dp[k][j+<span class="number">1</span>]+t[i][k]:<span class="number">0LL</span>)+a[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (p &lt; dp[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = p;</span><br><span class="line">                        nxt[i][j] = k;      <span class="comment">//第i条上完成j后,下一步转移至第k条最佳.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=dp[<span class="number">1</span>][<span class="number">1</span>],cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;dp[i][<span class="number">1</span>]) &#123;ans=dp[i][<span class="number">1</span>];cur=i;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Station&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: Line&quot;</span>&lt;&lt;cur&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            cur = nxt[cur][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 4.OBST(最优二叉搜索树）--区间dp 关键字的升序序列：K=&lt;k1,...,kn&gt;,有：k1&lt;...&lt;kn.--概率pi.(内部节点) n+1个伪关键字：d0,...,dn.有：ki&lt;di&lt;k(i+1).--概率qi.(叶节点) 有:sum(pi)+sum(qi)=1. 搜索代价：E=sum[(depth(ki)+1)*pi]+sum[(depth(di)+1)*qi] =1+sum[depth(ki)*pi]+sum[depth(di)*qi].<p></p><p>设:e[i,j]表示:在包含关键字ki,...,kj的OBST中搜索一次的期望代价. w[i,j]表示:包含关键字ki,...,kj的子树,概率之和: w[i,j]=sum(pl)(l=i<sub>j)+sum(ql)(l=i-1</sub>j). root[i,j]表示包含关键字ki,...,kj的子树的根.</p><p>递归公式:e[i,j]=q[i-1] if j==i-1. =min{e[i,r-1]+e[r+1,j]+w(i,j)}(i&lt;=r&lt;=j) if i&lt;=j.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="type">int</span> e[MAXN+<span class="number">1</span>][MAXN+<span class="number">1</span>],w[MAXN+<span class="number">1</span>][MAXN+<span class="number">1</span>],root[MAXN+<span class="number">1</span>][MAXN+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//e[1...n+1,0...n],w[1...n+1,0...n],root</span></span><br><span class="line"><span class="comment">//(p1,...,pn),(q0,...,qn)为概率,规模n.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OBST</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> *q,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;e[i][i<span class="number">-1</span>]=w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+l<span class="number">-1</span>;e[i][j]=inf;</span><br><span class="line">            w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=i;r&lt;=j;r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t=e[i][r<span class="number">-1</span>]+e[r+<span class="number">1</span>][j]+w[i][j];</span><br><span class="line">                <span class="keyword">if</span>(t&lt;e[i][j])&#123;e[i][j]=t;root[i][j]=r;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列lcs--on2">5.最长公共子序列(LCS)--O(n^2)</h3><p>c[i][j]=0. if i==0||j==0. c[i-1][j-1]+1. if i,j&gt;0&amp;&amp;x[i]=y[j]. max(c[i][j-1],c[i-1][j]). if i,j&gt;0&amp;&amp;x[i]!=y[j].</p><p>θ(mn)个子问题.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c[i,j]记录:Xi,Yj的LCS长度.</span></span><br><span class="line"><span class="comment">//可按行主次序计算:先从左至右i第一行,再第二行...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_M 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_N 100</span></span><br><span class="line"><span class="type">int</span> c[max_M+<span class="number">1</span>][max_N+<span class="number">1</span>],b[max_M][max_N],a[max_M+<span class="number">1</span>][max_N+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//a[i][j]记录:Xi,Yj的最长公共子串长度(字符连续).</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LCS</span><span class="params">(<span class="type">char</span> *X,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;        <span class="comment">//时间复杂度:O(m+n).</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[i][j]==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_LCS(X,i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,X[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">0</span>) print_LCS(X,i<span class="number">-1</span>,j);</span><br><span class="line">    <span class="keyword">else</span> print_LCS(X,i,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间复杂度:θ(mn).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LCS_length</span><span class="params">(<span class="type">char</span> *X,<span class="type">char</span> *Y,<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(X[i]==Y[j])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;b[i][j]=<span class="number">-1</span>;   <span class="comment">//LCS</span></span><br><span class="line">                a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;          <span class="comment">//最长公共子串</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[i<span class="number">-1</span>][j]&gt;=c[i][j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i<span class="number">-1</span>][j];b[i][j]=<span class="number">0</span>;        <span class="comment">//LCS</span></span><br><span class="line">                a[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i][j<span class="number">-1</span>];b[i][j]=<span class="number">1</span>;        <span class="comment">//LCS</span></span><br><span class="line">                a[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_LCS(X,m,n);</span><br><span class="line">    <span class="keyword">return</span> c[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A[<span class="number">2005</span>],B[<span class="number">2005</span>],C[<span class="number">2005</span>],D[<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);getchar();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(A,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);</span><br><span class="line">        <span class="built_in">memset</span>(B,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);</span><br><span class="line">        <span class="built_in">memset</span>(D,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">2005</span>);</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2006</span>*<span class="number">2006</span>);</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2006</span>*<span class="number">2006</span>);</span><br><span class="line">        ans1=<span class="number">0</span>;ans2=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        fgets(A,<span class="number">2003</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        fgets(B,<span class="number">2003</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="type">int</span> lenA=<span class="built_in">strlen</span>(A),lenB=<span class="built_in">strlen</span>(B);</span><br><span class="line">        <span class="keyword">if</span>(A[lenA<span class="number">-1</span>]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[lenA<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            lenA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(B[lenB<span class="number">-1</span>]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B[lenB<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            lenB--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(&amp;C[<span class="number">1</span>],A);<span class="built_in">strcpy</span>(&amp;D[<span class="number">1</span>],B);</span><br><span class="line">        <span class="comment">//printf(&quot;%d %d\n&quot;,lenA,lenB);</span></span><br><span class="line">        LCS_length(C,D,lenA,lenB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans2,ans1);</span><br><span class="line">    &#125;</span><br><span class="line">    ans1=c[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;ans2) ans2=a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 6.最长上升子序列(LIS)--O(n*logn)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度:O(n*logn);空间复杂度:O(n).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>,n=(<span class="type">int</span>)nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">d</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span>;   <span class="comment">//d[i]:长度为i的LIS的末尾元素最小值</span></span><br><span class="line">    d[len]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//初始len=1,d[1]=nums[0].</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)            <span class="comment">//将nums[i]加在序列末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;d[len]) d[++len]=nums[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">1</span>,r=len,pos=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//在d数组中二分查找,找到第一个(最大的)比nums[i]小的数d[k],更新:d[k+1]=nums[i].</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[mid]&lt;nums[i]) &#123;pos=mid;l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d[pos+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>拓展：最长公共上升子序列 思路：f[i][j]表示:所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j]) maxv = max(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) ans = max(f[n][i], ans);</span><br></pre></td></tr></table></figure><p></p><h3 id="背包问题">7.背包问题</h3><h4 id="背包一种物品使用一次">(1)0-1背包:一种物品使用一次</h4><p>压缩为一维:f[j]表示:背包容量不超过j时的最大价值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N]; <span class="comment">//w[i]是价值，v[i]是体积</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">//n件物品和体积限制m</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)              <span class="comment">//滚动数组,倒序优化</span></span><br><span class="line">            f[j] = max(f[j],f[j-v[i]]+w[i]); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维动态规划</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;goods;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="comment">//#define max(a,b) a&gt;b?a:b</span></span><br><span class="line">goods all[N+<span class="number">1</span>];     <span class="comment">//all[1...n]记录商品</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Knapsack</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span>&#123;        <span class="comment">//n为商品数量,W为背包承载量</span></span><br><span class="line">    <span class="type">int</span> **K=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) K[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(W+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//K[i][j]表示:承载量为j的背包,装前i件物品,所得最大价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) K[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=W;j++) K[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//是否将第i件商品装入背包</span></span><br><span class="line">            <span class="keyword">if</span>(j&lt;all[i].weight) K[i][j]=K[i<span class="number">-1</span>][j];      <span class="comment">//一定装不进</span></span><br><span class="line">            <span class="keyword">else</span> K[i][j]=max(K[i<span class="number">-1</span>][j],K[i<span class="number">-1</span>][j-all[i].weight]+all[i].val);     <span class="comment">//装/不装</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return K;</span></span><br><span class="line">    <span class="keyword">return</span> K[n][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T,n,V;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;V);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;all[i].val,&amp;all[i].weight);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Knapsack(n,V));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### (2)完全背包:每种物品可使用无限次 与0-1背包对比： 二维:f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]); //01背包 f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包 一维:如代码.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N]; <span class="comment">//w[i]是价值，v[i]是体积</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">//n件物品和体积限制m</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)              <span class="comment">//滚动数组,正序优化</span></span><br><span class="line">            f[j] = max(f[j],f[j-v[i]]+w[i]); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### (3)多重背包:每件物品最多有si件. 无法优化为一维. f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); //和完全背包问题的朴素代码一样<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;     <span class="comment">//n件物品和体积限制m</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];   <span class="comment">//s[i]:最多数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)          <span class="comment">//枚举种数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)         <span class="comment">//然后枚举体积，注意，这里不能从v[i]开始枚举</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];k++)  <span class="comment">//最后枚举第i种物品的个数</span></span><br><span class="line">                f[i][j] = max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">#### (<span class="number">4</span>)分组背包:同一组内物品最多选一个</span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N];<span class="comment">//第i组第j个物品的体积和价值</span></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//第i组物品的数量</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;          <span class="comment">//n个组,背包容量m.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i];              <span class="comment">//每组物品数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//第i组第j个物品的体积/价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)           <span class="comment">//枚举物品组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)       <span class="comment">//枚举体积</span></span><br><span class="line">            <span class="comment">//枚举决策，也就是选这个物品组的哪个物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                    f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="一些记录">8.一些记录</h3><pre><code>长高问题：dp[0..k][0..n],dp[i][j]为:完成第j个点时,跳过i次深坑,得到的最大身高(应有:i&lt;=j)</code></pre><h2 id="贪心">贪心</h2><h3 id="活动选择">1.活动选择</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法:局部最优解,导致全部最优解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.活动选择问题:找最大兼容活动集</span></span><br><span class="line"><span class="comment">//动态规划:c[i,j]=max&#123;c[i,k]+c[k,j]+1&#125;--(ak属于Sij)</span></span><br><span class="line"><span class="comment">//贪心选择:反复选择结束时间最早的活动,保留兼容的活动</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> finish;</span><br><span class="line">&#125;act;</span><br><span class="line">act all[N];     <span class="comment">//储存所有活动的数组</span></span><br><span class="line">act ans[N];     <span class="comment">//答案数组</span></span><br><span class="line"><span class="type">int</span> n;          <span class="comment">//活动总个数</span></span><br><span class="line"><span class="type">int</span> cnt;        <span class="comment">//答案数组中活动个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1,<span class="type">const</span> <span class="type">void</span> *e2)</span>&#123;</span><br><span class="line">    act *p=(act *)e1,*q=(act *)e2;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;finish-q-&gt;finish;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//qsort(&amp;all[1],n,sizeof(act),cmp);         //all数组按完成时间升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求解时调用:recursive_activity_selector(0,n).</span></span><br><span class="line"><span class="comment">//(已排序时)时间复杂度:theta(n).</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursive_activity_selector</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n)</span>&#123;      <span class="comment">//返回Sk的最大兼容活动集</span></span><br><span class="line">    <span class="type">int</span> m=k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m&lt;=n&amp;&amp;all[m].start&lt;all[k].finish) m=m+<span class="number">1</span>;      <span class="comment">//找与活动k兼容的,最早结束的活动</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[cnt++]=all[m];</span><br><span class="line">        recursive_activity_selector(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T,n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;all[i].start,&amp;all[i].finish);all[i].finish+=all[i].start;&#125;</span><br><span class="line">        qsort(&amp;all[<span class="number">1</span>],n,<span class="keyword">sizeof</span>(act),cmp);         <span class="comment">//all数组按完成时间升序排序</span></span><br><span class="line">        recursive_activity_selector(<span class="number">0</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="huffman编码">2.Huffman编码</h3><p>变长编码,每个字符用唯一的一个二进制串表示(性质：没有任何码字是其他码字的前缀） 问题：构造Huffman树，使得:B(T)=c.freq<em>d(c)最小,c.freq为点权重，d(c)为点深度 贪心算法构造:n-1次合并,每次合并时:最小优先队列(最小堆实现)选取最小两个元素,合并为一个元素,插入队列--O(n</em>lgn)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个不可分割钢条为叶节点,从树顶往下切割,非根节点为当前钢条长度,问题转为:求Huffman树的最小代价</span></span><br><span class="line"><span class="comment">//类Huffman树:选取当前长度最小的两个点,合并</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200086</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; q;</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ll x = q.top();q.pop();</span><br><span class="line">        x += q.top();q.pop();</span><br><span class="line">        ans += x * <span class="number">2</span>;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>### 3.合法括号序列<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心策略填括号.先计算需要新填入的左/右括号数量,在不超过的前提下,优先填左括号.</span></span><br><span class="line"><span class="comment">//时间复杂度:O(n).</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> S[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> l,r,no;</span><br><span class="line"><span class="type">int</span> left,right;     <span class="comment">//left,right记录当前位置之前的:左/右括号数量</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//奇数长度,一定不能构成合法括号序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)    <span class="comment">//初始化,统计左/右/待填括号数量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>) l++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S[i]==<span class="string">&#x27;)&#x27;</span>) r++;</span><br><span class="line">        <span class="keyword">else</span> no++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d,%d,%d\n&quot;,l,r,no);</span></span><br><span class="line">    <span class="keyword">if</span>(l+no&lt;r||r+no&lt;l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    l=n/<span class="number">2</span>-l;r=n/<span class="number">2</span>-r;        <span class="comment">//此时l,r为可新填入的左/右括号数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;=right&amp;&amp;left!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//left==right不满足:S任一非空且非自身前缀均不为合法括号序列</span></span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S[i]==<span class="string">&#x27;)&#x27;</span>) right++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;n/<span class="number">2</span>&amp;&amp;l&gt;<span class="number">0</span>)    <span class="comment">//优先填左括号</span></span><br><span class="line">            &#123;</span><br><span class="line">                S[i]=<span class="string">&#x27;(&#x27;</span>;left++;l--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                S[i]=<span class="string">&#x27;)&#x27;</span>;right++;r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%s\n&quot;,S);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,S);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="keyword">if</span>(S[len<span class="number">-1</span>]==<span class="string">&#x27;\n&#x27;</span>) &#123;S[len<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;len--;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!judge(n)) <span class="built_in">printf</span>(<span class="string">&quot;:(&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="求不超过n的最大回文串">4.求不超过n的最大回文串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, mid;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">leq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &lt; a[i]) <span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    mid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n; i &lt;= j; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = b[j] = a[i];</span><br><span class="line">        mid = i;</span><br><span class="line">    &#125;</span><br><span class="line">    b[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (leq())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[mid]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &amp;&amp; b[i] &lt; <span class="string">&#x27;0&#x27;</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += <span class="number">10</span>;</span><br><span class="line">        b[i - <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mid; i++)</span><br><span class="line">        b[n - i + <span class="number">1</span>] = b[i];</span><br><span class="line">    <span class="keyword">if</span> (b[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; leq())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        b[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    b[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论">图论</h2><h3 id="dfs">1.DFS</h3><h4 id="例n元数--依次选择每个数位上的数.">例:n元数--依次选择每个数位上的数.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各位的n次方之和等于该数,该数共n位.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll pw[<span class="number">10</span>],cnt[<span class="number">10</span>],bit[<span class="number">10</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(ll s)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) bit[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        bit[s%<span class="number">10</span>]++;</span><br><span class="line">        s/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]!=bit[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ubound:可供选择的n次方最大的底数;num为当前的n次方之和</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> bound,ll num,ll limit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;limit/<span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">    ans+=check(num)*num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=bound;i++)&#123;</span><br><span class="line">        cnt[i]++;</span><br><span class="line">        dfs(i,num+pw[i],limit*<span class="number">10</span>);</span><br><span class="line">        cnt[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;         <span class="comment">//n次方</span></span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            cnt[i]=<span class="number">0</span>;pw[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) pw[i]*=i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs">2.BFS</h3><h4 id="例地图中每个格子有可向上下左右移动的步数求11-nm的最小次数.">例:地图中每个格子,有可向上下左右移动的步数,求(1,1)-&gt;(n,m)的最小次数.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1,1]-&gt;[n,m]最小次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n为总行/列数;l为当前格子可向上/下/左/右移动的步数;</span></span><br><span class="line">ll <span class="title function_">calc</span><span class="params">(ll x,ll step,ll n,<span class="type">int</span> neg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(neg)&#123;</span><br><span class="line">        ll a=(x-step%(<span class="number">2</span>*n<span class="number">-2</span>)+(n<span class="number">-2</span>)+(<span class="number">2</span>*n<span class="number">-2</span>))%(<span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=n<span class="number">-2</span>) <span class="keyword">return</span> a-(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n<span class="number">-2</span>)-a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ll a=(x+step%(<span class="number">2</span>*n<span class="number">-2</span>))%(<span class="number">2</span>*n<span class="number">-2</span>);     <span class="comment">//n+(n-1)=2n-2.</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;=n) <span class="keyword">return</span> <span class="number">2</span>*n<span class="number">-2</span>-a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于每个格子处有不同的指定步数,且均可向上下左右移动,因此无法用dp.</span></span><br><span class="line"><span class="comment">//BFS访问,队列记录.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tt;<span class="built_in">cin</span>&gt;&gt;tt;</span><br><span class="line">    <span class="keyword">while</span>(tt--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;a (n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;&gt;vis (n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">array</span>&lt;ll,<span class="number">3</span>&gt;&gt;q;</span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        ll ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ll r=q.front()[<span class="number">0</span>],c=q.front()[<span class="number">1</span>],w=q.front()[<span class="number">2</span>];</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(r==n<span class="number">-1</span>&amp;&amp;c==m<span class="number">-1</span>) &#123;ans=w;<span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> step=a[r][c];</span><br><span class="line">            ll nr,nc;</span><br><span class="line">            nr=calc(r,step,n,<span class="number">0</span>);nc=c;</span><br><span class="line">            <span class="keyword">if</span>(!vis[nr][nc]) &#123;vis[nr][nc]=<span class="literal">true</span>;q.push(&#123;nr,nc,w+<span class="number">1</span>&#125;);&#125;</span><br><span class="line">            nr=calc(r,step,n,<span class="number">1</span>);nc=c;</span><br><span class="line">            <span class="keyword">if</span>(!vis[nr][nc]) &#123;vis[nr][nc]=<span class="literal">true</span>;q.push(&#123;nr,nc,w+<span class="number">1</span>&#125;);&#125;</span><br><span class="line">            nr=r;nc=calc(c,step,m,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(!vis[nr][nc]) &#123;vis[nr][nc]=<span class="literal">true</span>;q.push(&#123;nr,nc,w+<span class="number">1</span>&#125;);&#125;</span><br><span class="line">            nr=r;nc=calc(c,step,m,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!vis[nr][nc]) &#123;vis[nr][nc]=<span class="literal">true</span>;q.push(&#123;nr,nc,w+<span class="number">1</span>&#125;);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单源最短路问题">3.单源最短路问题</h3><h4 id="bellford可能包括负环">(1)Bellford:可能包括负环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 6005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) a&lt;b?a:b</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">Edges</span>[<span class="title">M</span>];</span></span><br><span class="line"><span class="type">int</span> dis[N];     <span class="comment">//dis[i]记录:源点到点i的距离(i=1,...,n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">//n个点,m条边</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BellFord</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    fill(dis,dis+n+<span class="number">1</span>,inf);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)    <span class="comment">//每条边松弛n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[Edges[j].v]=min(dis[Edges[j].v],dis[Edges[j].u]+Edges[j].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[Edges[j].v]&gt;dis[Edges[j].u]+Edges[j].w) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//有负环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> abyss</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;Edges[i].u&gt;&gt;Edges[i].v&gt;&gt;Edges[i].w;  <span class="comment">//输入边</span></span><br><span class="line">        <span class="type">bool</span> ans=BellFord(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="literal">false</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;boo how\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;(i==n?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dijkstra算法无向图无负环">(2)Dijkstra算法：无向图,无负环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无向图：单源最短路径问题</span></span><br><span class="line"><span class="comment">//无负边,无负环--Dijkstra</span></span><br><span class="line"><span class="comment">//1.已确定点集S,未确定点集T,初始化所有点属于T集合,dis(s)=0,其他点dis=inf;</span></span><br><span class="line"><span class="comment">//2.不断从T中选取dis最小的节点u,加入S中;</span></span><br><span class="line"><span class="comment">//3.对u的所有出边执行松弛操作.dis(v)=min(dis(v),dis(u)+w).</span></span><br><span class="line"><span class="comment">//贪心构建集合S;选取dis最小的点,用优先队列实现O(MlogM).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一:邻接表实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span> ,<span class="type">long</span> <span class="type">long</span>&gt;&gt;&gt;g;      <span class="comment">//g[u]存储u的出边及权重构成的pair</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;dis;</span><br><span class="line">    Dijkstra(<span class="type">int</span> k):n(k)&#123;</span><br><span class="line">        g.resize(n+<span class="number">1</span>);</span><br><span class="line">        dis.resize(n+<span class="number">1</span>,inf);</span><br><span class="line">        <span class="comment">//resize意义:如果n+1小于当前容器大小:保留,保留前n+1个元素,去除多余的值;</span></span><br><span class="line">        <span class="comment">//若n+1大于当前容器大小,在结尾插入一定数量的inf,使大小达标.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">        g[u].emplace_back(v,w);     <span class="comment">//加入u的出边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;vis(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;,<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;,greater&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;&gt;q;</span><br><span class="line">            <span class="comment">//小根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;       <span class="comment">//注意！再重新赋值一次</span></span><br><span class="line">        dis[s]=<span class="number">0</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.top().second;       <span class="comment">//q中存储&lt;dis,u&gt;对:u为点编号</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;        <span class="comment">//加入已访问的点集S</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:g[u])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+w) dis[v]=dis[u]+w;</span><br><span class="line">                q.push(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二：链式前向星实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra2</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;head;                <span class="comment">//head[u]:点u的第一条出边编号</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;nxt;                 <span class="comment">//nxt[i]:边i的下一条边编号</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>&gt;&gt;to;  <span class="comment">//(v,w)</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;dis;</span><br><span class="line">    Dijkstra2(<span class="type">int</span> k):n(k)&#123;</span><br><span class="line">        head.resize(n+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        dis.resize(n+<span class="number">1</span>,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=nxt.size();</span><br><span class="line">        to.emplace_back(v,w);</span><br><span class="line">        nxt.push_back(head[u]);</span><br><span class="line">        head[u]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;vis(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;,<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;,greater&lt;<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">        dis[s]=<span class="number">0</span>;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="type">int</span> u=q.top().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=nxt[i])       <span class="comment">//遍历u的出边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v,w]=to[i];</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+w) dis[v]=dis[u]+w;</span><br><span class="line">                q.push(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">    cin.tie(0);</span></span><br><span class="line"><span class="comment">    int n,m,s,x,y;      //n个点,m条边,s为源点</span></span><br><span class="line"><span class="comment">    long long t0,t;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t0;</span></span><br><span class="line"><span class="comment">    Dijkstra prob(n);</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;t;</span></span><br><span class="line"><span class="comment">        prob.add(x,y,t);        //无向图双向插入</span></span><br><span class="line"><span class="comment">        //prob.add(y,x,t);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    prob.solve(s);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //输出:1.不可到达的点;2.时间大于t0的点</span></span><br><span class="line"><span class="comment">    int cnt=0;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt;ans;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(prob.dis[i]==inf||prob.dis[i]&gt;t0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            cnt++;</span></span><br><span class="line"><span class="comment">            ans.push_back(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt; cnt&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    for(auto i:ans) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;(prob.dis[i]==inf?-1:prob.dis[i])&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变式:E4.D</span></span><br><span class="line"><span class="comment">//求出1到n,且经过点&#123;p1,...,pk&#125;中至少一点的最短路径.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">    cin.tie(0);</span></span><br><span class="line"><span class="comment">    int t;cin&gt;&gt;t;</span></span><br><span class="line"><span class="comment">    while(t--)&#123;</span></span><br><span class="line"><span class="comment">        int n,m,k;cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;mid(k);      //中间点集</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;k;i++) cin&gt;&gt;mid[i];</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Dijkstra d(n);</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int x,y;long long w;</span></span><br><span class="line"><span class="comment">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span></span><br><span class="line"><span class="comment">            d.add(x,y,w);</span></span><br><span class="line"><span class="comment">            d.add(y,x,w);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        d.solve(1);         //求点1到所有点的最短距离</span></span><br><span class="line"><span class="comment">        vector&lt;long long&gt;d1(n+1);</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++) d1[i]=d.dis[i];</span></span><br><span class="line"><span class="comment">        d.solve(n);         //求点n到所有点的最短距离</span></span><br><span class="line"><span class="comment">        long long ans=inf;</span></span><br><span class="line"><span class="comment">        //分别求点1,点n到以中间点集中每个点的距离之和</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;k;i++) ans=min(ans,d1[mid[i]]+d.dis[mid[i]]);</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;(ans&lt;inf?ans:-1)&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="所有点间的最短路问题--floyd">4.所有点间的最短路问题--Floyd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N][N];        <span class="comment">//各顶点间最短距离</span></span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;       <span class="comment">//O(V^3).</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++) dis[i][j]=inf;</span><br><span class="line">        dis[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        dis[u][v]=min(dis[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(dis[u][v]&gt;inf/<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[u][v]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序">5.拓扑排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//拓扑排序(对有向无环图):</span></span><br><span class="line"><span class="comment">//1.定义队列L,放入所有入度为0的点;</span></span><br><span class="line"><span class="comment">//2.取队首节点s,删除所有以s为起点的边,更新终点的入度,为0时加入队列L;</span></span><br><span class="line"><span class="comment">//3.重复处理,直至队列L为空.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//法一：链式向前星储存图</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define N 100005</span></span><br><span class="line"><span class="comment">#define M 400005</span></span><br><span class="line"><span class="comment">struct edge&#123;        //链式向前星储存图</span></span><br><span class="line"><span class="comment">    int to,next,weight;        //to为:边的终点;next:下一条边编号</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">edge G[M];     //G[i]表示:编号为i的下一条边编号</span></span><br><span class="line"><span class="comment">int head[N];       //head[u]表示:以u为起点的第一条边编号</span></span><br><span class="line"><span class="comment">int weight[M];</span></span><br><span class="line"><span class="comment">int cnt;        //边编号</span></span><br><span class="line"><span class="comment">int din[N];    //点的入度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//加入边:链表头插法--将当前边插入当前起点的第一条出边</span></span><br><span class="line"><span class="comment">//每次为当前边分配新编号(++cnt);获取当前起点的第一条出边编号,让当前边指向该边,起点的第一条出边更新为当前边</span></span><br><span class="line"><span class="comment">void add(int u,int v,int w)&#123;    //(u,v)为有向边,w为权重</span></span><br><span class="line"><span class="comment">    G[++cnt].next=head[u];</span></span><br><span class="line"><span class="comment">    head[u]=cnt;</span></span><br><span class="line"><span class="comment">    G[cnt].to=v;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">priority_queue&lt;int,vector&lt;int&gt;, less&lt;int&gt;&gt; L;       //拓扑序列(最大优先队列)--保证输出字典序最大的拓扑排序</span></span><br><span class="line"><span class="comment">//删除所有u的出边</span></span><br><span class="line"><span class="comment">void deleteEdge(int u)&#123;</span></span><br><span class="line"><span class="comment">    for(int i=head[u];i!=0;i=G[i].next)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        din[G[i].to]--;         //终点入度-1</span></span><br><span class="line"><span class="comment">        if(din[G[i].to]==0) L.push(G[i].to);     //入度为0的点加入队列L</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int n,m,s,e;cin&gt;&gt;n&gt;&gt;m;      //n个点,m条有向边</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;s&gt;&gt;e;</span></span><br><span class="line"><span class="comment">        add(s,e,1);</span></span><br><span class="line"><span class="comment">        din[e]++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(!din[i]) L.push(i);        //入度为0的点加入队列</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    while(!L.empty())&#123;</span></span><br><span class="line"><span class="comment">        int cur=L.top();      //取队首元素</span></span><br><span class="line"><span class="comment">        L.pop();</span></span><br><span class="line"><span class="comment">        deleteEdge(cur);</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;cur&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//法二：邻接表储存图</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 400005</span></span><br><span class="line"><span class="type">int</span> n,m,din[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[M];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        e[u].push_back(v);</span><br><span class="line">        din[v]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(din[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.top();q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            din[v]-=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(din[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键路径问题">关键路径问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点间有依赖关系,同一时间可平行访问多个顶点,求访问完所有顶点的最小时间.</span></span><br><span class="line"><span class="comment">//链式前向星实现:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define N 100005</span></span><br><span class="line"><span class="comment">#define M 200005</span></span><br><span class="line"><span class="comment">#define max(a,b) a&gt;b?a:b</span></span><br><span class="line"><span class="comment">#define min(a,b) a&lt;b?a:b</span></span><br><span class="line"><span class="comment">int head[N],nxt[M],to[M],cnt;   //head[u]:点u第一条出边编号; nxt[i]:边i的下一条边编号; to[i]:边i的终点</span></span><br><span class="line"><span class="comment">int inDegree[N];        //点i的入度</span></span><br><span class="line"><span class="comment">int fTime[N];           //fTime[u]:点u的完成时间</span></span><br><span class="line"><span class="comment">int n,m;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int q[N];       //队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addEdge(int u,int v)&#123;</span></span><br><span class="line"><span class="comment">    nxt[++cnt]=head[u];     //当前边的后继</span></span><br><span class="line"><span class="comment">    head[u]=cnt;            //更新u的第一条出边</span></span><br><span class="line"><span class="comment">    to[cnt]=v;</span></span><br><span class="line"><span class="comment">    inDegree[v]+=1;      //终点入度+=1.</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void solve()&#123;    //n个顶点,m条边</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++) head[i]=inDegree[i]=fTime[i]=0;   //初始化</span></span><br><span class="line"><span class="comment">    //memset(head,0,n+1);memset(inDegree,0,n+1);memset(fTime,0,n+1);cnt=0;  //使用会TLE?</span></span><br><span class="line"><span class="comment">    //memset(nxt,0,m+1);memset(to,0,m+1);</span></span><br><span class="line"><span class="comment">    int u,v;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;u&gt;&gt;v;</span></span><br><span class="line"><span class="comment">        addEdge(u,v);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    int ans=0;cnt=0;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    queue&lt;int&gt; q;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)       //加入入度为0的点</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(inDegree[i]==0) q.push(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    while(!q.empty())</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int x=q.front();</span></span><br><span class="line"><span class="comment">        q.pop();</span></span><br><span class="line"><span class="comment">        fTime[x]+=1;    //队首点x,完成</span></span><br><span class="line"><span class="comment">        ans=max(ans,fTime[x]);</span></span><br><span class="line"><span class="comment">        for(int i=head[x];i!=0;i=nxt[i])    //遍历x的出边</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            fTime[to[i]]=max(fTime[to[i]],fTime[x]);</span></span><br><span class="line"><span class="comment">            if(--inDegree[to[i]]==0) q.push(to[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int T;cin&gt;&gt;T;</span></span><br><span class="line"><span class="comment">    while(T--)&#123;</span></span><br><span class="line"><span class="comment">        cin&gt;&gt;n&gt;&gt;m;</span></span><br><span class="line"><span class="comment">        solve();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列操作另一种写法:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int front=1,rear=0;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(inDegree[i]==0) q[++rear]=i;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">while(front&lt;=rear)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int x=q[front++];</span></span><br><span class="line"><span class="comment">    fTime[x]+=1;</span></span><br><span class="line"><span class="comment">    ans=max(ans,fTime[x]);</span></span><br><span class="line"><span class="comment">    for(int i=head[x];i!=0;i=nxt[i])    //遍历x的出边</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        fTime[to[i]]=max(fTime[to[i]],fTime[x]);</span></span><br><span class="line"><span class="comment">        if(--inDegree[to[i]]==0) q[++rear]=to[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="最小生成树--kruskalomlogm">6.最小生成树--Kruskal:O(m*logm)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span> &#123;</span></span><br><span class="line">   public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    dsu(<span class="type">int</span> _n) : n(_n) &#123;</span><br><span class="line">        p.resize(n);</span><br><span class="line">        iota(p.begin(), p.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> (x == p[x] ? x : (p[x] = find(p[x]))); &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            p[x] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">array</span>&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&gt; e(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            --u; --v;</span><br><span class="line">            e[i] = &#123;u, v, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">p</span><span class="params">(m)</span>;</span><br><span class="line">        iota(p.begin(), p.end(), <span class="number">0</span>);</span><br><span class="line">        sort(p.begin(), p.end(), [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) &#123;</span><br><span class="line">            <span class="keyword">return</span> e[u][<span class="number">2</span>] &lt; e[v][<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        dsu d = dsu(n);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : p) &#123;</span><br><span class="line">            <span class="type">int</span> u = e[i][<span class="number">0</span>], v = e[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (d.unite(u, v)) &#123;</span><br><span class="line">                ans += e[i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网络流--dinic算法">7.网络流--Dinic算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dinic算法:n点m边有向图,每条边有最大容量,求s到t的最大流</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf=<span class="number">2005020600</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w,ans,dis[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,now[<span class="number">105</span>],head[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> to,net;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125; e[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> w)</span> &#123;</span><br><span class="line">    e[++tot].to=v;</span><br><span class="line">    e[tot].val=w;</span><br><span class="line">    e[tot].net=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">    </span><br><span class="line">    e[++tot].to=u;</span><br><span class="line">    e[tot].val=<span class="number">0</span>;</span><br><span class="line">    e[tot].net=head[v];</span><br><span class="line">    head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;  <span class="comment">//在残量网络中构造分层图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    now[s]=head[s];</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="type">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=e[i].net) &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].val&gt;<span class="number">0</span>&amp;&amp;dis[v]==inf) &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                dis[v]=dis[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">long</span> <span class="type">long</span> sum)</span> &#123;  <span class="comment">//sum是整条增广路对最大流的贡献</span></span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k,res=<span class="number">0</span>;  <span class="comment">//k是当前最小的剩余容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=now[x];i&amp;&amp;sum;i=e[i].net) &#123;</span><br><span class="line">        now[x]=i;  <span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].val&gt;<span class="number">0</span>&amp;&amp;(dis[v]==dis[x]+<span class="number">1</span>)) &#123;</span><br><span class="line">            k=dfs(v,min(sum,e[i].val));</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) dis[v]=inf;  <span class="comment">//剪枝，去掉增广完毕的点</span></span><br><span class="line">            e[i].val-=k;</span><br><span class="line">            e[i^<span class="number">1</span>].val+=k;</span><br><span class="line">            res+=k;  <span class="comment">//res表示经过该点的所有流量和（相当于流出的总量）</span></span><br><span class="line">            sum-=k;  <span class="comment">//sum表示经过该点的剩余流量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">            ans+=dfs(s,inf);  <span class="comment">//流量守恒（流入=流出）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        tot=<span class="number">1</span>;ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) now[i]=head[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二分图匹配on3">8.二分图匹配:O(n^3)</h3><h4 id="无权">(1)无权</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无权二分图匹配--HK算法:DFS,若每次调用时,匹配成功,则匹配数+1;否则不变.</span></span><br><span class="line"><span class="comment">//总复杂度:O(mn).</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HK</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;match;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;vis;</span><br><span class="line">    HK(<span class="type">int</span> _n):n(_n),g(_n+<span class="number">1</span>),match(_n+<span class="number">1</span>),vis(_n+<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> &#123;g[u].push_back(v);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:g[x])         <span class="comment">//遍历x所有出边的终点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!match[i]||find(match[i]))</span><br><span class="line">                    <span class="comment">//若该点未匹配,进行匹配;</span></span><br><span class="line">                    <span class="comment">//若已匹配,递归该点左边匹配的点,看是否能换一个点匹配,若可以,返回匹配成功;否则,匹配失败.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    match[i]=x;        <span class="comment">//match[y]=x表示:左边点x,匹配到右边点y.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fill(vis.begin(),vis.end(),<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(find(i)) res+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> first,second;</span><br><span class="line">&#125;male[<span class="number">405</span>],female[<span class="number">405</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    HK <span class="title function_">k</span><span class="params">(n)</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;male[i].first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;male[i].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;female[i].first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;female[i].second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(male[i].first&gt;=female[j].second&amp;&amp;female[j].first&gt;=male[i].second) k.add(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k.solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有权">(2)有权</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//E5.D</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ul unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;          <span class="comment">//两部各n个点的二分图</span></span><br><span class="line">ll x,y;         <span class="comment">//点坐标</span></span><br><span class="line">pr from[MAX],to[MAX];       <span class="comment">//记录左/右点坐标</span></span><br><span class="line"><span class="type">int</span> match[MAX];     <span class="comment">//右点匹配的左点</span></span><br><span class="line"><span class="type">int</span> va[MAX],vb[MAX];    <span class="comment">//标记点是否在交替路中</span></span><br><span class="line">ll w[MAX][MAX];</span><br><span class="line">ll la[MAX],lb[MAX];     <span class="comment">//左/右顶标</span></span><br><span class="line">ll slack[MAX];          <span class="comment">//松弛数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0xbf</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) w[i][j]=-<span class="built_in">abs</span>(from[i].first-to[j].first)-<span class="built_in">abs</span>(from[i].second-to[j].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>;            <span class="comment">//标记x在交替路中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)           <span class="comment">//遍历点x的所有边:可以据情况改动.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vb[y]) <span class="keyword">continue</span>;</span><br><span class="line">        ll t=la[x]+lb[y]-w[x][y];</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)            <span class="comment">//相等子图</span></span><br><span class="line">        &#123;</span><br><span class="line">            vb[y]=<span class="number">1</span>;            <span class="comment">//标记y在交替路中</span></span><br><span class="line">            <span class="keyword">if</span>(match[y]==<span class="number">-1</span>||dfs(match[y]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[y]=x;         <span class="comment">//找到增广路,更新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> slack[y]=min(slack[y],t);      <span class="comment">//不在相等子图中,更新松弛数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">KM</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));         <span class="comment">//初始化match[y]=-1:未匹配</span></span><br><span class="line">    <span class="built_in">memset</span>(lb,<span class="number">0</span>,<span class="keyword">sizeof</span>(lb));                <span class="comment">//初始化右顶标为0.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)           <span class="comment">//初始化左顶标为与之相连边的最大权值</span></span><br><span class="line">    &#123;</span><br><span class="line">        la[i]=-inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) la[i]=max(la[i],w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(slack,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(slack));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(va,<span class="number">0</span>,<span class="keyword">sizeof</span>(va));</span><br><span class="line">            <span class="built_in">memset</span>(vb,<span class="number">0</span>,<span class="keyword">sizeof</span>(vb));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i)) <span class="keyword">break</span>;           <span class="comment">//找到增广路,退出</span></span><br><span class="line">            ll d=inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vb[j]) d=min(d,slack[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)       <span class="comment">//更新顶标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(va[j]) la[j]-=d;     <span class="comment">//S中的点,左顶标-d.</span></span><br><span class="line">                <span class="keyword">if</span>(vb[j]) lb[j]+=d;     <span class="comment">//T中的点,右顶标+d.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=w[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            from[i]=<span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            to[i]=<span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        init();             <span class="comment">//init()环节:计算权重矩阵</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;-KM()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算几何">计算几何</h2><h3 id="判断三点是否共线三维">1.判断三点是否共线(三维)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span>  </span><br><span class="line">    <span class="type">double</span> x, y, z;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">areThreePointsCollinear</span><span class="params">(<span class="keyword">struct</span> Point p1, <span class="keyword">struct</span> Point p2, <span class="keyword">struct</span> Point p3)</span> &#123;  </span><br><span class="line">    <span class="comment">// 计算向量 v1 = p2 - p1, v2 = p3 - p2  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">v1</span> =</span> &#123;p2.x - p1.x, p2.y - p1.y, p2.z - p1.z&#125;;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">v2</span> =</span> &#123;p3.x - p2.x, p3.y - p2.y, p3.z - p2.z&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算向量叉积 v1 × v2，如果叉积为0，则三点共线  </span></span><br><span class="line">    <span class="type">double</span> crossProduct[<span class="number">3</span>] = &#123;v1.y * v2.z - v1.z * v2.y,  </span><br><span class="line">                             v1.z * v2.x - v1.x * v2.z,  </span><br><span class="line">                             v1.x * v2.y - v1.y * v2.x&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果叉积的绝对值小于一个很小的值（例如 1e-9），则可以认为叉积为0  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(crossProduct[<span class="number">0</span>]) &lt; <span class="number">1e-9</span> &amp;&amp; <span class="built_in">fabs</span>(crossProduct[<span class="number">1</span>]) &lt; <span class="number">1e-9</span> &amp;&amp; <span class="built_in">fabs</span>(crossProduct[<span class="number">2</span>]) &lt; <span class="number">1e-9</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="判断两线段位置关系相交平行无关">2.判断两线段位置关系:相交/平行/无关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ll x,y;</span><br><span class="line">&#125;P;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">direction</span><span class="params">(P pi,P pj,P pk)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pk.x-pi.x)*(pj.y-pi.y)-(pj.x-pi.x)*(pk.y-pi.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">on_Segment</span><span class="params">(P pi,P pj,P pk)</span>&#123;        <span class="comment">//pk是否在线段pipj上.</span></span><br><span class="line">    <span class="keyword">if</span>(min(pi.x,pj.x)&lt;=pk.x&amp;&amp;pk.x&lt;=max(pi.x,pj.x)&amp;&amp;min(pi.y,pj.y)&lt;=pk.y&amp;&amp;pk.y&lt;=max(pi.y,pj.y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">parallel</span><span class="params">(P p1,P p2,P p3,P p4)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((p2.y-p1.y)*(p4.x-p3.x)==(p4.y-p3.y)*(p2.x-p1.x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Segments_Intersect</span><span class="params">(P p1,P p2,P p3,P p4)</span>&#123;       <span class="comment">//判断线段p1p2和线段p3p4是否相交</span></span><br><span class="line">    ll d1=direction(p3,p4,p1);</span><br><span class="line">    ll d2=direction(p3,p4,p2);</span><br><span class="line">    ll d3=direction(p1,p2,p3);</span><br><span class="line">    ll d4=direction(p1,p2,p4);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(((d1&gt;<span class="number">0</span>&amp;&amp;d2&lt;<span class="number">0</span>)||(d1&lt;<span class="number">0</span>&amp;&amp;d2&gt;<span class="number">0</span>))&amp;&amp;((d3&gt;<span class="number">0</span>&amp;&amp;d4&lt;<span class="number">0</span>)||(d3&lt;<span class="number">0</span>&amp;&amp;d4&gt;<span class="number">0</span>))) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intersect\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d1==<span class="number">0</span>&amp;&amp;on_Segment(p3,p4,p1)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intersect\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d2==<span class="number">0</span>&amp;&amp;on_Segment(p3,p4,p2)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intersect\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d3==<span class="number">0</span>&amp;&amp;on_Segment(p1,p2,p3)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intersect\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d4==<span class="number">0</span>&amp;&amp;on_Segment(p1,p2,p4)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;intersect\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(parallel(p1,p2,p3,p4)) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;parallel\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;neither\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">P p1,q1,p2,q2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p1.x&gt;&gt;p1.y&gt;&gt;q1.x&gt;&gt;q1.y;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p2.x&gt;&gt;p2.y&gt;&gt;q2.x&gt;&gt;q2.y;</span><br><span class="line">        Segments_Intersect(p1,q1,p2,q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求点到线段最小距离">3.求点到线段最小距离</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pt</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line">    Pt p1,p2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">double</span> <span class="title function_">getDis</span><span class="params">(Pt p1,Pt p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p2.x-p1.x,<span class="number">2</span>)+<span class="built_in">pow</span>(p2.y-p1.y,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">disToSegment</span><span class="params">(Pt p,Segment l)</span>&#123;</span><br><span class="line">    <span class="type">double</span> len=getDis(l.p1, l.p2);</span><br><span class="line">    <span class="keyword">if</span> (len==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getDis(p, l.p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> v = ((p.x - l.p1.x) * (l.p2.x - l.p1.x) + (p.y - l.p1.y) * (l.p2.y - l.p1.y)) / <span class="built_in">pow</span>(len, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getDis(p, l.p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getDis(p, l.p2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pt u=&#123; l.p1.x+v*(l.p2.x-l.p1.x),l.p1.y+v*(l.p2.y-l.p1.y)&#125;;</span><br><span class="line">        <span class="keyword">return</span> getDis(p,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> xa,ya,xp,yp,xq,yq;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;xa&gt;&gt;ya&gt;&gt;xp&gt;&gt;yp&gt;&gt;xq&gt;&gt;yq;</span><br><span class="line">        Pt p =&#123;xa,ya&#125;;</span><br><span class="line">        Segment l = &#123;&#123;xp,yp&#125;,&#123;xq,yq&#125;&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>,disToSegment(p,l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求凸包面积">4.求凸包面积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:计算凸包面积</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y;</span><br><span class="line">    Vec() &#123;&#125;</span><br><span class="line">    Vec(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="title function_">len2</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> x * x + y * y; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">read</span><span class="params">()</span> &#123; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, x, y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Vec Point;</span><br><span class="line"></span><br><span class="line">Vec operator + (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123; <span class="keyword">return</span> Vec(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Vec operator - (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123; <span class="keyword">return</span> Vec(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Vec operator * (<span class="type">long</span> <span class="type">long</span> a, <span class="type">const</span> Vec &amp;b) &#123; <span class="keyword">return</span> Vec(a * b.x, a * b.y); &#125;</span><br><span class="line"><span class="comment">// cross product</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> operator * (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123; <span class="keyword">return</span> a.x * b.y - b.x * a.y; &#125;</span><br><span class="line"><span class="comment">// inner product</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> operator ^ (<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b) &#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span> &lt;Point&gt; Polygon;</span><br><span class="line"><span class="keyword">typedef</span> Polygon Points;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">onleft</span><span class="params">(<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b)</span> &#123; <span class="keyword">return</span> a * b &lt; <span class="number">0</span>; &#125;       <span class="comment">//cross product</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">onright</span><span class="params">(<span class="type">const</span> Vec &amp;a, <span class="type">const</span> Vec &amp;b)</span> &#123; <span class="keyword">return</span> a * b &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Graham扫描算法求凸包点集:函数返回逆时针排列的点集.</span></span><br><span class="line"><span class="comment">// c0 - c1 - ... - ck (- c0), counter-clockwise</span></span><br><span class="line">Polygon <span class="title function_">convex</span><span class="params">(Points p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sz = p.size();</span><br><span class="line">    sort(p.begin(), p.end(), [&amp;](<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b) &#123; <span class="keyword">return</span> a.x != b.x ? a.x &lt; b.x : a.y &lt; b.y; &#125;);                   <span class="comment">//先按x升序,再按y升序排列.</span></span><br><span class="line">    Polygon <span class="title function_">c</span><span class="params">(p.size() + <span class="number">1</span>)</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span> &amp;&amp; !onleft(p[i] - c[n - <span class="number">2</span>], c[n - <span class="number">1</span>] - c[n - <span class="number">2</span>])) n--;</span><br><span class="line">        c[n++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; t &amp;&amp; !onleft(p[i] - c[n - <span class="number">2</span>], c[n - <span class="number">1</span>] - c[n - <span class="number">2</span>])) n--;</span><br><span class="line">        c[n++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.resize(--n);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叉乘法求面积</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">areadb</span><span class="params">(Polygon &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        r += (p[i] - p[<span class="number">0</span>]) * (p[(i + <span class="number">1</span>) % n] - p[i]);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">diameter2</span><span class="params">(Polygon &amp;p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = p.size();</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vec e = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line">        <span class="keyword">while</span> (onleft(p[(a + <span class="number">1</span>) % n] - p[a % n], e) || a == i)</span><br><span class="line">        &#123;</span><br><span class="line">            r = max(&#123;r, (p[i] - p[a]).len2(), (p[(i + <span class="number">1</span>) % n] - p[a]).len2()&#125;);</span><br><span class="line">            a = (a + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        r = max(&#123;r, (p[i] - p[a]).len2(), (p[(i + <span class="number">1</span>) % n] - p[a]).len2()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Points p;       <span class="comment">//点集</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    p.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        p[i].read();        <span class="comment">//依据函数void read(),读入两个数</span></span><br><span class="line">    p = convex(p);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r = areadb(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld.%lld\n&quot;</span>, r / <span class="number">2</span>, (r &amp; <span class="number">1</span>) * <span class="number">5</span>);      <span class="comment">//保留1位小数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fft">FFT</h2><h3 id="dft模版--大数乘法">1.DFT模版--大数乘法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (1&lt;&lt;18)+5        <span class="comment">//超长整数位数</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=acosl(<span class="number">-1.0</span>);</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> r,i;</span><br><span class="line">    <span class="type">complex</span>()&#123;r=<span class="number">0</span>;i=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">complex</span>(<span class="type">double</span> re,<span class="type">double</span> im)&#123;r=re;i=im;&#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">len2</span><span class="params">()</span><span class="type">const</span>&#123;<span class="keyword">return</span> r*r+i*i;&#125;</span><br><span class="line">    <span class="type">complex</span> <span class="title function_">bar</span><span class="params">()</span> <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="type">complex</span>(r,-i);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">complex</span> operator + (<span class="type">const</span> <span class="type">complex</span> &amp;x,<span class="type">const</span> <span class="type">complex</span> &amp;y)&#123;<span class="keyword">return</span> <span class="type">complex</span>(x.r+y.r,x.i+y.i);&#125;</span><br><span class="line"><span class="type">complex</span> operator - (<span class="type">const</span> <span class="type">complex</span> &amp;x,<span class="type">const</span> <span class="type">complex</span> &amp;y)&#123;<span class="keyword">return</span> <span class="type">complex</span>(x.r-y.r,x.i-y.i);&#125;</span><br><span class="line"><span class="type">complex</span> operator * (<span class="type">double</span> k,<span class="type">const</span> <span class="type">complex</span> &amp;y)&#123;<span class="keyword">return</span> <span class="type">complex</span>(k*y.r,k*y.i);&#125;</span><br><span class="line"><span class="type">complex</span> operator * (<span class="type">const</span> <span class="type">complex</span> &amp;y,<span class="type">double</span> k)&#123;<span class="keyword">return</span> <span class="type">complex</span>(k*y.r,k*y.i);&#125;</span><br><span class="line"><span class="type">complex</span> operator * (<span class="type">const</span> <span class="type">complex</span> &amp;x,<span class="type">const</span> <span class="type">complex</span> &amp;y)&#123;<span class="keyword">return</span> <span class="type">complex</span>(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r);&#125;</span><br><span class="line"><span class="type">complex</span> operator / (<span class="type">const</span> <span class="type">complex</span> &amp;x,<span class="type">double</span> y)&#123;<span class="keyword">return</span> <span class="type">complex</span>(x.r/y,x.i/y);&#125;</span><br><span class="line"><span class="type">complex</span> operator / (<span class="type">const</span> <span class="type">complex</span> &amp;x,<span class="type">const</span> <span class="type">complex</span> &amp;y)&#123;<span class="keyword">return</span> x*y.bar()/y.len2();&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=acosl(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="type">complex</span> a[N],b[N],v[N];</span><br><span class="line"><span class="type">int</span> rev[N],ans[N];</span><br><span class="line"><span class="type">int</span> lens,lent,len;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFT</span><span class="params">(<span class="type">complex</span> c[],<span class="type">int</span> inv=<span class="number">0</span>)</span>&#123;            <span class="comment">//由系数表达c,求点值表达v,重装回c中.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) v[rev[i]]=c[i];</span><br><span class="line">        <span class="comment">//c[0,2,...,2n-2]放在v[0,...,n-1];c[1,...,2n-3]放在v[n,...,2n-2].</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i&lt;&lt;=<span class="number">1</span>)           <span class="comment">//迭代实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">complex</span> <span class="title function_">wn</span><span class="params">(cosl(<span class="number">2</span>*pi/i),sinl(<span class="number">2</span>*pi/i))</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j+=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">complex</span> <span class="title function_">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(i&gt;&gt;<span class="number">1</span>);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">complex</span> x=v[j+k],y=v[j+k+(i&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                v[j+k]=x+y;</span><br><span class="line">                v[j+k+(i&gt;&gt;<span class="number">1</span>)]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv)             <span class="comment">//逆DFT:点值表达-&gt;系数表达</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) v[i]=v[i]/len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=len<span class="number">-1</span>;i&lt;j;i++,j--) swap(v[i],v[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) c[i]=v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multiple</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">    lens=<span class="built_in">strlen</span>(s);lent=<span class="built_in">strlen</span>(t);len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;=lens+lent) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=b[i]=<span class="type">complex</span>(<span class="number">0</span>,<span class="number">0</span>);ans[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++) a[i]=<span class="type">complex</span>(s[lens<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lent;i++) b[i]=<span class="type">complex</span>(t[lent<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,t=i;j&lt;len;j&lt;&lt;=<span class="number">1</span>,t&gt;&gt;=<span class="number">1</span>) &#123;rev[i]&lt;&lt;=<span class="number">1</span>;rev[i]+=t&amp;<span class="number">1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//rev[0]=0,</span></span><br><span class="line">    DFT(a);DFT(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) b[i]=a[i]*b[i];      <span class="comment">//点值相乘</span></span><br><span class="line">    DFT(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]+=round(b[i].r);</span><br><span class="line">        ans[i+<span class="number">1</span>]+=ans[i]/<span class="number">10</span>;            <span class="comment">//十进制数--10;八进制数,这两行改为8.</span></span><br><span class="line">        ans[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;<span class="number">1</span>&amp;&amp;ans[len<span class="number">-1</span>]==<span class="number">0</span>) len-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;ans[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) multiple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆dft">2.逆DFT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆DFT:由点值表达-&gt;系数表达</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">computeRev</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;rev(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j,t;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>,t=i;j&lt;n;j&lt;&lt;=<span class="number">1</span>,t&gt;&gt;=<span class="number">1</span>) &#123;rev[i]&lt;&lt;=<span class="number">1</span>;rev[i]+=t&amp;<span class="number">1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">complex</span>&gt; <span class="title function_">inverseDFT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">complex</span>&gt;y,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;rev=computeRev(n);</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++) cout&lt;&lt;rev[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">complex</span>&gt; <span class="title function_">c</span><span class="params">(n)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) c[rev[i]]=y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">complex</span> <span class="title function_">wn</span><span class="params">(cosl(<span class="number">2</span>*pi/i),sinl(<span class="number">2</span>*pi/i))</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">complex</span> <span class="title function_">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(i&gt;&gt;<span class="number">1</span>);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">complex</span> x=c[j+k],y=c[j+k+(i&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                c[j+k]=x+y;</span><br><span class="line">                c[j+k+(i&gt;&gt;<span class="number">1</span>)]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) c[i]=c[i]/n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n<span class="number">-1</span>;i&lt;j;i++,j--) swap(c[i],c[j]);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;<span class="built_in">cin</span>&gt;&gt;k;<span class="type">int</span> n=<span class="built_in">pow</span>(<span class="number">2</span>,k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">complex</span>&gt; <span class="title function_">y</span><span class="params">(n)</span>;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;y[i]=<span class="type">complex</span>(a,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">complex</span>&gt;c=inverseDFT(y,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(c[i].r<span class="number">-0</span>)&lt;<span class="number">0.005</span>) c[i].r=<span class="number">0</span>;       <span class="comment">//四舍五入保留两位小数时,-0.00写作0.00.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(c[i].i<span class="number">-0</span>)&lt;<span class="number">0.005</span>) c[i].i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2lf %.2lf\n&quot;</span>,c[i].r,c[i].i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="啰嗦的解释">3.啰嗦的解释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FFT:多项式乘法--两个次数界为n的多项式,theta(n*lgn)时间内完成乘法</span></span><br><span class="line"><span class="comment">//1.系数表达:(a0,a1,...,a(n-1)).霍纳法则:A(x0)=a0+x0(a1+x0(a2+...+x0(a(n-2)+x0*a(n-1))...))--theta(n)完成求值运算</span></span><br><span class="line"><span class="comment">//2.点值表达:n个点值对的集合&#123;(x0,y0),...,(x(n-1),y(n-1))&#125;.所有xk各不相同,满足:yk=A(xk).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//互逆运算:n个点的求值/插值运算</span></span><br><span class="line"><span class="comment">//由系数表达求点值表达:theta(n^2).</span></span><br><span class="line"><span class="comment">//插值(由点值表达求系数表达):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(系数形式)多项式快速相乘:</span></span><br><span class="line"><span class="comment">//朴素算法:系数表达--theta(n^2)</span></span><br><span class="line"><span class="comment">//点值表达--theta(n)</span></span><br><span class="line"><span class="comment">//解释:要插值获得次数界为2n的多项式C,需2n个点值对.</span></span><br><span class="line"><span class="comment">//扩展A:&#123;(x0,y0),...,(x(2n-1),y(2n-1))&#125;,扩展B:&#123;(x0,y0&#x27;),...,(x(2n-1),y(2n-1)&#x27;)&#125;</span></span><br><span class="line"><span class="comment">//C:&#123;(x0,y0*y0&#x27;),...,(x(2n-1),y(2n-1)*y(2n-1)&#x27;)&#125;,基于C(xk)=A(xk)*B(xk).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通乘法:(a0,a1,...,a(n-1)),(b0,b1,...,b(n-1))-&gt;(c0,a1,...,c(2n-2))--theta(n^2).</span></span><br><span class="line"><span class="comment">//快速乘法:</span></span><br><span class="line"><span class="comment">//1.扩展为2n次:(a0,a1,...,a(n-1)),(b0,b1,...,b(n-1))-&gt;(a0,a1,...,a(n-1),0,...,0),(b0,b1,...,b(n-1),0,...,0)</span></span><br><span class="line"><span class="comment">//2,2n阶FFT计算2n阶点值表达:(A(w2n^0),...,A(w2n^(2n-1))),(B(w2n^0),...,B(w2n^(2n-1)))--theta(n*lgn).</span></span><br><span class="line"><span class="comment">//(精心选择的插值点:2n阶单位复根.</span></span><br><span class="line"><span class="comment">//3.点值乘法:得(C(w2n^0),...,C(w2n^(2n-1)))--theta(n).</span></span><br><span class="line"><span class="comment">//4.插值:对2n个点值计算其逆DFT,得(c0,c1,...,c(2n-2))--theta(n*lgn).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DFT:y=DFTn(a)--计算n次多项式A(x)在wn^0,...,wn^(n-1)这n个n次单位复根处的值.</span></span><br><span class="line"><span class="comment">//结果:y=(y0,...,y(n-1)),其中:yk=A(wn^k).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FFT:利用单位复根特殊性质，在theta(n*lgn)时间内，计算DFTn(a).（朴素算法：theta(n^2)）.</span></span><br></pre></td></tr></table></figure><h2 id="字符串">字符串</h2><h3 id="kmp">1.KMP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.KMP算法</span></span><br><span class="line"><span class="comment">//预处理时间:theta(m);匹配时间:theta(n).</span></span><br><span class="line"><span class="comment">//模式P的前缀函数:pi:&#123;1,2,...,m&#125;-&gt;&#123;0,1,...,m-1&#125;.满足:pi[q]=max&#123;k:k&lt;q且Pk是Pq的后缀&#125;.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;prefix(<span class="built_in">string</span> s)&#123;</span><br><span class="line">    <span class="type">int</span> m=(<span class="type">int</span>)s.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;pi(m);</span><br><span class="line">    pi[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=pi[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j]) j=pi[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j]) j++;</span><br><span class="line">        pi[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmp</span><span class="params">(<span class="built_in">string</span> T,<span class="built_in">string</span> P)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=(<span class="type">int</span>)T.length(),m=(<span class="type">int</span>)P.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;pi=prefix(P);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">0</span>&amp;&amp;P[q]!=T[i]) q=pi[q];</span><br><span class="line">        <span class="keyword">if</span>(P[q]==T[i]) q+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Pattern occurs with shift &quot;</span>&lt;&lt;i-m;</span><br><span class="line">            q=pi[q];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断长为i的前缀和后缀是否相同</span></span><br><span class="line"><span class="comment">//法一:求前缀数组</span></span><br><span class="line"><span class="comment">//从大到小考虑:字符串n为最大解;pi[n-1]为次大解;下一个解为pi[pi[n-1]-1].递推直至解为0,逆序输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="built_in">string</span> &amp;s)</span>&#123;          <span class="comment">//加引用:因为此处string不是全局变量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;pi=prefix(s),ans;</span><br><span class="line">    <span class="type">int</span> x=s.length();</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans.push_back(x);</span><br><span class="line">        x=pi[x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(ans.rbegin(),ans.rend(),[](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;&#125;);      <span class="comment">//rbegin,rend为逆向迭代器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;solve(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始T为空，两操作二选一：在T后添加一个字母;选择T的一前缀T&#x27;,连在T后.</span></span><br><span class="line"><span class="comment">//操作的最小次数.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;pi=prefix(s);</span><br><span class="line">        <span class="type">int</span> n=(<span class="type">int</span>)s.length(),cnt=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=pi[i];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">2</span>*q&gt;i+<span class="number">1</span>) q=pi[q<span class="number">-1</span>];       <span class="comment">//避免产生重叠.</span></span><br><span class="line">            <span class="keyword">if</span>(q==<span class="number">0</span>) &#123;cnt+=<span class="number">1</span>;i-=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;cnt+=<span class="number">1</span>;i-=q;&#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;q&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态机">2.状态机</h3><p>由字符串S构建的字符串匹配自动机共有n+1个状态，其中n为字符串S的长度。第i个状态表示接收到的字符串的最后i−1个字符（长度为i−1的后缀）恰能匹配S的前i−1个字符，第n+1个状态表示已经匹配上字符串S，为字符串匹配自动机的终态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">compute_Trans</span><span class="params">(<span class="built_in">string</span> &amp;s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=(<span class="type">int</span>)s.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;pi=prefix(s);</span><br><span class="line">    <span class="type">int</span> **Trans=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) Trans[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>+j) Trans[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> Trans[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>+j) &#123;Trans[i][j]=i+<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="type">int</span> q=pi[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(q&gt;<span class="number">0</span>&amp;&amp;s[q]!=<span class="string">&#x27;a&#x27;</span>+j) q=pi[q<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[q]==<span class="string">&#x27;a&#x27;</span>+j) Trans[i][j]=q+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> Trans[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Trans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="字符串映射">3.字符串映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立双向映射的哈希表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>,<span class="type">char</span>&gt;m1,m2;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::iterator it1=m1.begin(),it2=m2.begin();</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            it1=m1.find(s[i]);it2=m2.find(t[i]);</span><br><span class="line">            <span class="keyword">if</span>(it1==m1.end()&amp;&amp;it2==m2.end())    <span class="comment">//找不到</span></span><br><span class="line">            &#123;</span><br><span class="line">                m1.insert(<span class="built_in">make_pair</span>(s[i],t[i]));</span><br><span class="line">                m2.insert(<span class="built_in">make_pair</span>(t[i],s[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(it1!=m1.end()&amp;&amp;it2==m2.end()) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(it1==m1.end()&amp;&amp;it2!=m2.end()) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(it1-&gt;second!=t[i]||it2-&gt;second!=s[i]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*n);</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相同--建立哈希映射">4.判断字符串是否相同--建立哈希映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">26</span>,M=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepose</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p[<span class="number">0</span>]=<span class="number">1</span>;i&lt;N;i++) p[i]=(ll)p[i<span class="number">-1</span>]*B%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//prepose();</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,<span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="type">int</span>&gt;&gt;::iterator it=<span class="built_in">map</span>.begin();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="type">int</span> maxsize=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> m=(<span class="type">int</span>)s.size();</span><br><span class="line">        ll k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) k=(k*B+s[j])%M;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;k&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        it=<span class="built_in">map</span>.find(k);</span><br><span class="line">        <span class="keyword">if</span>(it==<span class="built_in">map</span>.end()) <span class="built_in">map</span>.insert(<span class="built_in">make_pair</span>(k,<span class="built_in">make_pair</span>(s,<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second.first;</span></span><br><span class="line">            <span class="keyword">if</span>(s!=it-&gt;second.first) <span class="built_in">map</span>.insert(<span class="built_in">make_pair</span>(k,<span class="built_in">make_pair</span>(s,<span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                it-&gt;second.second+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second.second&gt;maxsize) maxsize=it-&gt;second.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;map.size()&lt;&lt;&quot; &quot;&lt;&lt;maxsize&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>.size()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxsize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结合的变式">5.1,2结合的变式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G--C,E结合的变式</span></span><br><span class="line"><span class="comment">//同一集合内字符串相似:</span></span><br><span class="line"><span class="comment">//1.对每个字符串的字符建立映射,哈希值与字符位置相关(设为m.size()+1),求整个字符串的哈希值;</span></span><br><span class="line"><span class="comment">//2.对所有字符串建立映射,每个字符串的哈希值由步骤1得出.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">26</span>,M=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">Hash</span><span class="params">(<span class="built_in">string</span> &amp;s)</span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it=m.begin();</span><br><span class="line">    <span class="type">int</span> len=(<span class="type">int</span>)s.size();</span><br><span class="line">    ll k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">        it=m.find(s[j]);</span><br><span class="line">        <span class="keyword">if</span>(it==m.end())</span><br><span class="line">        &#123;</span><br><span class="line">            m.emplace(s[j],m.size()+<span class="number">1</span>);</span><br><span class="line">            k=(k*B+m.size())%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> k=(k*B+it-&gt;second)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,<span class="type">int</span>&gt;whole_map;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,<span class="type">int</span>&gt;::iterator it1=whole_map.begin();</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;<span class="type">int</span> maxsize=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        ll k=Hash(s);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        it1=whole_map.find(k);</span><br><span class="line">        <span class="keyword">if</span>(it1==whole_map.end()) whole_map.insert(<span class="built_in">make_pair</span>(k,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            it1-&gt;second+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(it1-&gt;second&gt;maxsize) maxsize=it1-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;whole_map.size()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxsize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>logb(a)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io">Liuyi Wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io/posts/abf55f5c.html">http://wenliuyi.github.io/posts/abf55f5c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wenliuyi.github.io" target="_blank">Liuyi Wen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/8b715a29.html" title="纸翼传问平台：平台功能、CICD、降级服务、自动扩缩容展示"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">纸翼传问平台：平台功能、CICD、降级服务、自动扩缩容展示</div></div><div class="info-2"><div class="info-item-1">该平台为北航2024年秋暑期软件工程实践项目。 CICD部署 (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"/posts/8b715a29/4-CICD.mp4","pic":"1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 降级服务 (function(){var player = new...</div></div></div></a><a class="pagination-related" href="/posts/f79d4b0.html" title="大模型推理框架vLLM：paper + code 解析"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">大模型推理框架vLLM：paper + code 解析</div></div><div class="info-2"><div class="info-item-1">论文解读：Efficient Memory Management for Large Language Model Serving with PagedAttention 论文原文 Abstract 为了提供LLM的高吞吐量服务，每次需要批量处理足够多的请求。然而现有系统面临KV缓存内存不足的挑战：每个请求的KV缓存内存占用巨大，且动态增减。当内存管理效率低下时，碎片化和冗余复制会造成显著的内存浪费，从而限制批处理规模。为解决这一问题，我们提出PagedAttention，这是一种受经典操作系统虚拟内存与分页技术启发的注意力算法。基于此，我们构建了vLLM这一LLM服务系统，其实现了：(1) KV缓存内存接近零浪费；(2) 支持请求内及跨请求的KV缓存灵活共享，进一步降低内存占用。评估表明，在相同延迟水平下，vLLM将主流LLM的吞吐量较FasterTransformer、Orca等最先进系统提升了2-4倍。当处理更长序列、更大模型及更复杂解码算法时，性能提升尤为显著。 Introduction 当前LLM...</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%91%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.渐近符号：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AE%9A%E7%90%86%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.主定理求时间复杂度:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E8%B4%A8%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">快速幂&#x2F;质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82ab."><span class="toc-number">1.2.1.</span> <span class="toc-text">1.快速幂：求a^b.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.分解质因数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%85%83%E8%8B%A5xy1mod-p%E5%88%99xy%E4%BA%92%E4%B8%BA%E6%A8%A1p%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E9%80%86%E5%85%83."><span class="toc-number">1.2.3.</span> <span class="toc-text">3.逆元:若x*y&#x3D;1(mod p),则x,y互为模p意义下的逆元.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97sigmaaixii0n."><span class="toc-number">1.2.4.</span> <span class="toc-text">4.秦九韶算法:快速计算sigma(ai*x^i)(i&#x3D;0~n).</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.辗转相除法:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.3.</span> <span class="toc-text">递推&#x2F;模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.卡特兰数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.多项式相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95%CE%B8mn"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.大数乘法:θ(m*n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.高精度除法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-number">1.4.</span> <span class="toc-text">分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E5%AF%BB%E6%89%BEa%E7%9A%84%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E9%9D%9E%E7%A9%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84."><span class="toc-number">1.4.1.</span> <span class="toc-text">1.最大子数组问题:寻找A的和最大的非空连续子数组.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.树状数组:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">C语言实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">求顺序统计量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">线性时间排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.比较排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.计数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.8.</span> <span class="toc-text">动态规划:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.1.</span> <span class="toc-text">3.流水线调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97lcs--on2"><span class="toc-number">1.8.2.</span> <span class="toc-text">5.最长公共子序列(LCS)--O(n^2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E4%B8%80%E7%A7%8D%E7%89%A9%E5%93%81%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AC%A1"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">(1)0-1背包:一种物品使用一次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.一些记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.9.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.活动选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#huffman%E7%BC%96%E7%A0%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.Huffman编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%B8%8D%E8%B6%85%E8%BF%87n%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.9.3.</span> <span class="toc-text">4.求不超过n的最大回文串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.10.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8Bn%E5%85%83%E6%95%B0--%E4%BE%9D%E6%AC%A1%E9%80%89%E6%8B%A9%E6%AF%8F%E4%B8%AA%E6%95%B0%E4%BD%8D%E4%B8%8A%E7%9A%84%E6%95%B0."><span class="toc-number">1.10.1.1.</span> <span class="toc-text">例:n元数--依次选择每个数位上的数.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bfs"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%9C%B0%E5%9B%BE%E4%B8%AD%E6%AF%8F%E4%B8%AA%E6%A0%BC%E5%AD%90%E6%9C%89%E5%8F%AF%E5%90%91%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%AD%A5%E6%95%B0%E6%B1%8211-nm%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0."><span class="toc-number">1.10.2.1.</span> <span class="toc-text">例:地图中每个格子,有可向上下左右移动的步数,求(1,1)-&gt;(n,m)的最小次数.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.3.</span> <span class="toc-text">3.单源最短路问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bellford%E5%8F%AF%E8%83%BD%E5%8C%85%E6%8B%AC%E8%B4%9F%E7%8E%AF"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">(1)Bellford:可能包括负环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95%E6%97%A0%E5%90%91%E5%9B%BE%E6%97%A0%E8%B4%9F%E7%8E%AF"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">(2)Dijkstra算法：无向图,无负环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98--floyd"><span class="toc-number">1.10.4.</span> <span class="toc-text">4.所有点间的最短路问题--Floyd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.5.</span> <span class="toc-text">5.拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">关键路径问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91--kruskalomlogm"><span class="toc-number">1.10.6.</span> <span class="toc-text">6.最小生成树--Kruskal:O(m*logm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81--dinic%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.7.</span> <span class="toc-text">7.网络流--Dinic算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8Don3"><span class="toc-number">1.10.8.</span> <span class="toc-text">8.二分图匹配:O(n^3)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%9D%83"><span class="toc-number">1.10.8.1.</span> <span class="toc-text">(1)无权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%9D%83"><span class="toc-number">1.10.8.2.</span> <span class="toc-text">(2)有权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-number">1.11.</span> <span class="toc-text">计算几何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%89%E7%82%B9%E6%98%AF%E5%90%A6%E5%85%B1%E7%BA%BF%E4%B8%89%E7%BB%B4"><span class="toc-number">1.11.1.</span> <span class="toc-text">1.判断三点是否共线(三维)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E7%BA%BF%E6%AE%B5%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB%E7%9B%B8%E4%BA%A4%E5%B9%B3%E8%A1%8C%E6%97%A0%E5%85%B3"><span class="toc-number">1.11.2.</span> <span class="toc-text">2.判断两线段位置关系:相交&#x2F;平行&#x2F;无关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E7%82%B9%E5%88%B0%E7%BA%BF%E6%AE%B5%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.11.3.</span> <span class="toc-text">3.求点到线段最小距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%87%B8%E5%8C%85%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.11.4.</span> <span class="toc-text">4.求凸包面积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fft"><span class="toc-number">1.12.</span> <span class="toc-text">FFT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dft%E6%A8%A1%E7%89%88--%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.DFT模版--大数乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86dft"><span class="toc-number">1.12.2.</span> <span class="toc-text">2.逆DFT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%B0%E5%97%A6%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.12.3.</span> <span class="toc-text">3.啰嗦的解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.13.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp"><span class="toc-number">1.13.1.</span> <span class="toc-text">1.KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.13.2.</span> <span class="toc-text">2.状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%A0%E5%B0%84"><span class="toc-number">1.13.3.</span> <span class="toc-text">3.字符串映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C--%E5%BB%BA%E7%AB%8B%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="toc-number">1.13.4.</span> <span class="toc-text">4.判断字符串是否相同--建立哈希映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E7%9A%84%E5%8F%98%E5%BC%8F"><span class="toc-number">1.13.5.</span> <span class="toc-text">5.1,2结合的变式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4e29148d.html" title="Go-上下文Context">Go-上下文Context</a><time datetime="2025-07-09T09:16:57.000Z" title="发表于 2025-07-09 17:16:57">2025-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1e6a04d4.html" title="Transformer系列：2. Attention机制，MHA，MQA和GQA">Transformer系列：2. Attention机制，MHA，MQA和GQA</a><time datetime="2025-06-29T07:47:26.000Z" title="发表于 2025-06-29 15:47:26">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/42e930ef.html" title="Transformer系列：1. 从RNN到Transformer">Transformer系列：1. 从RNN到Transformer</a><time datetime="2025-05-13T10:27:28.000Z" title="发表于 2025-05-13 18:27:28">2025-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/76aa9d6e.html" title="Transformer的KV Cache">Transformer的KV Cache</a><time datetime="2025-05-06T01:49:26.000Z" title="发表于 2025-05-06 09:49:26">2025-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2ac460b1.html" title="verl框架：2. 对比OpenRLHF+colocate思路解析">verl框架：2. 对比OpenRLHF+colocate思路解析</a><time datetime="2025-05-06T01:49:06.000Z" title="发表于 2025-05-06 09:49:06">2025-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=(e,o)=>{n&&(window.shuoshuoComment.destroyValine=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))});const t={el:"#vcomment",appId:"bsxtUJWr1muoPS1pmoXLOPZ2-gzGzoHsz",appKey:"wm2wUYvKLEySwyRnFn7xAbJI",avatar:"monsterid",serverURLs:"",emojiMaps:"",visitor:!1,path:n?o:window.location.pathname};new Valine(t)},o=async(n,o)=>{"function"==typeof Valine||await btf.getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"),e(n,o)};n?window.shuoshuoComment={loadComment:o}:btf.loadComment(document.getElementById("vcomment"),o)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>