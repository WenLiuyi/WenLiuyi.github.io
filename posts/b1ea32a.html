<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Go 的长连接 | Liuyi Wen's Blog</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 连接的建立和关闭 绝大多数网络连接的建立都是基于 TCP 协议的，我们往往知道一个原则：建立 TCP 连接需要三次握手，其具体过程也是面试的一个常考点。那么“为什么 TCP 建立连接需要三次握手？”呢？这个问题很少深究。首先回顾一下建立连接的过程： TCP 连接是什么？ 连接：用于保证可靠性和流控制的信息，包括 Socket、序列号和窗口大小。其中：Socket 由互联网地址标志符和端口组"><meta property="og:type" content="article"><meta property="og:title" content="Go 的长连接"><meta property="og:url" content="http://wenliuyi.github.io/posts/b1ea32a.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:description" content="TCP 连接的建立和关闭 绝大多数网络连接的建立都是基于 TCP 协议的，我们往往知道一个原则：建立 TCP 连接需要三次握手，其具体过程也是面试的一个常考点。那么“为什么 TCP 建立连接需要三次握手？”呢？这个问题很少深究。首先回顾一下建立连接的过程： TCP 连接是什么？ 连接：用于保证可靠性和流控制的信息，包括 Socket、序列号和窗口大小。其中：Socket 由互联网地址标志符和端口组"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><meta property="article:published_time" content="2025-09-03T03:20:39.000Z"><meta property="article:modified_time" content="2025-09-03T10:01:14.223Z"><meta property="article:author" content="Liuyi Wen"><meta property="article:tag" content="Go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go 的长连接",
  "url": "http://wenliuyi.github.io/posts/b1ea32a.html",
  "image": "http://wenliuyi.github.io/img/WechatIMG105.jpg",
  "datePublished": "2025-09-03T03:20:39.000Z",
  "dateModified": "2025-09-03T10:01:14.223Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liuyi Wen",
      "url": "http://wenliuyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/posts/b1ea32a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Go 的长连接",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go 的长连接</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">Go 的长连接</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-03T03:20:39.000Z" title="发表于 2025-09-03 11:20:39">2025-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-03T10:01:14.223Z" title="更新于 2025-09-03 18:01:14">2025-09-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="tcp-连接的建立和关闭">TCP 连接的建立和关闭</h2><p>绝大多数网络连接的建立都是基于 TCP 协议的，我们往往知道一个原则：建立 TCP 连接需要三次握手，其具体过程也是面试的一个常考点。那么“为什么 TCP 建立连接需要三次握手？”呢？这个问题很少深究。首先回顾一下建立连接的过程：</p><h3 id="tcp-连接是什么">TCP 连接是什么？</h3><p>连接：用于保证可靠性和流控制的信息，包括 <strong>Socket、序列号和窗口大小</strong>。其中：<strong>Socket</strong> 由<strong>互联网地址标志符和端口</strong>组成；窗口大小主要用来做<strong>流控制</strong>；最后的序列号用于<strong>追踪通信发起方发送的数据包序号</strong>，接收方可以通过序列号向发送方确认某个数据包的成功接收。 <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-1.png"></p><p>TCP 所有的协议状态如下图： <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image.png"></p><h3 id="建立-tcp-连接的三次握手">建立 TCP 连接的三次握手</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-2.png"></p><p>抽象成通俗语言就是：</p><ol type="1"><li><p>你能听到吗？</p></li><li><p>我能听到，你听得到吗？</p></li><li><p>我也能听到。</p></li><li><p><strong>第一次握手：SYN 报文</strong>：<strong>客户端随机初始化序列号 client_isn</strong>，放进TCP⾸部序列号段，然后把SYN置1。把SYN报⽂发送给服务端，表示 发起连接，之后客户端处于 SYN-SENT状态。</p></li><li><p><strong>第二次握手：SYN+ACK报⽂</strong>：<strong>服务端</strong>收到客户端的SYN报⽂之后，会<strong>把⾃⼰随机初始化的序号 server_isn放进TCP⾸部序列号段</strong>，<strong>「确认应答号」填⼊ client_isn + 1</strong>，把SYN和ACK标志位置为1。把SYN+ACK报⽂发送给客户端，然后进⼊ SYN-RCVD状态,表示服务器接受了客户端的请求，并希望建⽴连接。</p></li><li><p><strong>第三次握手：ACK报文</strong>：客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂。⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次<strong>确认应答号字段填⼊ server_isn + 1</strong> ，最后把报⽂发送给服务端，这次报⽂可以。</p></li></ol><p>服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED状态。</p><blockquote><p>补充：</p><p>第三次握⼿是可以携带数据的，但是前两次握⼿是不可以携带数据的。</p><p>半连接（SYN队列）：服务器第⼀次收到客户端的 SYN 之后，就会处于 SYN_RCVD状态，此时尚未建立连接，将此状态下的请求连接放在一个队列里。</p><p>全连接队列（Accept 队列）：存放已经完成三次握手的连接。</p><p>SYN 攻击：攻击者<strong>发送⼤量伪造的 SYN 请求到⽬标服务器，但不完成后续的握⼿过程，从⽽让服务器⼀直等待确认</strong>，消耗服务器的资源（如半连接队列和系统资源）；当半连接队列满了之后，后续再收到 SYN 报⽂就会丢弃，导致⽆法与客户端之间建⽴连接。</p></blockquote><h4 id="为什么一定是三次连接呢">为什么一定是三次连接呢？</h4><h5 id="排除历史重复连接">排除历史重复连接</h5><p>TCP 连接使用三次握手的首要原因是：阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p><p>如果通信次数只有两次会怎么样呢？那么<strong>发送方一旦发出建立连接的请求之后，无法再撤回这一次请求</strong>。如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，但接收方只能选择接受或者拒绝发送方发起的请求，<strong>它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</strong></p><p>因此下图中，选择使用三次握手建立 TCP 连接，并引入 RST。第二次请求后发送方判断：</p><ol type="1"><li>如果当前连接是历史连接（接收方返回的 ACK 报文中序列号不符合预期），即 Seq 过期或者超时：<strong>发送方就会直接发送 RST 控制消息中止</strong>这一次连接；</li><li>如果当前连接不是历史连接：发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；</li></ol><p>使用三次握手和 RST 控制消息将是否建立连接的<strong>最终控制权交给了发送方</strong>，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-3.png"></p><h5 id="同步双方的初始序列号">同步双方的初始序列号</h5><p>TCP 协议的通信双方，都必须维护一个序列号，以保证可靠传输，使得：</p><ol type="1"><li>接收端可以去除重复数据；</li><li>发送端可以在对应数据包未被 ACK 时进行重复发送；</li><li>接收端可以根据数据包的序列号对它们进行重新排序。</li></ol><p>它们都需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。如下图： <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-4.png"> 由于 TCP 消息头的设计，可以将中间的两次通信合成一个，TCP B 可以向 TCP A 同时发送 ACK 和 SYN 控制消息，帮助我们将四次通信减少至三次。</p><h3 id="关闭-tcp-连接的四次挥手">关闭 TCP 连接的四次挥手</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-5.png"> 在挥⼿之前，客户端和服务器都处于 ESTABLISHED 状态。</p><ol type="1"><li><strong>第一次挥手：FIN 报文</strong>：当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态；</li><li><strong>第二次挥手：ACK报文</strong>：服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；</li><li><strong>第三次挥手：FIN 报文</strong>：待<strong>服务端处理完数据后</strong>，当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息，并进入 LAST_ACK 状态；</li><li><strong>第四次挥手：ACK 报文</strong>：客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态；</li><li>客户端等待 2MSL 时间后，⾃动进⼊ CLOSE 状态，完成连接的关闭。</li></ol><h4 id="为什么需要-time_wait-状态呢">为什么需要 TIME_WAIT 状态呢？</h4><p>可以发现被动断开连接的一方会直接进入 CLOSED 状态，<strong>TIME_WAIT 仅在主动断开连接的一方出现</strong>，。原因如下：</p><h5 id="阻止延迟数据段被其他使用相同源地址源端口目的地址以及目的端口的-tcp-连接收到">阻止延迟数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到</h5><p>每一个 TCP 数据段都包含唯一的序列号以保证 TCP 协议的可靠性和顺序性。因此需要保证新 TCP 连接的数据段不会与还在网络中传输的历史连接的数据段重复。 <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-6.png"></p><p>那么为什么是 2 倍 MSL 呢？一个合理解释是：网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><blockquote><p>在 Linux 上，客户端的可以使用端口号 32,768 ~ 61,000，总共 28,232 个端口号与远程服务器建立连接，应用程序可以在将近 3 万的端口号中任意选择一个。</p><p>但是如果主机在过去一分钟时间内与目标主机的特定端口创建的 TCP 连接数超过 28,232，那么再创建新的 TCP 连接就会发生错误，也就是说如果我们不调整主机的配置，那么每秒能够建立的最大 TCP 连接数为 ~470。</p></blockquote><h5 id="保证连接关闭确保被动关闭放收到其发出的终止连接消息-fin-对应的-ack">保证连接关闭：确保被动关闭放收到其发出的终止连接消息 FIN 对应的 ACK</h5><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-7.png"> 如果最后的⼀次ACK报⽂丢失（第四次挥⼿），客户端没有 TIME_WAIT 状态，直接进⼊ ClOSE。</p><p>客户端重新与服务端建立 TCP 连接时，由于<strong>服务端没有收到 ACK 消息，所以仍然处于 LAST_ACK 状态，认为当前连接是合法的，客户端重新发送 SYN 消息请求握手时，会收到服务端的 RST 消息</strong>，连接建立的过程就会被终止。</p><p>为了解决这个问题，为什么等待的是2倍 MSL 时间呢？<strong>如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送⼀个 FIN，这样⼀去⼀来刚好两个 MSL 的时间</strong>。</p><p>如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况：</p><ol type="1"><li>服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。</li><li>服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会重发 FIN 关闭连接报⽂并等待新的 ACK 报⽂。</li></ol><blockquote><p>在某些场景下，60 秒的等待销毁时间确实是难以接受的，例如：高并发的压力测试。当我们通过并发请求测试远程服务的吞吐量和延迟时，本地就可能产生大量处于 TIME_WAIT 状态的 TCP 连接。此时如何处理呢？</p><ol type="1"><li>使用 SO_LINGER 选项并设置暂存时间 l_linger 为 0；在这时如果我们关闭 TCP 连接，内核就会<strong>直接丢弃缓冲区中的全部数据并向服务端发送 RST 消息直接终止当前的连接</strong>；</li><li>使用 net.ipv4.tcp_tw_reuse 选项，<strong>通过 TCP 的时间戳选项允许内核重用处于 TIME_WAIT 状态的 TCP 连接</strong>；</li><li>修改 net.ipv4.ip_local_port_range 选项中的<strong>可用端口范围</strong>，<strong>增加可同时存在的 TCP 连接数上限</strong>。</li></ol></blockquote><h3 id="建立-tcp-连接的成本">建立 TCP 连接的成本</h3><p>梳理完三次握手和四次挥手的详细过程后可以发现：建立 TCP 连接具备一定的<strong>时间成本</strong>；其次，握手、挥手、发送数据都是从网卡发送出去和接收的，对于高并发系统，如果大量数据包都经历过这么上述程，<strong>CPU 资源成本</strong>较高；每个 socket 需要<strong>耗费系统缓存</strong>。</p><p>那么什么场景下应该采用怎样的 TCP 连接方式呢？</p><h2 id="tcp-长连接和-tcp-短连接">TCP 长连接和 TCP 短连接</h2><p>长连接入服务<strong>同时支持客户端主动发起请求和服务器主动发起推送</strong>；短连接入服务则<strong>只支持客户端主动发起请求</strong>。</p><h3 id="tcp-短连接">TCP 短连接</h3><p>客户端与服务器建立连接开始通信，<strong>一次/指定次数通信结束之后就断开本次TCP连接</strong>；当下次再次通信时，再次建立TCP的链接。</p><p>优点：不长期占用服务器的内存，服务器能处理的连接数量是比较多的；</p><p>缺点：</p><ol type="1"><li>因为等到要发送数据或者获取资源时，才去请求建立连接发送数据，因此<strong>服务器无法向客户端主动发送数据；需要等到客户端下一次请求数据时才发送</strong>。<strong>客户端需要采用轮询实时拉取信息</strong>。</li></ol><h3 id="tcp-长连接">TCP 长连接</h3><p>客户端与服务器建立 TCP 连接之后一直保持连接状态，直到最后不再需要服务的时候才断开连接。</p><p>优点：传输数据快；服务器能够主动第一时间传输数据到客户端。</p><p>缺点：因为客户端与服务器一直保持这种连接，那么在高并发分布式集群系统中<strong>客户端数量会越来越多，占用大量系统资源</strong>；TCP本身是一种有状态的数据，在高并发分布式系统会导致后台设计比较复杂。</p><h3 id="tcp-的-keepalive-机制">TCP 的 keepalive 机制</h3><h4 id="设计理念">设计理念</h4><ol type="1"><li><strong>客户端和服务器需要了解什么时候终止进程，或者与对方断开连接</strong>。</li><li>在另一些情况下，虽然应用进程之间无数据交换，但依然需要<strong>通过连接保持一个最小的数据流</strong>。</li></ol><h4 id="使用场景">使用场景</h4><ol type="1"><li><p><strong>服务端应用程序探测客户端是否离开</strong>：在建立 TCP 连接后，如果客户端没有关闭连接而是直接关闭主机（不发送 RST 取消连接），会在服务端留下一个半开放连接，服务器永久等待，占用系统资源。可以使用 keepalive 机制检测。</p></li><li><p><strong>客户端通过 NAT 路由器连接并超时</strong>：NAT路由器，由于其硬件的限制（例如内存、CPU处理能力），无法保持所有连接，因此在必要的时候，会在连接池中选择一些不活跃的连接踢掉。<strong>需要在客户端离开时继续保持长连接</strong>时，可以使用 keepalive 机制，让连接每隔一小段时间就产生一些 ACK 包，降低被踢掉的风险。</p></li></ol><h4 id="实现">实现</h4><p><strong>keepalive 功能在默认情况下关闭，可以由 TCP 连接的任何一端、或者两端打开</strong>。</p><ol type="1"><li>如果在保活时间（keepalive time）内，连接处于非活跃状态，<strong>开启保活功能的一端向对方发送一个保活探测报文</strong>；</li><li>如果发送端没有收到 ACK 报文，经过一个保活时间间隔（keepalive internal），<strong>继续发送保活探测报文，直到发送次数达到保活探测数</strong>（keepalive probe）；此时<strong>对方主机将被确认为不可达，连接中断</strong>。</li></ol><blockquote><p>保活探测报文：<strong>一个空报文段，序列号等于对方发送的 ACK 报文的最大序列号-1</strong>。探测和响应报文都不包含任何有效数据，丢失时不重传。</p></blockquote><h4 id="检测到的4种状态">检测到的4种状态</h4><p>开启 TCP 保活功能的一端发现对方处于以下4种状态之一：</p><ol type="1"><li><strong>对方主机正在工作，可以到达</strong>：收到 ACK 报文，请求端将保活计时器重置；每次有应用程序通过该连接传输数据时，再次重置。</li><li><strong>对方主机已经崩溃，包括已经关闭或者正在重启</strong>：收不到 ACK 报文，一共发送保护探测数指定次数的探测报文，如果均未收到对应 ACK 报文，认为对方主机已经关闭，断开连接。</li><li><strong>对方主机崩溃并已经重启</strong>：请求端收到一个 RST 报文，请求端断开连接。</li><li><strong>对方主机正在工作，但由于某些原因不能到达请求端</strong>（例如网络传输问题）：与状态2相同，无法区分。</li></ol><blockquote><p>如果对方主机<strong>正常关闭</strong>再重启（不同于主机崩溃）：系统关机时，所有应用进程终止，会向请求端发送一个 FIN 报文以正常断开 TCP 连接。</p></blockquote><p>第1种情况所有操作在 TCP 层完成，请求端的应用层无法察觉保活探测；第2，3，4种情况中，<strong>请求端的应用层将收到一个来自 TCP 层的差错报告</strong>。</p><h5 id="tcp-层的实现">TCP 层的实现</h5><p>TCP 层心跳的开销较低，但检测精度相对较低，且受限于操作系统配置，可能无法满足所有应用需求；另外 TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制会失效。</p><blockquote><p>Linux 相关内核参数：</p><ul><li><strong>tcp_keepalive_time：</strong>（单位：秒）：发送探测报文之前的链接空闲时间，默认为7200；</li><li><strong>tcp_keepalive_intvl：</strong>（单位：秒）：两次探测报文发送的时间间隔，默认为75； <strong>tcp_keepalive_probes：</strong>：探测次数，默认为9。</li></ul></blockquote><h5 id="应用层的实现netty">应用层的实现：netty</h5><p>源码：<a target="_blank" rel="noopener" href="https://github.com/dongyusheng/csdn-code/tree/master/heartbeat">https://github.com/dongyusheng/csdn-code/tree/master/heartbeat</a></p><h2 id="go-的-http-连接池">Go 的 HTTP 连接池</h2><p>对于高并发服务，如何管理若干个连接呢？Go 中实现了连接池，帮助完成连接的建立、复用、回收等工作。在设计与实现时，通常需要考虑以下几个问题：</p><ol type="1"><li>连接池的最大连接数目是多少呢？</li><li>连接长时间未使用，如何设置触发回收的条件呢？</li><li>如果连接池无空闲连接，业务是否需要阻塞等待呢？</li><li>如果进行排队，那么队列的长度和排队时间分别是多少呢？</li></ol><p>为了回答以上问题，先深入 Go 连接池的源码：</p><h3 id="transport-原理">Transport 原理</h3><p>net/http/transport.go中的Transport struct继承并实现 实现了 http.RoundTripper接口，负责http的请求分发，以及对空闲连接的管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">	RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Transport</code> 结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//操作空闲连接需要获取锁</span></span><br><span class="line">    idleMu                 sync.Mutex   </span><br><span class="line">    closeIdle              <span class="type">bool</span></span><br><span class="line">    <span class="comment">//空闲连接池，key为协议目标地址等组合</span></span><br><span class="line">    idleConn               <span class="keyword">map</span>[connectMethodKey][]*persistConn</span><br><span class="line">    <span class="comment">//等待空闲连接的队列：基于切片实现，队列大小无限制</span></span><br><span class="line">    idleConnWait           <span class="keyword">map</span>[connectMethodKey]wantConnQueue</span><br><span class="line">    idleLRU                connLRU</span><br><span class="line">    reqMu                  sync.Mutex</span><br><span class="line">    reqCanceler            <span class="keyword">map</span>[*Request]context.CancelCauseFunc</span><br><span class="line">    altMu                  sync.Mutex</span><br><span class="line">    altProto               atomic.Value</span><br><span class="line">     <span class="comment">//排队等待建立连接需要获取锁</span></span><br><span class="line">    connsPerHostMu         sync.Mutex</span><br><span class="line">    <span class="comment">//每个host建立的连接数</span></span><br><span class="line">    connsPerHost           <span class="keyword">map</span>[connectMethodKey]<span class="type">int</span></span><br><span class="line">    <span class="comment">//等待建立连接的队列：同样基于切片实现，队列大小无限制</span></span><br><span class="line">    connsPerHostWait       <span class="keyword">map</span>[connectMethodKey]wantConnQueue</span><br><span class="line">    dialsInProgress        wantConnQueue</span><br><span class="line">    Proxy                  <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span></span> (*url.URL, <span class="type">error</span>)</span><br><span class="line">    OnProxyConnectResponse <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, proxyURL *url.URL, connectReq *Request, connectRes *Response)</span></span> <span class="type">error</span></span><br><span class="line">    DialContext            <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network <span class="type">string</span>, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    Dial                   <span class="function"><span class="keyword">func</span><span class="params">(network <span class="type">string</span>, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    DialTLSContext         <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network <span class="type">string</span>, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    DialTLS                <span class="function"><span class="keyword">func</span><span class="params">(network <span class="type">string</span>, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">//tls client：用于tls协商的配置</span></span><br><span class="line">    TLSClientConfig        *tls.Config</span><br><span class="line">    <span class="comment">//tls协商的超时时间</span></span><br><span class="line">    TLSHandshakeTimeout    time.Duration</span><br><span class="line">    <span class="comment">//是否取消长连接，默认使用长连接</span></span><br><span class="line">    DisableKeepAlives      <span class="type">bool</span></span><br><span class="line">    <span class="comment">//是否取消HTTP压缩</span></span><br><span class="line">    DisableCompression     <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有host的连接池最大连接数量：默认无穷大</span></span><br><span class="line">    MaxIdleConns           <span class="type">int</span></span><br><span class="line">    <span class="comment">//每个目标host最大空闲连接数：默认为2</span></span><br><span class="line">    MaxIdleConnsPerHost    <span class="type">int</span></span><br><span class="line">    <span class="comment">//对每个host可建立的最大连接数量：0表示不限制</span></span><br><span class="line">    MaxConnsPerHost        <span class="type">int</span></span><br><span class="line">    <span class="comment">//连接多少时间没有使用则被关闭</span></span><br><span class="line">    IdleConnTimeout        time.Duration</span><br><span class="line">    <span class="comment">//发送完request后等待serve response的时间</span></span><br><span class="line">    ResponseHeaderTimeout  time.Duration</span><br><span class="line">    ExpectContinueTimeout  time.Duration</span><br><span class="line">    TLSNextProto           <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(authority <span class="type">string</span>, c *tls.Conn)</span></span> RoundTripper</span><br><span class="line">    <span class="comment">// 在CONNECT请求时，配置request的首部信息：可选</span></span><br><span class="line">    ProxyConnectHeader     Header</span><br><span class="line">    GetProxyConnectHeader  <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, proxyURL *url.URL, target <span class="type">string</span>)</span></span> (Header, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">//指定server响应首部的最大字节数</span></span><br><span class="line">    MaxResponseHeaderBytes <span class="type">int64</span></span><br><span class="line">    <span class="comment">//写bufffer的大小：默认为4096</span></span><br><span class="line">    WriteBufferSize        <span class="type">int</span></span><br><span class="line">    <span class="comment">//读bufffer的大小：默认为4096</span></span><br><span class="line">    ReadBufferSize         <span class="type">int</span></span><br><span class="line">    nextProtoOnce          sync.Once</span><br><span class="line">    h2transport            h2Transport</span><br><span class="line">    tlsNextProtoWasNil     <span class="type">bool</span></span><br><span class="line">    <span class="comment">//是否启用HTTP/2：默认为启用</span></span><br><span class="line">    ForceAttemptHTTP2      <span class="type">bool</span></span><br><span class="line">    HTTP2                  *HTTP2Config</span><br><span class="line">    Protocols              *Protocols</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-8.jpg"></p><p>注意：<code>MaxIdleConnsPerHost</code>默认等于2，即<strong>当前客户端与目标主机最多只维护两个空闲连接</strong>。</p><h3 id="transport.roundtrip">Transport.roundTrip</h3><p>Transport.roundTrip是主入口，传入一个request参数，<strong>选择一个合适的长连接来发送该 request 并返回 response</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 请求重试循环</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 创建传输请求对象</span></span><br><span class="line">        treq := &amp;transportRequest&#123;Request: req, trace: trace&#125;</span><br><span class="line">        <span class="comment">// 获取连接方法（代理、目标地址等信息）</span></span><br><span class="line">        cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            req.closeBody()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取持久连接（从连接池或新建）</span></span><br><span class="line">        pconn, err := t.getConn(treq, cm)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.setReqCanceler(req, <span class="literal">nil</span>)</span><br><span class="line">            req.closeBody()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> resp *Response</span><br><span class="line">        <span class="comment">// 处理HTTP/2或其他替代协议</span></span><br><span class="line">        <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.decHostConnCount(cm.key())</span><br><span class="line">            t.setReqCanceler(req, <span class="literal">nil</span>)</span><br><span class="line">            resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标准HTTP请求处理（通过writeLoop和readLoop）</span></span><br><span class="line">            resp, err = pconn.roundTrip(treq)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求重试处理</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getconn为一个-http-请求获取一个可用的底层-tcptls-连接">getConn：为一个 HTTP 请求获取一个可用的底层 TCP/TLS 连接</h4><p><code>getConn</code> 优先尝试从空闲连接池中复用；如果没有则创建新连接，同时处理各种超时和取消逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConn 拨号并创建一个新的 persistConn 到 connectMethod 指定的目标。</span></span><br><span class="line"><span class="comment">// 这包括执行代理 CONNECT 和/或设置 TLS。如果不返回错误，persistConn 就可以写入请求。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (_ *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">	req := treq.Request</span><br><span class="line">	trace := treq.trace</span><br><span class="line">	ctx := req.Context()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 追踪：开始获取连接</span></span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.GetConn(cm.addr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关键步骤：从请求上下文的取消信号中分离出来</span></span><br><span class="line">	<span class="comment">// 即使请求被取消，拨号也应该继续进行，因为未来的请求可能会使用这个连接</span></span><br><span class="line">	dialCtx, dialCancel := context.WithCancel(context.WithoutCancel(ctx))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 wantConn 结构，用于管理连接获取过程</span></span><br><span class="line">	w := &amp;wantConn&#123;</span><br><span class="line">		cm:         cm,           <span class="comment">// 连接方法</span></span><br><span class="line">		key:        cm.key(),     <span class="comment">// 连接键值</span></span><br><span class="line">		ctx:        dialCtx,      <span class="comment">// 分离后的拨号上下文</span></span><br><span class="line">		cancelCtx:  dialCancel,   <span class="comment">// 取消拨号的函数</span></span><br><span class="line">		result:     <span class="built_in">make</span>(<span class="keyword">chan</span> connOrError, <span class="number">1</span>), <span class="comment">// 结果通道</span></span><br><span class="line">		beforeDial: testHookPrePendingDial,</span><br><span class="line">		afterDial:  testHookPostPendingDial,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			w.cancel(t) <span class="comment">// 如果出错，取消连接获取</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 尝试从空闲队列获取连接</span></span><br><span class="line">	<span class="keyword">if</span> delivered := t.queueForIdleConn(w); !delivered &#123;</span><br><span class="line">		<span class="comment">// 2. 如果没有空闲连接，排队等待拨号</span></span><br><span class="line">		t.queueForDial(w)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 等待连接获取完成或请求取消</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r := &lt;-w.result:</span><br><span class="line">		<span class="comment">// 成功获取到连接结果</span></span><br><span class="line">		<span class="keyword">if</span> r.pc != <span class="literal">nil</span> &amp;&amp; r.pc.alt == <span class="literal">nil</span> &amp;&amp; trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 为 HTTP/1 连接添加追踪信息</span></span><br><span class="line">			info := httptrace.GotConnInfo&#123;</span><br><span class="line">				Conn:   r.pc.conn,</span><br><span class="line">				Reused: r.pc.isReused(), <span class="comment">// 是否复用</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !r.idleAt.IsZero() &#123;</span><br><span class="line">				info.WasIdle = <span class="literal">true</span></span><br><span class="line">				info.IdleTime = time.Since(r.idleAt) <span class="comment">// 空闲时间</span></span><br><span class="line">			&#125;</span><br><span class="line">			trace.GotConn(info)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 检查请求是否被取消，优先返回取消错误</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-treq.ctx.Done():</span><br><span class="line">				err := context.Cause(treq.ctx)</span><br><span class="line">				<span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">					err = errRequestCanceledConn</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 返回原始错误</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r.pc, r.err</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">case</span> &lt;-treq.ctx.Done():</span><br><span class="line">		<span class="comment">// 请求在等待过程中被取消</span></span><br><span class="line">		err := context.Cause(treq.ctx)</span><br><span class="line">		<span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">			err = errRequestCanceledConn</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结：<code>getConn</code>为一个 HTTP 请求获取一个可用的底层 TCP/TLS 连接，优先复用空闲连接池中的连接。包含以下关键策略：</p><ol type="1"><li><strong>上下文分离</strong>：创建独立的 dialCtx，使拨号过程不受原始请求取消的影响，避免浪费已建立的连接；</li><li><strong>连接获取策略</strong>：优先使用 <code>queueForIdleConn</code> 尝试从空闲池获取可用连接；失败则使用 <code>queueForDial</code> 启动异步拨号；</li><li><strong>资源管理</strong>：妥善处理拨号创建但未被使用的连接，将其转入资源池，避免浪费。</li></ol><p>这个方法完美体现了 Go 并发模型的优势：使用 Goroutine 进行异步操作，使用 Channel 进行通信和同步，使用 Select 进行多路事件监听，最终构建出一个高效且健壮的连接管理机制。</p></blockquote><p>总结一下 <code>transport</code> 连接池流程：</p><p><code>transport</code> 中维护了一个空闲连接池 <code>idleConn map[connectMethodKey][]*persistConn</code>，其中的每个成员都是一个<code>persistConn</code>对象（即一个具体的连接实例，包含了连接的上下文），会启动两个 groutine 分别执行<code>readLoop</code>和<code>writeLoop</code>；</p><p>每当transport调用<code>roundTrip</code>的时候：</p><ol type="1"><li><p><strong>从连接池中选择一个空闲的<code>persistConn</code></strong>，调用其<code>roundTrip</code>方法，<strong>将读写请求通过channel分别发送到<code>readLoop</code>和<code>writeLoop</code>中</strong>；</p></li><li><p><code>select</code>监听各个<code>channel</code>的信息，包括连接关闭、请求超时、<code>writeLoop</code>出错、<code>readLoop</code>返回读取结果等；<strong>在<code>writeLoop</code>中发送请求，在<code>readLoop</code>中获取 response 并通过 channel 返回给<code>roundTrip</code></strong>；并<strong>再次将自己加入到<code>idleConn</code>中，等待下次请求到来</strong>。</p></li></ol><h3 id="transport-连接池的使用">Transport 连接池的使用</h3><ol type="1"><li>初始化客户端（可以自定义 client 和 transport 的参数）：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	url    <span class="type">string</span></span><br><span class="line">	client *http.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewClient 初始化客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(url <span class="type">string</span>)</span></span> *Client &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Client&#123;</span><br><span class="line">		url: url,</span><br><span class="line">		client: &amp;http.Client&#123;</span><br><span class="line">			Transport: &amp;http.Transport&#123;</span><br><span class="line">				DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">					Timeout:   <span class="number">30</span> * time.Millisecond,  <span class="comment">//限制建立TCP连接的时间</span></span><br><span class="line">					KeepAlive: <span class="number">10</span> * time.Millisecond,  <span class="comment">//指定 TCP keep-alive 探测发送到对等方的频率。</span></span><br><span class="line">				&#125;).DialContext,</span><br><span class="line">				ForceAttemptHTTP2:     <span class="literal">true</span>,  <span class="comment">//是否启用HTTP/2</span></span><br><span class="line">				IdleConnTimeout:       <span class="number">90</span> * time.Millisecond, <span class="comment">//连接多少时间没有使用则被关闭</span></span><br><span class="line">				TLSHandshakeTimeout:   <span class="number">10</span> * time.Second, <span class="comment">//tls协商的超时时间</span></span><br><span class="line">				ExpectContinueTimeout: <span class="number">1</span> * time.Second, <span class="comment">//等待收到一个go-ahead响应报文所用的时间</span></span><br><span class="line">				MaxIdleConns:          <span class="number">100</span>,  <span class="comment">//最大空闲连接数</span></span><br><span class="line">				MaxIdleConnsPerHost: <span class="number">10</span>, <span class="comment">// 每台主机保持的最大空闲连接</span></span><br><span class="line">				MaxConnsPerHost:     <span class="number">10</span>, <span class="comment">// 限制每个主机的连接总数</span></span><br><span class="line">				TLSClientConfig:     &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">			Timeout: <span class="number">20</span> * time.Second, <span class="comment">//从发起连接到接收响应报文结束</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>创建 HTTP 请求并发送</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// httpRequest http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> HttpRequest(method, params <span class="type">string</span>) (resBody []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. 初始化请求</span></span><br><span class="line">	body := strings.NewReader(params)</span><br><span class="line">    newReq, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, c.url+method, body)</span><br><span class="line">    <span class="comment">// newReq, err := http.NewRequest(&quot;GET&quot;, c.url+methed+params, nil)</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;创建转发的 HTTP 请求失败: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 发送请求</span></span><br><span class="line">	newReq.Header.Add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	newReq.Header.Add(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	httpResp, err := c.client.Do(newReq)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;请求发送失败: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> httpResp.Body.Close()</span><br><span class="line">	<span class="comment">// 3. 接收返回结果</span></span><br><span class="line">	<span class="keyword">return</span> ioutil.ReadAll(httpResp.Body), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么需要<code>httpResp.Body.Close()</code>呢？</p><p>如果返回值<code>httpResp.Body</code>未关闭，<code>client</code> 下层的 <code>RoundTripper</code> 接口（一般为 <code>Transport</code> 类型）可能无法重用 <code>httpResp.Body</code> 下层保持的 TCP 连接去执行之后的请求。所以它的作用就是用来确保 Body 读干净，释放出该连接。</p><p>不这么做的危害是什么呢？</p><ol type="1"><li>当前 TCP 连接未回收，无法复用；</li><li><code>readLoop</code> 和 <code>writeLoop</code> 两个 goroutine 在 写入请求并获取 response 返回后，并没有跳出 for 循环，而<strong>继续阻塞在下一次 for 循环的 select 语句里面，goroutine 一直无法被回收</strong>，cpu 和 memory 全部打满。发生 goroutine 内存泄漏； <strong>对方关闭了连接</strong>（向客户端发送了FIN），如果不调用<code>response.Body.Close()</code>，那么<strong>与这个请求相关的 TCP 连接的状态一直处于<code>CLOSE_WAIT</code>状态</strong>，不会被系统回收，文件描述符不会被释放，出现资源泄漏。</li></ol></blockquote><blockquote><p>注意 SSRF 漏洞：</p><p>使用"net/http"下的方法<code>http.Get(url)</code>、<code>http.Post(url, contentType, body)</code>、<code>http.Head(url)</code>、<code>http.PostForm(url, data)</code>、<code>http.Do(req)</code>时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p><p>一个栗子：来源于用户请求的 URL 路径 <code>path := r.URL.Path</code> 是不可信输入（污点）。直接拼接 <code>targetURL := "http://" + address + path</code> 并用于构建请求<code>newReq, err := http.NewRequest(r.Method, targetURL, bytes.NewBuffer(body))</code> 。攻击者可能构造恶意 path 实现 开放重定向 或 服务端请求伪造（SSRF）。</p></blockquote><h2 id="go-长连接服务在高并发场景下的优化">Go 长连接服务在高并发场景下的优化</h2><p>先看一个服务端采用原生 <code>net</code> 库实现长连接服务访问的例子，包括以下关键步骤：</p><ol type="1"><li><strong>建立 TCP 连接</strong>：使用 <code>net.Listen</code> 监听端口，接受客户端连接；<strong>每个连接在一个独立的 Goroutine 中处理</strong>。</li><li><strong>维护连接状态</strong>：使用 <code>sync.Map</code> 或 <code>map</code> 存储所有活跃的连接；定期检查连接状态，清理断开的连接。</li><li><strong>处理数据读写</strong>：使用 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 高效地读写数据；使用协议（如 JSON、Protobuf）序列化和反序列化数据。</li><li><strong>实现心跳机制</strong>：客户端定期发送心跳包，服务器检测心跳以判断连接是否存活。</li><li><strong>处理连接超时</strong>：使用 <code>net.Conn</code> 的 <code>SetReadDeadline</code> 和 <code>SetWriteDeadline</code> 方法设置超时时间；如果超过指定时间没有读写操作，连接会自动关闭。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn          net.Conn</span><br><span class="line">    lastHeartbeat time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> connections sync.Map</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;0.0.0.0:8081&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;pprof server start error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Failed to start server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    log.Println(<span class="string">&quot;Server started at :8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;Failed to accept connection:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    log.Println(<span class="string">&quot;New connection:&quot;</span>, conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化连接</span></span><br><span class="line">    connection := &amp;Connection&#123;</span><br><span class="line">        conn:          conn,</span><br><span class="line">        lastHeartbeat: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储活跃连接</span></span><br><span class="line">    connections.Store(conn.RemoteAddr().String(), connection)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动心跳检测</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">go</span> checkHeartbeat(ctx, connection)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数据读写</span></span><br><span class="line">    scanner := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        msg := scanner.Text()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&quot;PONG&quot;</span> &#123;</span><br><span class="line">            connection.lastHeartbeat = time.Now()</span><br><span class="line">            log.Println(<span class="string">&quot;Received PONG from:&quot;</span>, conn.RemoteAddr())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;Received message from&quot;</span>, conn.RemoteAddr(), <span class="string">&quot;:&quot;</span>, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理连接</span></span><br><span class="line">    connections.Delete(conn.RemoteAddr().String())</span><br><span class="line">    log.Println(<span class="string">&quot;Connection closed:&quot;</span>, conn.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkHeartbeat</span><span class="params">(ctx context.Context, conn *Connection)</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="keyword">if</span> time.Since(conn.lastHeartbeat) &gt; <span class="number">10</span>*time.Second &#123;</span><br><span class="line">                log.Println(<span class="string">&quot;Heartbeat timeout, closing connection:&quot;</span>, conn.conn.RemoteAddr())</span><br><span class="line">                conn.conn.Close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送心跳包</span></span><br><span class="line">            _, err := conn.conn.Write([]<span class="type">byte</span>(<span class="string">&quot;PING\n&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(<span class="string">&quot;Failed to send heartbeat:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的 Net 库提供简单的<strong>非阻塞调用</strong>接口，网络模型采用一个连接一个协程（Goroutine-per-Connection）。普通场景下易用，但对于百万连接级别的高并发场景，为每个连接分配一个协程将消耗极大的内存，并且调度大量协程也将十分困难。因此必须打破一个连接一个协程模型，tRPC-Go 的高性能网络库 tnet 基于事件驱动（Reactor）的网络模型，能够提供百万连接的能力。</p><h3 id="net一个连接一个协程">net：一个连接一个协程</h3><p>在传统的一个连接一个协程模式下，<strong>服务端每 Accept 个新连接就会为该连接创建一个独立的协程</strong>。在这个协程中完成从连接读取数据、处理业务逻辑、向连接写入数据的完整流程。这种模式在连接数较少时工作良好，但在百万级长连接场景下存在严重问题。</p><p>百万连接场景中，虽然连接总数巨大，但活跃连接（有数据可读写的连接）通常只占少数，<strong>大部分连接处于空闲状态（无数据读写）</strong>。<strong>空闲连接的协程会阻塞在Read调用上，虽然不占用CPU调度资源，但每个协程仍然需要占用一定的内存资源</strong>。在百万连接规模下，这种内存消耗变得极其巨大，导致成本昂贵。</p><h3 id="tnet事件驱动模型">tnet：事件驱动模型</h3><p>事件驱动模式是指利用<strong>多路复用（epoll / kqueue）监听 FD 的可读、可写等事件</strong>，该模型的核心是Poller结构，每个Poller运行在一个独立的协程中，Poller数量通常等于CPU核心数。</p><p>在这种架构下，<strong>采用单独的 Poller 监听 listener 端口的可读事件来 Accept 新连接；其他Poller负责监听所有连接的可读事件</strong>。当连接变得可读时，才为该连接分配协程进行处理：读取数据、处理业务、写入响应。这种设计确保只有活跃连接才会占用协程资源。</p><p>具体执行过程中，<strong>Poller检测到可读事件后，为每个可读连接分配处理协程</strong>。由于已知连接可读，<strong>Read操作不会阻塞</strong>，整个处理流程可以顺利执行；在 Write 阶段，向Poller注册可写事件后协程即可退出，由Poller在连接可写时完成数据发送，从而完成一轮完整的数据交互。</p><p>这种事件驱动模式在百万连接场景下显著降低了内存占用，通过只为活跃连接分配协程的方式实现了资源的高效利用，解决了传统模式的内存瓶颈问题。</p><h3 id="适用场景">适用场景</h3><ol type="1"><li><p>作为服务端使用 tnet，客户端发送请求使用多路复用的模式：可以充分发挥 tnet 批量收发包的能力，可以提高 QPS，降低 CPU 占用；</p></li><li><p>作为服务端使用 tnet：存在大量的不活跃连接的场景，可以通过减少协程数等逻辑降低内存占用；</p></li><li><p>作为客户端使用 tnet，开启多路复用模式：可以充分发挥 tnet 批量收发包的能力，可以提高 QPS。</p></li></ol><h2 id="参考">参考</h2><p><a target="_blank" rel="noopener" href="https://draven.co/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p><p><a target="_blank" rel="noopener" href="https://draven.co/whys-the-design-tcp-time-wait/">为什么 TCP 协议有 TIME_WAIT 状态</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6871081474003746830">TCP长连接、短连接（心跳检测）</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/104261099">TCP/IP卷一:94---TCP保活机制</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/89532613">UNP编程：21---套接字选项之（套接字选项简介与接口：getsockopt、setsockopt）</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484645386">一分钟了解长连接 、短连接、心跳机制与断线重连</a></p><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/398qn2sicbswudtusm5c">一文读懂网络框架 Netty</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mic112/p/15527384.html">工作了5年，你真的理解Netty以及为什么要用吗？（深度干货）</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cljdsc/article/details/125027270">golang长连接和短连接的那些事儿</a></p><p><a target="_blank" rel="noopener" href="https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#%E8%BD%AE%E8%AF%A2%E4%BA%8B%E4%BB%B6">网络轮询器</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/charlieroro/p/11409153.html">详解golang net之transport</a></p><p><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/">The complete guide to Go net/http timeouts</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yubo-guan/p/18724226#tid-DFhCaz">Golang 如何实现一个长连接服务？如何处理连接的超时和心跳？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7326807800905072679">千万级高性能长连接Go服务架构实践</a></p><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/trpc.group/trpc-go/tnet#section-readme"></a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io">Liuyi Wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io/posts/b1ea32a.html">http://wenliuyi.github.io/posts/b1ea32a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wenliuyi.github.io" target="_blank">Liuyi Wen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post-share"><div class="social-share" data-image="/img/WechatIMG105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/cda30c10.html" title="Go-内存分配器"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go-内存分配器</div></div><div class="info-2"><div class="info-item-1">内存分配器 内存空间包含两个重要区域：栈区和堆区。不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。 设计原理 内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）；当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。 分配方法 线性分配器 使用线性分配器时，只需要在内存中维护一个指向特定位置的指针；用户程序申请内存时，移动指针。然而，这不利于在内存被释放时重用内存。如下图中红色部分难以利用： 因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和...</div></div></div></a><a class="pagination-related" href="/posts/ba1e1693.html" title="RL 系列：1. Markov 决策过程"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RL 系列：1. Markov 决策过程</div></div><div class="info-2"><div class="info-item-1">本文旨在阐述基于 Markov 决策过程的强化学习原理，聚焦于关键公式（省去一些繁杂的数学推导），快速领会 RL 的核心理念。 RL 概述 强化学习的理念：Agent 根据 Environment 输出的 \(S_t\) 和 \(R_t\) 综合判断，产生当前步骤的动作 \(A_t\)，放入 Environment 执行；Environment 根据 \(A_t\) 执行的结果，输出下一个状态 \(S_{t+1}\) 和当前动作带来的奖励 \(R_{t+1}\)，返回给 Agent。 强化学习和监督学习的区别： RL 得到的时序数据不满足独立同分布； RL 无实时明确反馈当前 Action 是否正确，奖励信号延迟。（通过 rollout 过程从当前帧对 Action 进行采样，得到多个 observation， 每个 observe 对应一条 trajectory，即一个 State 和 Action 的序列 τ=(s0,a0,s1,a1,…)；通过最终 reward 来观测当前 trajectory 是否合适） Markov...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/cda30c10.html" title="Go-内存分配器"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">Go-内存分配器</div></div><div class="info-2"><div class="info-item-1">内存分配器 内存空间包含两个重要区域：栈区和堆区。不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。 设计原理 内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）；当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。 分配方法 线性分配器 使用线性分配器时，只需要在内存中维护一个指向特定位置的指针；用户程序申请内存时，移动指针。然而，这不利于在内存被释放时重用内存。如下图中红色部分难以利用： 因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和...</div></div></div></a><a class="pagination-related" href="/posts/e8d1fb4.html" title="Go-channel"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">Go-channel</div></div><div class="info-2"><div class="info-item-1">Go-Channel Channel是Go的核心数据结构和Goroutine之间的通信方式，支持Go的高性能并发编程模型。 设计原理 不通过共享内存的方式通信，而是通过通信的方式共享内存，采用的并发模式为：CSP（通信顺序进程）。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。 怎么理解“不通过共享内存的方式通信，而是通过通信的方式共享内存”这句话呢？ 前半句指通过 sync 包里的一些组件进行并发编程；后半句指使用 channel 进行并发编程。实际上，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。 上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。 FIFO Channel的收发操作遵循“先进先出”： 先从 Channel 读取数据的 Goroutine...</div></div></div></a><a class="pagination-related" href="/posts/4e29148d.html" title="Go-上下文Context"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Go-上下文Context</div></div><div class="info-2"><div class="info-item-1">上下文context 上下文context是Go中较独特的设计，其他编程语言中较为少见，主要用于在Goroutine之间传递请求的截止时间、取消信号和其他跨API边界的值。 context.Context是Go在1.7版本中引入的标准库接口，定义了4个待实现的方法： Deadline：返回 context.Context 被取消的时间，也就是完成工作的截止日期（如果Context设置了截止时间，则返回ok=true，deadline返回该时间；如果没有设置截止时间，则返回ok=false，deadline为空） Done：返回一个Channel（在当前工作完成或者上下文被取消后关闭），作为对Context关联函数的取消信号。当Channel关闭时，关联函数终止工作并返回。 多次调用 Done...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/WechatIMG105.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">1.</span> <span class="toc-text">TCP 连接的建立和关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">TCP 连接是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.</span> <span class="toc-text">建立 TCP 连接的三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%91%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么一定是三次连接呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E5%8E%86%E5%8F%B2%E9%87%8D%E5%A4%8D%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">排除历史重复连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%8C%E6%96%B9%E7%9A%84%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">同步双方的初始序列号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.3.</span> <span class="toc-text">关闭 TCP 连接的四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-time_wait-%E7%8A%B6%E6%80%81%E5%91%A2"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么需要 TIME_WAIT 状态呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E5%BB%B6%E8%BF%9F%E6%95%B0%E6%8D%AE%E6%AE%B5%E8%A2%AB%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E6%BA%90%E5%9C%B0%E5%9D%80%E6%BA%90%E7%AB%AF%E5%8F%A3%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BB%A5%E5%8F%8A%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E7%9A%84-tcp-%E8%BF%9E%E6%8E%A5%E6%94%B6%E5%88%B0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">阻止延迟数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E7%A1%AE%E4%BF%9D%E8%A2%AB%E5%8A%A8%E5%85%B3%E9%97%AD%E6%94%BE%E6%94%B6%E5%88%B0%E5%85%B6%E5%8F%91%E5%87%BA%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5%E6%B6%88%E6%81%AF-fin-%E5%AF%B9%E5%BA%94%E7%9A%84-ack"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">保证连接关闭：确保被动关闭放收到其发出的终止连接消息 FIN 对应的 ACK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.4.</span> <span class="toc-text">建立 TCP 连接的成本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C-tcp-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.</span> <span class="toc-text">TCP 长连接和 TCP 短连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text">TCP 短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">TCP 长连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E7%9A%84-keepalive-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">TCP 的 keepalive 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">设计理念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%844%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">检测到的4种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tcp-%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">TCP 层的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0netty"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">应用层的实现：netty</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E7%9A%84-http-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">Go 的 HTTP 连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transport-%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">Transport 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transport.roundtrip"><span class="toc-number">3.2.</span> <span class="toc-text">Transport.roundTrip</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getconn%E4%B8%BA%E4%B8%80%E4%B8%AA-http-%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%94%A8%E7%9A%84%E5%BA%95%E5%B1%82-tcptls-%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">getConn：为一个 HTTP 请求获取一个可用的底层 TCP&#x2F;TLS 连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transport-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">Transport 连接池的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">Go 长连接服务在高并发场景下的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">net：一个连接一个协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tnet%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">tnet：事件驱动模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/eecc19a2.html" title="并行训练系列：4. Megatron 之分布式环境初始化">并行训练系列：4. Megatron 之分布式环境初始化</a><time datetime="2025-09-25T09:41:56.000Z" title="发表于 2025-09-25 17:41:56">2025-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d7906c2a.html" title="并行训练系列：4. 张量并行（TP）">并行训练系列：4. 张量并行（TP）</a><time datetime="2025-09-18T15:53:50.000Z" title="发表于 2025-09-18 23:53:50">2025-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7529a079.html" title="并行训练系列：3. 数据并行下篇（DeepSeed-ZeRO）">并行训练系列：3. 数据并行下篇（DeepSeed-ZeRO）</a><time datetime="2025-09-17T10:00:42.000Z" title="发表于 2025-09-17 18:00:42">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3858f068.html" title="并行训练系列：2. 数据并行上篇（DP，DDP）">并行训练系列：2. 数据并行上篇（DP，DDP）</a><time datetime="2025-09-16T07:43:28.000Z" title="发表于 2025-09-16 15:43:28">2025-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ab0f7bb9.html" title="RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代">RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代</a><time datetime="2025-09-15T08:22:53.000Z" title="发表于 2025-09-15 16:22:53">2025-09-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=(e,o)=>{n&&(window.shuoshuoComment.destroyValine=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))});const t={el:"#vcomment",appId:"bsxtUJWr1muoPS1pmoXLOPZ2-gzGzoHsz",appKey:"wm2wUYvKLEySwyRnFn7xAbJI",avatar:"monsterid",serverURLs:"",emojiMaps:"",visitor:!1,path:n?o:window.location.pathname};new Valine(t)},o=async(n,o)=>{"function"==typeof Valine||await btf.getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"),e(n,o)};n?window.shuoshuoComment={loadComment:o}:btf.loadComment(document.getElementById("vcomment"),o)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>