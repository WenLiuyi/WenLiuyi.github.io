<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Go-调度器 | Liuyi Wen's Blog</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Go-调度器 多个线程可以属于同一个进程并共享内存空间。因此它们也不需要内存管理单元处理上下文的切换，线程之间的通信是基于共享的内存进行的。 虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对"><meta property="og:type" content="article"><meta property="og:title" content="Go-调度器"><meta property="og:url" content="http://wenliuyi.github.io/posts/b1ea32a.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:description" content="Go-调度器 多个线程可以属于同一个进程并共享内存空间。因此它们也不需要内存管理单元处理上下文的切换，线程之间的通信是基于共享的内存进行的。 虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><meta property="article:published_time" content="2025-07-17T03:20:39.000Z"><meta property="article:modified_time" content="2025-07-17T10:45:25.881Z"><meta property="article:author" content="Liuyi Wen"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go-调度器",
  "url": "http://wenliuyi.github.io/posts/b1ea32a.html",
  "image": "http://wenliuyi.github.io/img/WechatIMG105.jpg",
  "datePublished": "2025-07-17T03:20:39.000Z",
  "dateModified": "2025-07-17T10:45:25.881Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liuyi Wen",
      "url": "http://wenliuyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/posts/b1ea32a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Go-调度器",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go-调度器</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">Go-调度器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-17T03:20:39.000Z" title="发表于 2025-07-17 11:20:39">2025-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-17T10:45:25.881Z" title="更新于 2025-07-17 18:45:25">2025-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="go-调度器">Go-调度器</h1><p>多个线程可以属于同一个进程并共享内存空间。因此它们也不需要内存管理单元处理上下文的切换，<strong>线程之间的通信是基于共享的内存进行的</strong>。</p><p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-18.png"></p><p>Go 语言的调度器通过<strong>使用与 CPU 数量相等的线程</strong>减少线程频繁切换的内存开销，同时<strong>在每一个线程上执行额外开销更低的 Goroutine</strong> 来降低操作系统和硬件的负载。</p><h2 id="设计原理">设计原理</h2><p>包括以下几个版本：</p><ol type="1"><li><strong>单线程调度器</strong>：程序中只能存在一个活跃线程，由G-M模型组成；</li></ol><h3 id="单线程调度器">单线程调度器</h3><p>0.x 版本调度器只包含：Goroutine（G）和 线程（M）两种结构，全局只有一个线程。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	G* gp;</span><br><span class="line">	m-&gt;procid = getprocid();    <span class="comment">// 保存当前进程的ID</span></span><br><span class="line">	lock(&amp;sched);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 保存当前机器上下文，并尝试恢复（即切换到另一个goroutine）</span></span><br><span class="line">	<span class="keyword">if</span>(gosave(&amp;m-&gt;sched))&#123; </span><br><span class="line">        <span class="comment">// 如果函数返回 true，表示该函数是通过 gogo 或者 gosave 跳转到当前执行点的：之前的 lock(&amp;sched) 未能执行，需要在此重新锁住调度器</span></span><br><span class="line">		lock(&amp;sched);</span><br><span class="line"></span><br><span class="line">		gp = m-&gt;curg;       <span class="comment">// 将当前执行的 goroutine 保存到 gp</span></span><br><span class="line">		gp-&gt;m = nil;	</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 状态切换</span></span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;     <span class="comment">// 检查当前 goroutine 的状态</span></span><br><span class="line">		<span class="keyword">case</span> Grunnable:</span><br><span class="line">		<span class="keyword">case</span> Gdead:</span><br><span class="line">			throw(<span class="string">&quot;bad gp-&gt;status in sched&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> Grunning:      <span class="comment">// 正在运行：放回就绪队列</span></span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Gmoribund:     <span class="comment">// 即将死亡</span></span><br><span class="line">			gp-&gt;status = Gdead;</span><br><span class="line">			<span class="keyword">if</span>(--sched.gcount == <span class="number">0</span>)</span><br><span class="line">				sys·<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		notewakeup(&amp;gp-&gt;stopped);   <span class="comment">// 通知 gp 已经停止，标记当前goroutine已经完成，准备返回调度器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 获取下一个准备运行的goroutine：如果没有goroutine可以执行，它会使当前线程阻塞等待</span></span><br><span class="line">	gp = nextgandunlock();</span><br><span class="line">	</span><br><span class="line">	noteclear(&amp;gp-&gt;stopped);    <span class="comment">// 清除 gp 上的停止标记：表示当前的goroutine已经准备好运行</span></span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp;   <span class="comment">// 更新 m-&gt;curg 为当前要运行的goroutine gp</span></span><br><span class="line">	gp-&gt;m = m;	<span class="comment">// for debugger</span></span><br><span class="line">	g = gp;     <span class="comment">// 全局 g 设置为当前正在运行的 goroutine</span></span><br><span class="line">	gogo(&amp;gp-&gt;sched);   <span class="comment">// 恢复goroutine的执行状态，继续运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括以下步骤：</p><ol type="1"><li><strong>保存和恢复上下文</strong>：<code>lock(&amp;sched)</code>获取调度器的全局锁，调用 <code>runtime.gosave:9682400</code> 保存栈寄存器和程序计数器；</li><li><strong>选择下一个要运行的goroutine</strong>：调用 <code>runtime.nextgandunlock:9682400</code> 获取下一个需要运行的 Goroutine 并解锁调度器；修改全局线程 <code>m</code> 上要执行的 Goroutine；调用 <code>runtime.gogo:9682400</code> 函数运行最新的 Goroutine；</li></ol><h3 id="多线程调度器">多线程调度器</h3><p>整体的逻辑与单线程调度器差异不大。因为程序中可能同时存在多个活跃线程，所以多线程调度器<strong>引入 <code>GOMAXPROCS</code> 变量帮助灵活控制程序中的最大处理器数，即活跃线程数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">schedule</span><span class="params">(G *gp)</span> &#123;</span><br><span class="line">	schedlock();</span><br><span class="line">	<span class="keyword">if</span>(gp != nil) &#123;</span><br><span class="line">		gp-&gt;m = nil;</span><br><span class="line">		uint32 v = runtime·xadd(&amp;runtime·sched.atomic, <span class="number">-1</span>&lt;&lt;mcpuShift);</span><br><span class="line">		<span class="keyword">if</span>(<span class="type">atomic_mcpu</span>(v) &gt; maxgomaxprocs)</span><br><span class="line">			runtime·throw(<span class="string">&quot;negative mcpu in scheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;</span><br><span class="line">		<span class="keyword">case</span> Grunning:</span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ...:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	gp = nextgandunlock();</span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp;</span><br><span class="line">	gp-&gt;m = m;</span><br><span class="line">	runtime·gogo(&amp;gp-&gt;sched, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程调度器的问题：<strong>锁竞争严重浪费资源</strong>。有以下问题待解决：</p><ol type="1"><li><strong>单一全局互斥锁（<code>Sched.Lock</code>）和集中的状态</strong>：当前的调度器使用一个全局的互斥锁保护所有与goroutine相关的操作（如创建、完成、重新调度等）；</li><li><strong>Goroutine的传递（<code>G.nextg</code>）</strong>：工作线程（M）经常在它们之间传递可运行的goroutine，这可能导致延迟和额外的开销。每个M必须能够执行任何可运行的G，特别是刚刚创建的G；</li><li><strong>每个M的内存缓存（<code>M.mcache</code>）</strong>：内存缓存和其他缓存（如栈分配）与所有M关联，但实际上<strong>这些缓存只需要与正在运行Go代码的M关联（处于系统调用中的M不需要缓存）</strong>。在一些情况下，运行Go代码的M与所有M的比例可能高达1:100，这会导致过度的资源消耗（每个MCache可能会占用多达2MB的内存）和较差的数据局部性；</li><li><strong>频繁的线程阻塞和解除阻塞</strong>：在系统调用的情况下，工作线程会频繁地被阻塞和解除阻塞，这增加了额外的开销。</li></ol><h3 id="任务窃取调度器">任务窃取调度器</h3><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit?tab=t.0">Scalable Go Scheduler Design Doc</a> 对于多线程调度器的若干问题，引入<strong>处理器P</strong>，在此基础上实现任务窃取调度器。</p><ul><li><code>M</code>表示操作系统线程（与现有实现相同）；</li><li><code>P</code>表示执行Go代码所需的资源：<strong>当M执行Go代码时，它需要一个与之关联的P；当M处于空闲或系统调用状态时，不需要P</strong>。系统中有<code>GOMAXPROCS</code>个<code>P</code>，所有<code>P</code>被组织成一个数组（调整 <code>GOMAXPROCS</code> 时，需要暂停并重新启动程序以调整P的数量）</li></ul><h4 id="处理器p">处理器<code>P</code></h4><p>相较于多线程调度器：调度器的一些变量将从<code>sched</code>中去中心化并移动到<code>P</code>中，部分与Go代码执行相关的M的变量也将移到<code>P</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    uint32	status;</span><br><span class="line">	P*	link;</span><br><span class="line">	uint32	tick;</span><br><span class="line">	M*	m;      <span class="comment">// 线程</span></span><br><span class="line">	MCache*	mcache;</span><br><span class="line"></span><br><span class="line">	G**	runq;</span><br><span class="line">	int32	runqhead;</span><br><span class="line">	int32	runqtail;</span><br><span class="line">	int32	runqsize;</span><br><span class="line"></span><br><span class="line">	G*	gfree;</span><br><span class="line">	int32	gfreecnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">P *allp;  <span class="comment">// [GOMAXPROCS]</span></span><br><span class="line"></span><br><span class="line">P *idlep;  <span class="comment">// 空闲P的无锁列表</span></span><br></pre></td></tr></table></figure><p>处理器持有一个由就绪的Goroutine组成的环形就绪队列<code>runq</code>，且反向持有一个线程；调度时从处理器P的就绪队列中，选择队头的Goroutine放到线程M上执行。 <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-19.png"></p><p>基于工作窃取的多线程调度器<strong>将每一个线程绑定到了独立的 CPU 上</strong>（M和P绑定）；这些线程会被不同处理器管理，<strong>不同的处理器P通过工作窃取对Goroutine进行再分配</strong>实现任务的平衡，能提升调度器和 Go 语言程序的整体性能。</p><h4 id="调度">调度</h4><ol type="1"><li>当创建一个新的<code>G</code>或者一个<code>G</code>转为就绪状态时：当前<code>G</code>被推入当前<code>P</code>goroutines的就绪队列；</li><li>当<code>P</code>完成<code>G</code>的执行后，首先尝试从自己的goroutine就绪队列中弹出一个<code>G</code>以继续执行；如果队列为空，<code>P</code>会选择一个随机的受害者（另一个<code>P</code>），并尝试从它那里窃取一半的就绪goroutines。（充分利用处理器资源）</li></ol><h4 id="syscallm的挂靠和解挂靠">Syscall/M的挂靠和解挂靠</h4><p>当<code>M</code>创建一个新的G时，必须确保有一个<code>M</code>来执行该<code>G</code>（如果所有<code>M</code>都已经忙碌）；同样，当<code>M</code>进入系统调用时，它必须确保有其他的<code>M</code>可以继续执行Go代码。有两种选择：立即阻塞和解除阻塞<code>M</code>；或者使用一些自旋（消耗一些CPU周期）。这是性能和不必要的CPU消耗之间的冲突。为了避免影响<code>GOMAXPROCS=1</code>的程序，采取了一些自旋策略。</p><p>自旋是分两级的：</p><ol type="1"><li>与<code>P</code>关联的空闲<code>M</code>在等待新<code>G</code>时进行自旋；</li><li>无<code>P</code>关联的<code>M</code>等待可用的<code>P</code>。</li></ol><p>这种自旋方式主要是被动的（通过<code>yield</code>或<code>sched_yield()</code>），但可能会包括一些主动的自旋（通过循环消耗CPU），需要进一步研究和优化。</p><blockquote><p>自旋锁：一种轻量级的同步机制，广泛应用于多线程编程和操作系统内核中。它通过<strong>忙等待（busy-waiting）</strong>的方式，让<strong>线程在尝试获取锁时不断循环检查锁的状态，直到成功获取锁为止</strong>。</p></blockquote><p>看看一个版本的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	G *gp;</span><br><span class="line">    <span class="comment">// 1. 检查当前线程m是否持有锁</span></span><br><span class="line">	<span class="keyword">if</span>(m-&gt;locks)</span><br><span class="line">		runtime·throw(<span class="string">&quot;schedule: holding locks&quot;</span>);</span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// 2. 等待垃圾回收</span></span><br><span class="line">    <span class="keyword">if</span>(runtime·gcwaiting) &#123;</span><br><span class="line">        gcstopm();</span><br><span class="line">        <span class="keyword">goto</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从当前处理器上的运行队列获取一个就绪的goroutine</span></span><br><span class="line">	gp = runqget(m-&gt;p);</span><br><span class="line">    <span class="comment">// 4. 没有就绪的goroutine：查找其他P得就绪goroutine</span></span><br><span class="line">	<span class="keyword">if</span>(gp == nil)</span><br><span class="line">		gp = findrunnable();</span><br><span class="line">    <span class="comment">// 5. 检查当前线程m是否在进行自旋操作：</span></span><br><span class="line">	<span class="keyword">if</span>(m-&gt;spinning) &#123;</span><br><span class="line">        <span class="comment">// 自旋完成</span></span><br><span class="line">		m-&gt;spinning = <span class="literal">false</span>;</span><br><span class="line">		runtime·xadd(&amp;runtime·sched.nmspinning, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 检查是否需要唤醒其他OS线程（当前P的运行队列存在剩余Goroutine，当前没有自旋线程，存在空闲P）：唤醒一个空闲的OS线程</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;p-&gt;runqhead != m-&gt;p-&gt;runqtail &amp;&amp;     </span><br><span class="line">		runtime·sched.nmspinning == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		runtime·sched.npidle &gt; <span class="number">0</span>)  </span><br><span class="line">		wakep();</span><br><span class="line">    <span class="comment">// 7. 如果要执行的goroutine被锁定：</span></span><br><span class="line">	<span class="keyword">if</span>(gp-&gt;lockedm) &#123;</span><br><span class="line">		startlockedm(gp);   <span class="comment">// 启动一个锁定的M执行该goroutine</span></span><br><span class="line">		<span class="keyword">goto</span> top;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 8. 执行选定的goroutine</span></span><br><span class="line">	execute(gp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作流程：</p><ol type="1"><li>当一个Goroutine被创建时：它被放入一个P的本地队列；</li><li>若P的本地队列满了，或者某个G长期未被调度执行：<strong>P尝试从全局队列获取G</strong>；</li><li>若全局队列为空：<strong>P从其他P的本地队列中，窃取一些G</strong>，放在当前M上运行，以保证尽可能多地利⽤所有的处理器。</li></ol><p>工作窃取函数：<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c#L955"><code>runtime.findrunnable:779c45a</code></a></p><h3 id="抢占式调度器">抢占式调度器</h3><p>解决1.1版本中，程序只能依靠Goroutine主动让出CPU资源才能触发调度的问题。</p><h4 id="基于协作的抢占式调度">基于协作的抢占式调度</h4><p>工作原理：</p><ol type="1"><li>编译器会在调用函数前插入 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/asm_amd64.s#L412"><code>runtime.morestack</code></a>；</li><li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li><li><strong>当发生函数调用时，可能会执行编译器插入的 <code>runtime.morestack</code></strong>，它调用的 <code>runtime.newstack</code> 检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li><li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li></ol><p>抢占通过<strong>编译器在函数调用时插入抢占检查指令</strong>实现：在函数调用时检查当前Goroutine是否发起了抢占请求，因此<strong>需要函数调用作为入口才能触发抢占</strong>。</p><p>然而，Goroutine可能因为垃圾回收和循环长时间占用资源导致程序暂停。</p><h4 id="基于信号的抢占式调度">基于信号的抢占式调度</h4><ol type="1"><li><strong>注册信号处理函数</strong>：程序启动时，在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/signal_unix.go#L532"><code>runtime.sighandler</code></a> 中注册 <code>SIGURG</code> 信号的处理函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/signal_unix.go#L325"><code>runtime.doSigPreempt</code></a>；</li><li><strong>在触发垃圾回收的栈扫描时，会调用 <code>runtime.suspendG</code> 挂起 Goroutine</strong>，该函数会执行下面的逻辑：<ol type="1"><li><strong>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占</strong>，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li><li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/signal_unix.go#L352"><code>runtime.preemptM</code></a> 触发抢占；</li></ol></li><li><strong>发送信号</strong>：<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/signal_unix.go#L352"><code>runtime.preemptM</code></a> 会调用 <code>runtime.signalM</code> 向线程发送信号 <code>SIGURG</code>；</li><li><strong>接收信号后，OS执行信号处理函数</strong>：操作系统会中断正在运行的线程，并执行预先注册的信号处理函数 <code>runtime.doSigPreempt</code>；</li><li><code>runtime.doSigPreempt</code> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <code>r</code>untime.sigctxt.pushCall`；</li><li><code>runtime.sigctxt.pushCall</code> 会修改寄存器并在程序回到用户态时执行 <code>runtime.asyncPreempt</code>；</li><li>汇编指令 <code>runtime.asyncPreempt</code> 会调用运行时函数 <code>runtime.asyncPreempt2</code>；</li><li><code>runtime.asyncPreempt2</code> 会调用 <code>runtime.preemptPark</code>；</li><li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3249"><code>runtime.preemptPark</code></a> 会<strong>修改当前 Goroutine 的状态到 <code>_Gpreempted</code>，并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2977"><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程</strong>，调度器会选择其它的 Goroutine 继续执行；</li></ol><p>这里抢占的安全点包括：<strong>STW（Stop-the-world，垃圾回收时暂停整个程序）；栈扫描</strong></p><h2 id="数据结构">数据结构</h2><p>调度器包括3个重要组成部分：</p><ol type="1"><li><strong>G</strong>：表示Goroutine，一个待执行的任务；</li><li><strong>M</strong>：表示操作系统线程；</li><li><strong>P</strong>：表示处理器。</li></ol><h3 id="g">G</h3><p>Goroutine 是 Go 语言调度器中待执行的任务，<strong>只存在于Go语言运行时，是Go语言在用户态提供的线程</strong>。使用结构体<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L404"><code>runtime.g</code></a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type g <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 1. 栈相关字段</span></span><br><span class="line">	<span class="built_in">stack</span>       <span class="built_in">stack</span>       <span class="comment">// 当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)</span></span><br><span class="line">	stackguard0 uintptr     <span class="comment">// 用于抢占式调度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 抢占式调度相关字段</span></span><br><span class="line">    preempt       <span class="type">bool</span> <span class="comment">// 抢占信号</span></span><br><span class="line">	preemptStop   <span class="type">bool</span> <span class="comment">// 抢占时将状态修改成 `_Gpreempted`</span></span><br><span class="line">	preemptShrink <span class="type">bool</span> <span class="comment">// 在同步安全点收缩栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 存储 defer 和 panic 对应结构体的链表</span></span><br><span class="line">    _panic       *_panic <span class="comment">// 最内侧的 panic 结构体</span></span><br><span class="line">	_defer       *_defer <span class="comment">// 最内侧的延迟函数结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 其他字段</span></span><br><span class="line">    m              *m       <span class="comment">// 当前 Goroutine 占用的线程，可能为空</span></span><br><span class="line">	sched          gobuf    <span class="comment">// 存储 Goroutine 的调度相关的数据</span></span><br><span class="line">	atomicstatus   uint32   <span class="comment">// Goroutine 的状态</span></span><br><span class="line">	goid           int64    <span class="comment">// Goroutine 的 ID（该字段对开发者不可见）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sched字段的runtime.gobuf结构体"><code>sched</code>字段的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L313"><code>runtime.gobuf</code></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type gobuf <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	sp   uintptr        <span class="comment">// 栈指针</span></span><br><span class="line">	pc   uintptr        <span class="comment">// 程序计数器</span></span><br><span class="line">	g    guintptr       <span class="comment">// 持有`runtime.gobuf` 的 Goroutine（对应sched字段）</span></span><br><span class="line">	ret  sys.Uintreg    <span class="comment">// syscall返回值</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="goroutine的状态对应atomicstatus字段"><code>Goroutine</code>的状态（对应<code>atomicstatus</code>字段）</h4><table><colgroup><col style="width:22%"><col style="width:77%"></colgroup><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>_Gidle</code></td><td>刚刚被分配并且还没有被初始化</td></tr><tr><td><strong><code>_Grunnable</code></strong></td><td>没有执行代码，没有栈的所有权，存储在运行队列中</td></tr><tr><td><strong><code>_Grunning</code></strong></td><td>可以执行代码，拥有栈的所有权，<strong>被赋予了内核线程 M 和处理器 P</strong></td></tr><tr><td><strong><code>_Gsyscall</code></strong></td><td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，<strong>被赋予了内核线程 M 但是不在运行队列上</strong></td></tr><tr><td><strong><code>_Gwaiting</code></strong></td><td><strong>由于运行时而被阻塞</strong>，没有执行用户代码并且不在运行队列上，但是<strong>可能存在于 Channel 的等待队列上</strong></td></tr><tr><td><code>_Gdead</code></td><td>没有被使用，没有执行代码，可能有分配的栈</td></tr><tr><td><code>_Gcopystack</code></td><td>栈正在被拷贝，没有执行代码，不在运行队列上</td></tr><tr><td><strong><code>_Gpreempted</code></strong></td><td><strong>由于抢占而被阻塞</strong>，没有执行用户代码并且不在运行队列上，<strong>等待唤醒</strong></td></tr><tr><td><code>_Gscan</code></td><td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td></tr></tbody></table><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-20.png"></p><p>主要归为3类：</p><ol type="1"><li><strong>等待中</strong>：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态；</li><li><strong>可运行</strong>：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li><li><strong>运行中</strong>：Goroutine 正在某个线程上运行，即 <code>_Grunning</code>；</li></ol><h3 id="m">M</h3><p>M是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），<strong>最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行</strong>。（<strong>默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数</strong>，不会频繁触发操作系统的线程调度和上下文切换，所有的调度都发生在用户态，由 Go 语言调度器触发，减少额外开销）</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-21.png"></p><p>在默认情况下，一个四核机器会创建四个活跃的操作系统线程，<strong>每一个线程都对应一个运行时中的 <code>runtime.m</code> 结构体</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type m <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 1. Goroutine 相关字段</span></span><br><span class="line">	g0   *g     <span class="comment">// 持有调度栈的 Goroutine</span></span><br><span class="line">	curg *g     <span class="comment">// 在当前线程上运行的用户 Goroutine</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2. 处理器相关字段</span></span><br><span class="line">    p             puintptr      <span class="comment">// 正在运行代码的处理器 p</span></span><br><span class="line">	nextp         puintptr      <span class="comment">// 暂存的处理器 nextp</span></span><br><span class="line">	oldp          puintptr      <span class="comment">// 执行系统调用之前使用线程的处理器 oldp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="p">P</h3><p>处理器P是线程和Goroutine的中间层，能<strong>提供线程需要的上下文环境，负责调度线程上的等待队列</strong>；通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。</p><p>调度器在<strong>启动时会创建 <code>GOMAXPROCS</code> 个处理器</strong>，所以 Go 语言程序的<strong>处理器数量一定会等于 <code>GOMAXPROCS</code></strong>，这些处理器会绑定到不同的内核线程上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type p <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	m           muintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runqhead、runqtail 和 runq 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表</span></span><br><span class="line">	runqhead    uint32</span><br><span class="line">	runqtail    uint32</span><br><span class="line">	runq        [<span class="number">256</span>]guintptr</span><br><span class="line">	runnext     guintptr        <span class="comment">// 线程下一个需要执行的 Goroutine</span></span><br><span class="line">	status      uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p的状态对应status字段"><code>P</code>的状态（对应<code>status</code>字段）</h4><table><colgroup><col style="width:15%"><col style="width:84%"></colgroup><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>_Pidle</code></td><td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td></tr><tr><td><code>_Prunning</code></td><td><strong>被线程 M 持有，并且正在执行用户代码</strong>或者调度器</td></tr><tr><td><code>_Psyscall</code></td><td>没有执行用户代码，当前线程陷入系统调用</td></tr><tr><td><code>_Pgcstop</code></td><td>被线程 M 持有，当前处理器由于垃圾回收被停止</td></tr><tr><td><code>_Pdead</code></td><td>当前处理器已经不被使用</td></tr></tbody></table><h2 id="调度器启动">调度器启动</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span>     <span class="comment">// 最多可以创建 10000 个线程，但是可以同时运行的线程还是由 GOMAXPROCS 变量控制</span></span><br><span class="line">    ...... </span><br><span class="line">	lock(&amp;sched.lock)           <span class="comment">// 锁定调度器，整个程序不执行任何用户Goroutine</span></span><br><span class="line">	sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;       <span class="comment">// 更新程序中处理器的数量</span></span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4702"><code>runtime.procresize</code></a> 是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p><h2 id="创建goroutine">创建Goroutine</h2><p>通过关键字<code>go</code>启动一个新的Goroutine来执行任务。编译器将该关键字转为<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3900"><code>runtime.newproc</code></a>函数调用，然后<strong>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3925"><code>runtime.newproc1</code></a> 函数获取新的 Goroutine 结构体</strong>、将其加入处理器的运行队列并在满足条件时调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2353"><code>runtime.wakep</code></a> 唤醒新的处理执行 Goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newg := newproc1(fn, argp, siz, gp, pc)</span><br><span class="line"></span><br><span class="line">		_p_ := getg().m.p.ptr()</span><br><span class="line">		runqput(_p_, newg, <span class="literal">true</span>)    <span class="comment">// 将新创建的Goroutine newg设置到处理器的runnext，作为下一个处理器执行的任务</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.newproc1</code> 会根据传入参数创建一个状态为<code>_Grunnable</code>的 g 结构体，分为以下几个部分：</p><ol type="1"><li>获取或者创建新的 Goroutine 结构体；</li><li>将传入的参数移到 Goroutine 的栈上；</li><li>更新 Goroutine 调度相关的属性。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr)</span> *g &#123;</span><br><span class="line">    <span class="comment">// 1. 获取或创建Goroutine结构体：先在gFree列表中查找空闲Goroutine；如果不存在空闲Goroutine，通过 runtime.malg 创建一个栈大小足够的新结构体</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == nil &#123;</span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 2. 将fn函数的所有参数拷贝到栈上</span></span><br><span class="line">    totalSize := <span class="number">4</span>*sys.RegSize + uintptr(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	sp := newg.<span class="built_in">stack</span>.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;       <span class="comment">// argp 和 narg 分别是参数的内存空间和大小</span></span><br><span class="line">		memmove(unsafe.Pointer(spArg), argp, uintptr(narg))     <span class="comment">// 将参数对应的内存空间整块拷贝到栈上</span></span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3. 设置新的 Goroutine 结构体的参数：包括栈指针、程序计数器并更新其状态到 _Grunnable 并返回</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">    casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line">    newg.goid = int64(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化结构体runtime.gfget">初始化结构体（<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4097"><code>runtime.gfget</code></a>）</h3><p>调用链：<code>newproc</code>-&gt;<code>newproc1</code>-&gt;<code>gfget</code>(+<code>malg</code>)</p><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4097"><code>runtime.gfget</code></a>通过两种不同方式获取新的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L404"><code>runtime.g</code></a></p><ol type="1"><li>从 <strong>Goroutine 所在处理器的 <code>gFree</code> 列表</strong>，或者<strong>调度器的 <code>sched.gFree</code> 列表</strong>中获取 <code>runtime.g</code>；<ol type="1"><li>当处理器的<code>gFree</code>列表为空时：将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 <code>gFree</code> 列表中的 Goroutine 数量达到32；</li><li>当处理器的 Goroutine 数量充足时：从列表头部返回一个新的 Goroutine；</li></ol></li><li>调用 <code>runtime.malg</code> 生成一个新的 <code>runtime.g</code>，并将结构体追加到全局的 Goroutine 列表 <code>allgs</code> 中。</li></ol><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-22.png"></p><h3 id="设置调度信息sched">设置调度信息<code>sched</code></h3><p>调用链：<code>newproc</code>-&gt;<code>newproc1</code>-&gt;...</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum      <span class="comment">// 程序计数器设置为：runtime.goexit</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))       <span class="comment">// Goroutine设置为：新创建的Goroutine 运行的函数</span></span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure><h3 id="运行队列runqput">运行队列（<code>runqput</code>）</h3><p>调用链：<code>newproc</code>-&gt;<code>runqput</code></p><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L5646"><code>runtime.runqput</code></a> 会将 Goroutine 放到运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p><ol type="1"><li>当<code>next</code>为<code>true</code>时：将 Goroutine 设置到处理器的 <code>runnext</code> 作为下一个处理器执行的任务；</li><li>当<code>next</code>为<code>false</code>且本地运行队列还有剩余空间时：将 Goroutine 加入处理器持有的本地运行队列；</li><li>当<code>next</code>为<code>false</code>且处理器的本地运行队列已经没有剩余空间时：把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 <code>runtime.runqputslow</code> 添加到<strong>调度器持有的全局运行队列</strong>上；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(_p_ *p, gp *g, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		next = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> next &#123;</span><br><span class="line">	retryNext:</span><br><span class="line">		oldnext := _p_.runnext</span><br><span class="line">		<span class="keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line">			<span class="keyword">goto</span> retryNext</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Kick the old runnext out to the regular run queue.</span></span><br><span class="line">		gp = oldnext.ptr()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">	t := _p_.runqtail</span><br><span class="line">	<span class="keyword">if</span> t-h &lt; <span class="type">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">		_p_.runq[t%<span class="type">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span><br><span class="line">		atomic.StoreRel(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// the queue is not full, now the put above must succeed</span></span><br><span class="line">	<span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-23.png"></p><blockquote><p>两个运行队列辨析：<strong>处理器本地的运行队列 &amp; 调度器持有的全局运行队列</strong> 仅当本地运行队列没有剩余空间时，才使用全局队列。</p></blockquote><h2 id="调度循环查找可执行的goroutine">调度循环：查找可执行的Goroutine</h2><p>调度器启动之后，Go 语言运行时会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L1183"><code>runtime.mstart</code></a> 以及 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L1217"><code>runtime.mstart1</code></a>：前者初始化 <code>g0</code> 的 <code>stackguard0</code> 和 <code>stackguard1</code> 字段；后者初始化线程并<strong>调用 <code>runtime.schedule</code> 进入调度循环，采用三种方法查找待执行的Goroutine</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 当全局运行队列中有待执行的 Goroutine 时：通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 1.2 从处理器本地的运行队列中查找待执行的 Goroutine；</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 1.3 通过 runtime.findrunnable 进行阻塞地查找 Goroutine</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 2. 执行获取的Goroutine：通过 runtime.gogo 将 Goroutine 调度到当前线程上</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.gogo</code>在不同处理器架构上的实现不同，</p><ol type="1"><li>函数调用时，模仿<code>CALL</code>过程的几个关键指令如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVL gobuf_sp(BX), SP  // 将 runtime.goexit 函数的 PC 恢复到 SP 中</span><br><span class="line">MOVL gobuf_pc(BX), BX  // 将待执行函数的程序计数器放到寄存器BX上</span><br><span class="line">JMP  BX                // 开始执行</span><br></pre></td></tr></table></figure><blockquote><p>函数调用使用<code>CALL</code>指令：将<strong>调用方的返回地址加入栈寄存器SP</strong>，跳转到目标函数；<strong>当目标函数返回后，会从栈中查找调用的地址，并跳转回调用方</strong>继续执行剩下的代码。</p></blockquote><ol start="2" type="1"><li>从 Goroutine 中运行的函数返回时，跳转到<a target="_blank" rel="noopener" href="https://draven.co/golang/tree/runtime.goexit"><code>runtime.goexit</code></a>所在位置执行该函数：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	CALL	runtime·goexit1(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在当前线程的 <code>g0</code> 的栈上调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3302"><code>runtime.goexit0</code></a> 函数，该函数会将 Goroutine 转换为 <code>_Gdead</code> 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4062"><code>runtime.gfput</code></a> 重新加入处理器的 Goroutine 空闲列表 <code>gFree</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">    <span class="comment">// 1. 将 Goroutine 转换为 `_Gdead` 状态</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">    <span class="comment">// 2. 清理字段</span></span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	...</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 3. 移除 Goroutine 和线程的关联</span></span><br><span class="line">	dropg()</span><br><span class="line">    <span class="comment">// 4. 将gp重新加入处理器的 Goroutine 空闲列表 gFree</span></span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">    <span class="comment">// 5. 触发新一轮的Goroutine调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-24.png"> 以上是Goroutine正常执行和退出的逻辑；多数情况下Goroutine执行过程中，会经历协作式/抢占式调度，让出线程使用权并等待调度器唤醒。</p><h2 id="触发调度">触发调度</h2><p>找到<code>runtime.schedule</code>函数的调用方，也即所有触发调度的时间点： <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-25.png"></p><p>除此之外，运行时还会在线程启动 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L1183"><code>runtime.mstart</code></a> 和 Goroutine 执行结束 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3302"><code>runtime.goexit0</code></a> 触发调度。</p><h3 id="主动挂起">主动挂起</h3><p>调用链： <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L319"><code>runtime.gopark</code></a> -&gt; <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2668"><code>runtime.park_m</code></a></p><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L319"><code>runtime.gopark</code></a> 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列，而是等待唤醒：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="type">bool</span>, lock unsafe.Pointer, reason waitReason, traceEv <span class="type">byte</span>, traceskip <span class="type">int</span>) &#123;</span><br><span class="line">	......</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一行通过<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/asm_386.s#L316"><code>runtime.mcall</code></a>切换到g0的栈上调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2668"><code>runtime.park_m</code></a>：<strong>将当前 Goroutine 的状态从 <code>_Grunning</code> 切换至 <code>_Gwaiting</code>，调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3100"><code>runtime.dropg</code></a> 移除线程和 Goroutine 之间的关联</strong>，在这之后就可以调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2977"><code>runtime.schedule</code></a> 触发新一轮的调度了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Goroutine 等待的特定条件满足后，运行时会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L345"><code>runtime.goready</code></a> <strong>将因为调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L319"><code>runtime.gopark</code></a> 而陷入休眠的 Goroutine 唤醒</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="type">int</span>, next <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">    <span class="comment">// 1. 将准备就绪的 Goroutine 的状态切换至 _Grunnable</span></span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    <span class="comment">// 2. 将 gp 加入处理器的运行队列中，等待调度器的调度</span></span><br><span class="line">	runqput(_g_.m.p.ptr(), gp, next)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用">系统调用</h3><p>在系统调用前后，会调用运行时的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3490"><code>runtime.entersyscall</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3584"><code>runtime.exitsyscall</code></a>，这层包装能够在陷入系统调用前触发运行时的准备和清理工作。 <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/b1ea32a/image-26.png"></p><h4 id="准备工作分离线程和处理器释放锁">准备工作：分离线程和处理器，释放锁</h4><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3490"><code>runtime.entersyscall</code></a> 会在获取当前程序计数器和栈位置之后调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3424"><code>runtime.reentersyscall</code></a>，完成 Goroutine 进入系统调用前的准备工作：<strong>使得处理器和线程分离</strong>，当前线程会陷入系统调用等待返回；在锁被释放后，会有其他Goroutine抢占处理器资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	_g_.stackguard0 = stackPreempt</span><br><span class="line">	_g_.throwsplit = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 1. 保存当前的程序计数器 PC 和栈指针 SP 中的内容；</span></span><br><span class="line">	save(pc, sp)</span><br><span class="line">	_g_.syscallsp = sp</span><br><span class="line">	_g_.syscallpc = pc</span><br><span class="line">    <span class="comment">// 2. 将 Goroutine 的状态更新至 _Gsyscall；</span></span><br><span class="line">	casgstatus(_g_, _Grunning, _Gsyscall)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Goroutine 的处理器和线程暂时分离并更新处理器的状态到 _Psyscall；</span></span><br><span class="line">	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</span><br><span class="line">	_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.m = <span class="number">0</span></span><br><span class="line">	_g_.m.oldp.set(pp)</span><br><span class="line">	_g_.m.p = <span class="number">0</span></span><br><span class="line">	atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(entersyscall_gcwait)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 4. 释放当前线程上的锁</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="恢复工作为当前goroutine重新分配资源">恢复工作：为当前Goroutine重新分配资源</h4><p>调用退出系统调用的函数<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3584"><code>runtime.exitsyscall</code></a>为当前Goroutine重新分配资源，有两个不同的执行路径：</p><ol type="1"><li>调用快速路径<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3658"><code>runtime.exitsyscallfast</code></a>：<ol type="1"><li>如果Goroutine的原处理器处于<code>_Psyscall</code>状态：直接调用 <code>wirep</code> 将 Goroutine 与处理器进行关联；</li><li>如果调度器中存在闲置的处理器，会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4841"><code>runtime.acquirep</code></a> 使用闲置的处理器处理当前 Goroutine；</li></ol></li><li>调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3739"><code>runtime.exitsyscall0</code></a>，将当前Goroutine切换至<code>_Grunnable</code>状态，并移除线程M和当前Goroutine的关联：<ol type="1"><li>如果通过<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L5599"><code>runtime.pidleget</code></a>获取到闲置的处理器：在该处理器上执行Goroutine；</li><li>其他情况：将当前Goroutine放到全局的运行队列中，等待调度器的调度。</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	oldp := _g_.m.oldp.ptr()</span><br><span class="line">	_g_.m.oldp = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">		_g_.m.p.ptr().syscalltick++</span><br><span class="line">		casgstatus(_g_, _Gsyscall, _Grunning)</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mcall(exitsyscall0)</span><br><span class="line">	_g_.m.p.ptr().syscalltick++</span><br><span class="line">	_g_.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协作式调度">协作式调度</h3><p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L290"><code>runtime.Gosched</code></a>函数主动让出处理器，允许其他Goroutine运行。该函数无法挂起Goroutine，调度器可能会将当前 Goroutine 调度到其他线程上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">	checkTimeouts()</span><br><span class="line">	mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosched_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在<code>g0</code>的栈上调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L3203"><code>runtime.goschedImpl</code></a>，运行时更新Goroutine的状态到<code>_Grunnable</code>，让出当前处理器并将Goroutine重新放回全局队列。最后，调用<code>runtime.schedule</code>触发调度。</p><h2 id="线程管理">线程管理</h2><p>Go的运行时通过调度器改变线程所有权，也提供<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L4190"><code>runtime.LockOSThread</code></a>和<a target="_blank" rel="noopener" href="https://draven.co/golang/tree/runtime.UnlockOSThread"><code>runtime.UnlockOSThread</code></a>绑定Goroutine和线程。</p><h3 id="线程生命周期">线程生命周期</h3><p>Go的运行时通过<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2206"><code>runtime.startm</code></a>启动线程以执行处理器P：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> nmp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没有可用的 M，我们必须释放 sched.lock，并调用 newm。然而，我们已经拥有一个 P 来分配给 M。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        一旦释放了 sched.lock，另一个 G（例如，在系统调用中）可能会发现没有空闲的 P；同时 checkdead 可能会发现一个可以运行的 G，但是没有正在运行的 M，因为这个新的 M 还没有启动，从而导致一个表面上的死锁。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        通过预分配新 M 的 ID 来避免这种情况，从而在我们释放 sched.lock 之前，将其标记为“正在运行”。这个新 M 最终将运行调度器以执行任何排队的 G。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		id := mReserveID()</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">		<span class="keyword">if</span> spinning &#123;</span><br><span class="line">			fn = mspinning</span><br><span class="line">		&#125;</span><br><span class="line">		newm(fn, _p_, id)       <span class="comment">// 创建新的线程M</span></span><br><span class="line">        <span class="comment">// 释放P的所有权，让新的 M 开始执行任务</span></span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> iscgo &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	newosproc(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新线程时调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/os_linux.go#L139"><code>runtime.newosproc</code></a>，在Linux平台上通过系统调用<code>clone</code>创建新的操作系统线程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	...</span><br><span class="line">	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用系统调用 <code>clone</code> 创建的线程会在线程主动调用 <code>exit</code>、以及在传入的函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L1183"><code>runtime.mstart</code></a> 返回时主动退出；<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L1183"><code>runtime.mstart</code></a> 会执行调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/proc.go#L2001"><code>runtime.newm</code></a> 时传入的匿名函数 <code>fn</code>，完成了从线程创建到销毁的整个闭环。</p><h2 id="参考">参考</h2><p><a target="_blank" rel="noopener" href="https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go 语言设计与实现</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io">Liuyi Wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io/posts/b1ea32a.html">http://wenliuyi.github.io/posts/b1ea32a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wenliuyi.github.io" target="_blank">Liuyi Wen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WechatIMG105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/d1f88670.html" title="并发系列：1. 自旋锁"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">并发系列：1. 自旋锁</div></div><div class="info-2"><div class="info-item-1">首先从乐观锁和悲观锁的设计思想开始。 乐观锁和悲观锁 悲观锁 悲观锁总认为最坏的情况可能会出现，即数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源或者数据锁住，其他线程想要请求这个资源时阻塞，直到悲观锁释放资源（读写操作均加锁）。传统的关系型数据库里边就用到了很多悲观锁机制，比如行锁，表锁等，读锁，写锁等，均在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。 Java 中的 Synchronized 和 ReentrantLock 等独占锁(排他锁)也是一种悲观锁思想的实现，因为 Synchronzied 和 ReetrantLock 不管是否持有资源，它都会尝试去加锁。 一个悲观锁的运用场景： select * from student where name="cxuan" for update 这条 sql 语句从 Student 表中选取 name =...</div></div></div></a><a class="pagination-related" href="/posts/cda30c10.html" title="Go-内存分配器"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go-内存分配器</div></div><div class="info-2"><div class="info-item-1">内存分配器 内存空间包含两个重要区域：栈区和堆区。不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。 设计原理 内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）；当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。 分配方法 线性分配器 使用线性分配器时，只需要在内存中维护一个指向特定位置的指针；用户程序申请内存时，移动指针。然而，这不利于在内存被释放时重用内存。如下图中红色部分难以利用： 因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和...</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/WechatIMG105.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">Go-调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">设计原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">单线程调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">多线程调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AA%83%E5%8F%96%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">任务窃取调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8p"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">处理器P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syscallm%E7%9A%84%E6%8C%82%E9%9D%A0%E5%92%8C%E8%A7%A3%E6%8C%82%E9%9D%A0"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Syscall&#x2F;M的挂靠和解挂靠</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">抢占式调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">基于协作的抢占式调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">基于信号的抢占式调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#g"><span class="toc-number">1.2.1.</span> <span class="toc-text">G</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sched%E5%AD%97%E6%AE%B5%E7%9A%84runtime.gobuf%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">sched字段的runtime.gobuf结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine%E7%9A%84%E7%8A%B6%E6%80%81%E5%AF%B9%E5%BA%94atomicstatus%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Goroutine的状态（对应atomicstatus字段）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#m"><span class="toc-number">1.2.2.</span> <span class="toc-text">M</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p"><span class="toc-number">1.2.3.</span> <span class="toc-text">P</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#p%E7%9A%84%E7%8A%B6%E6%80%81%E5%AF%B9%E5%BA%94status%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">P的状态（对应status字段）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">1.3.</span> <span class="toc-text">调度器启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAgoroutine"><span class="toc-number">1.4.</span> <span class="toc-text">创建Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93runtime.gfget"><span class="toc-number">1.4.1.</span> <span class="toc-text">初始化结构体（runtime.gfget）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B0%83%E5%BA%A6%E4%BF%A1%E6%81%AFsched"><span class="toc-number">1.4.2.</span> <span class="toc-text">设置调度信息sched</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97runqput"><span class="toc-number">1.4.3.</span> <span class="toc-text">运行队列（runqput）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF%E6%9F%A5%E6%89%BE%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84goroutine"><span class="toc-number">1.5.</span> <span class="toc-text">调度循环：查找可执行的Goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text">触发调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%8C%82%E8%B5%B7"><span class="toc-number">1.6.1.</span> <span class="toc-text">主动挂起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">准备工作：分离线程和处理器，释放锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%B7%A5%E4%BD%9C%E4%B8%BA%E5%BD%93%E5%89%8Dgoroutine%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">恢复工作：为当前Goroutine重新分配资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.6.3.</span> <span class="toc-text">协作式调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">线程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">线程生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.8.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/cda30c10.html" title="Go-内存分配器">Go-内存分配器</a><time datetime="2025-07-18T13:37:10.000Z" title="发表于 2025-07-18 21:37:10">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b1ea32a.html" title="Go-调度器">Go-调度器</a><time datetime="2025-07-17T03:20:39.000Z" title="发表于 2025-07-17 11:20:39">2025-07-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d1f88670.html" title="并发系列：1. 自旋锁">并发系列：1. 自旋锁</a><time datetime="2025-07-14T11:21:14.000Z" title="发表于 2025-07-14 19:21:14">2025-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/e8d1fb4.html" title="Go-channel">Go-channel</a><time datetime="2025-07-11T10:41:20.000Z" title="发表于 2025-07-11 18:41:20">2025-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4e29148d.html" title="Go-上下文Context">Go-上下文Context</a><time datetime="2025-07-09T09:16:57.000Z" title="发表于 2025-07-09 17:16:57">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=(e,o)=>{n&&(window.shuoshuoComment.destroyValine=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))});const t={el:"#vcomment",appId:"bsxtUJWr1muoPS1pmoXLOPZ2-gzGzoHsz",appKey:"wm2wUYvKLEySwyRnFn7xAbJI",avatar:"monsterid",serverURLs:"",emojiMaps:"",visitor:!1,path:n?o:window.location.pathname};new Valine(t)},o=async(n,o)=>{"function"==typeof Valine||await btf.getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"),e(n,o)};n?window.shuoshuoComment={loadComment:o}:btf.loadComment(document.getElementById("vcomment"),o)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>