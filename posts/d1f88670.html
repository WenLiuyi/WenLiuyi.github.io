<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>并发系列：1. 自旋锁 | Liuyi Wen's Blog</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="首先从乐观锁和悲观锁的设计思想开始。 乐观锁和悲观锁 悲观锁 悲观锁总认为最坏的情况可能会出现，即数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源或者数据锁住，其他线程想要请求这个资源时阻塞，直到悲观锁释放资源（读写操作均加锁）。传统的关系型数据库里边就用到了很多悲观锁机制，比如行锁，表锁等，读锁，写锁等，均在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。 Java"><meta property="og:type" content="article"><meta property="og:title" content="并发系列：1. 自旋锁"><meta property="og:url" content="http://wenliuyi.github.io/posts/d1f88670.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:description" content="首先从乐观锁和悲观锁的设计思想开始。 乐观锁和悲观锁 悲观锁 悲观锁总认为最坏的情况可能会出现，即数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源或者数据锁住，其他线程想要请求这个资源时阻塞，直到悲观锁释放资源（读写操作均加锁）。传统的关系型数据库里边就用到了很多悲观锁机制，比如行锁，表锁等，读锁，写锁等，均在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。 Java"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><meta property="article:published_time" content="2025-07-14T11:21:14.000Z"><meta property="article:modified_time" content="2025-07-14T11:27:21.073Z"><meta property="article:author" content="Liuyi Wen"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并发系列：1. 自旋锁",
  "url": "http://wenliuyi.github.io/posts/d1f88670.html",
  "image": "http://wenliuyi.github.io/img/WechatIMG105.jpg",
  "datePublished": "2025-07-14T11:21:14.000Z",
  "dateModified": "2025-07-14T11:27:21.073Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liuyi Wen",
      "url": "http://wenliuyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/posts/d1f88670.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"并发系列：1. 自旋锁",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">并发系列：1. 自旋锁</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">并发系列：1. 自旋锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-14T11:21:14.000Z" title="发表于 2025-07-14 19:21:14">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-14T11:27:21.073Z" title="更新于 2025-07-14 19:27:21">2025-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/High-Concurrency/">High Concurrency</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>首先从乐观锁和悲观锁的设计思想开始。</p><h2 id="乐观锁和悲观锁">乐观锁和悲观锁</h2><h3 id="悲观锁">悲观锁</h3><p>悲观锁总认为最坏的情况可能会出现，即数据很可能会被其他人所修改，所以<strong>悲观锁在持有数据的时候总会把资源或者数据锁住，其他线程想要请求这个资源时阻塞，直到悲观锁释放资源</strong>（<strong>读写操作均加锁</strong>）。传统的关系型数据库里边就用到了很多悲观锁机制，比如行锁，表锁等，读锁，写锁等，均在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的锁功能实现。</p><p>Java 中的 <code>Synchronized</code> 和 <code>ReentrantLock</code> 等独占锁(排他锁)也是一种悲观锁思想的实现，因为 <code>Synchronzied</code> 和 <code>ReetrantLock</code> 不管是否持有资源，它都会尝试去加锁。</p><blockquote><p>一个悲观锁的运用场景： <code>select * from student where name="cxuan" for update</code> 这条 sql 语句从 Student 表中选取 name = "cxuan" 的记录并对其加锁，那么其他写操作再这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。</p></blockquote><p>悲观锁因为对读写都加锁，所以性能较差，不适用多并发场景。</p><h3 id="乐观锁">乐观锁</h3><p>乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以<strong>乐观锁读取不上锁，但是在写入操作时会判断当前数据是否被修改过</strong>。乐观锁的实现方案一般有两种：<strong>版本号机制</strong>和<strong>CAS实现</strong>。乐观锁多适用于<strong>多读</strong>的应用类型，这样可以提高吞吐量。</p><p>在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h4 id="乐观锁的实现方式">乐观锁的实现方式</h4><h5 id="版本号机制">版本号机制</h5><p><strong>通过数据表中加上一个 <code>version</code> 字段实现：表示数据被修改的次数</strong>。<strong>当执行写操作并且写入成功后，<code>version = version + 1</code></strong>。当线程A要更新数据时，在读取数据的同时也会读取 <code>version</code> 值；在提交更新时，若刚才读取到的 <code>version</code> 值为当前数据库中的<code>version</code>值相等时才更新，否则重试更新操作，直到更新成功。</p><p>举一个栗子： <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/d1f88670/image-18.png"></p><ol type="1"><li>事务一开启，男柜员先执行读操作，取出金额和版本号，执行写操作：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表 <span class="keyword">set</span> 金额 <span class="operator">=</span> <span class="number">120</span>,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> 金额 <span class="operator">=</span> <span class="number">100</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>此时金额改为 120，版本号为1，事务未提交。</p><ol start="2" type="1"><li>事务二开启，女柜员先执行读操作，取出金额和版本号，执行写操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表 <span class="keyword">set</span> 金额 <span class="operator">=</span> <span class="number">50</span>,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> 金额 <span class="operator">=</span> <span class="number">100</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>此时金额改为 50，版本号变为 1，事务未提交。</p><ol start="3" type="1"><li>现在提交事务一，金额改为 120，版本变为1，提交事务。理想情况下应该变为 金额 = 50，版本号 = 2，但是实际上事务二 的更新是建立在金额为 100 和 版本号为 0 的基础上的，所以事务二不会提交成功，应该重新读取金额和版本号，再次进行写操作。（这样，就避免了女柜员 用基于 <code>version=0</code> 的旧数据修改的结果覆盖男操作员操作结果的可能）</li></ol><h5 id="cas算法">CAS算法</h5><p>CAS 即 <code>compare and swap</code>（比较与交换），是一种有名的无锁算法。即<strong>不使用锁的情况下实现多线程之间的变量同步</strong>，也就是在<strong>没有线程被阻塞</strong>的情况下实现变量的同步，所以也叫非阻塞同步。</p><p>CAS涉及3个要素：需要读写的内存值 <code>V</code>；进行比较的值 <code>A</code>；拟写入的新值 <code>B</code>。</p><p><strong>当且仅当预期值<code>A</code>和内存值<code>V</code>相同时，将内存值<code>V</code>修改为<code>B</code></strong>，否则什么都不做。</p><blockquote><p>JAVA对CAS的支持：在JDK1.5 中新添加 <code>java.util.concurrent</code> (J.U.C) 就是建立在 CAS 之上的。</p></blockquote><h4 id="乐观锁的缺点">乐观锁的缺点</h4><h5 id="aba问题">ABA问题</h5><p>如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？可以是由 A -&gt; B -&gt; A 的这种情况，（<code>AtomicInteger</code>没有考虑这种情况）</p><p>JDK 1.5 以后的 <code>AtomicStampedReference</code>类提供该能力：其中的 <code>compareAndSet</code> 方法首先<strong>检查当前引用是否等于预期引用，以及当前标志是否等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>也可以采用CAS的一个变种DCAS解决上述问题：对于每一个<code>V</code>增加一个表示<strong>引用修改次数</strong>的标记符。<strong>对于每个<code>V</code>，如果引用修改了一次，这个计数器就加1</strong>。当该变量需要update的时候，就同时检查变量的值和计数器的值。</p><h5 id="循环开销大">循环开销大</h5><p>乐观锁在进行写操作时判断是否能够写入成功；如果写入不成功，将触发等待 -&gt; 重试机制。这通常通过一个自旋锁实现：适用于短期内获取不到、等待重试的锁；但<strong>不适用于长期获取不到锁的情况</strong>。另外，自旋循环对于性能开销比较大。</p><h4 id="java的cas和synchronized使用场景">Java的CAS和synchronized使用场景</h4><p><strong>CAS 适用于多读场景（写冲突较少）；<code>synchronized</code> 适用于多写场景（写冲突较多）</strong>。</p><ol type="1"><li>对于<strong>资源竞争较少（线程冲突较轻）的情况</strong>：使用 <code>synchronized</code> 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于<strong>资源竞争严重（线程冲突严重）的情况</strong>：CAS 自旋的概率较大，从而浪费更多的 CPU 资源，效率低于 <code>synchronized</code>。</li></ol><h2 id="自旋锁">自旋锁</h2><h3 id="提出背景">提出背景</h3><p>多处理器环境中的资源常常通过锁实现资源的互斥访问。同一时间，只能有一个线程获取到锁。那<strong>没有获取到锁的线程应该怎么办呢？</strong>通常有两种处理方式：</p><ol type="1"><li><strong>自旋锁（非阻塞）</strong>：循环等待，判断该资源是否已经释放锁；</li><li><strong>互斥锁（阻塞）</strong>：自己阻塞，等待重新调度请求。</li></ol><h3 id="工作原理">工作原理</h3><p>自旋锁的核心思想是<strong>通过一个共享变量（通常是原子变量）来控制锁的状态</strong>。当一个线程尝试获取锁时，它会检查该变量的值：</p><ol type="1"><li>如果锁未被占用（变量值为 <code>false</code>），线程可以成功获取锁，并将变量值设置为 <code>true</code>；</li><li>如果锁已被占用（变量值为 <code>true</code>），线程会进入一个循环，不断检查变量值，直到锁被释放。</li></ol><h3 id="优缺点">优缺点</h3><p>优点：</p><ol type="1"><li><p><strong>减少线程上下文切换开销</strong>：当锁已经被占用时，线程不会进入操作系统的调度队列，也即<strong>不需要做内核态和用户态之间的切换进入阻塞状态</strong>，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p></li><li><p><strong>自旋锁通常适用在时间比较短的情况</strong>。</p></li></ol><p>缺点：</p><ol type="1"><li><strong>忙等待浪费CPU资源</strong>：如果长时间上锁，会有<strong>大量的线程处于自旋状态占用 CPU 资源</strong>，进而会影响整体系统的性能；</li><li><strong>可能导致活锁</strong>：线程持有锁的时间越长，则持有该锁的线程被OS调度程序中断的风险越大。<strong>如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止</strong>。<ul><li>解决方法：设定<strong>自旋时间</strong>，到时间后立即释放自旋锁。</li></ul></li><li><strong>不适用于高负载的情况</strong>：在高并发的环境下，自旋锁可能会造成性能下降，因为自旋时的CPU消耗可能会比阻塞等待的成本还要高。</li></ol><h3 id="示例">示例</h3><h4 id="一个c栗子">一个C++栗子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;   <span class="comment">// 初始化一个原子布尔类型变量：专门用于标记锁的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待锁释放：不断循环，直到flag变为false，即锁被释放</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                flag.test_and_set是一个原子操作, 它会检查 flag 的值并将其设置为 true：</span></span><br><span class="line"><span class="comment">                如果原本是 false， 它就设置为true，并返回false表示锁被成功获得；否则返回 true，表示锁已经被占用，此时进入循环等待。</span></span><br><span class="line"><span class="comment">                当 flag 被设置为 true 时，表示锁被占用，此时会不断循环直到 flag 被清除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                std::memory_order_acquire 是一个内存顺序， 保证了当前线程获取锁时，所有先前对共享数据的读写操作会在获取锁之前完成，从而保证内存顺序。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁的原子操作，清除atomic_flag, 将其设置为 false，允许其他线程获取锁</span></span><br><span class="line">         <span class="comment">//std::memory_order_relase 保证了释放锁时，前面的操作会在此锁释放前可见</span></span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：使用自旋锁保护共享变量</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">(SpinLock&amp; lock, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working with shared data.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 2. 操作共享数据</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    <span class="comment">// 3. 模拟线程工作时的一段时间延迟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished working. Shared data = &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 4. 释放锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpinLock spinlock;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(thread_task, std::<span class="built_in">ref</span>(spinlock), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个java栗子">一个Java栗子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不支持重入：一个线程第一次已经获取到了该锁，如果在锁释放之前又一次重新获取该锁，第二次就不能成功获取到（由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的）</p><h5 id="可重入自旋锁">可重入自旋锁</h5><p>如何实现可重入锁呢？<strong>引入一个计数器，记录获取锁的线程数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="literal">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cur</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">                cas.compareAndSet(cur, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁的其他变种">自旋锁的其他变种</h3><h4 id="ticketlock"><code>TicketLock</code></h4><p>思路：<strong>每当有线程获取锁的时候，就给该线程分配一个递增的id</strong>，称之为<strong>排队号</strong>；<strong>锁对应一个服务号</strong>，<strong>每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁</strong>，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketLock</span> &#123;</span><br><span class="line">    <span class="comment">// 服务号：当前持有锁的线程号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">serviceNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">// 排队号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">// 新增一个ThreadLocal，用于存储每个线程的排队号</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 为当前线程分配一个新的排队号 currentTicketNum</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentTicketNum</span> <span class="operator">=</span> ticketNum.incrementAndGet();</span><br><span class="line">        <span class="comment">// 2. 每个线程获取锁的时候（即调用lock()的时候）：将当前线程的排队号保存在ticketNumHolder中</span></span><br><span class="line">        ticketNumHolder.set(currentTicketNum);</span><br><span class="line">        <span class="comment">// 3. 自旋等待：循环判断排队号是否等于服务号</span></span><br><span class="line">        <span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">currentTickNum</span> <span class="operator">=</span> ticketNumHolder.get();</span><br><span class="line">        <span class="comment">// 2. 释放锁</span></span><br><span class="line">        <span class="comment">// 检查 serviceNum 是否等于 currentTickNum：如果相等，则将 serviceNum 更新为 currentTickNum + 1，表示下一个线程可以获得锁；如果不相等，不做任何更改</span></span><br><span class="line">        serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：保证了线程按照请求的顺序获取锁，<strong>不会出现线程饥饿</strong>的情况；</p><p><strong>缺点</strong>：多处理系统上，<strong>每个进程/线程占用的处理器都在读写同一个变量<code>serviceNum</code></strong>；每次读写操作都必须在多个处理器缓存之间进行<strong>缓存同步</strong>，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p><h4 id="clhlock"><code>CLHLock</code></h4><p>CLH锁是一种基于<strong>链表</strong>的可扩展、高性能、公平的自旋锁，<strong>申请线程只在本地变量上自旋，它不断轮询前驱的状态</strong>：如果发现前驱释放锁就结束自旋，获得锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> &#123;</span><br><span class="line">    <span class="comment">// 锁的基本单元：每个线程在请求锁时，都会创建一个 CLHNode 对象，节点的状态由 isLocked 字段表示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CLHNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾部节点：表示最后一个请求锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="comment">// 线程本地存储：保存每个线程自己创建的 CLHNode 对象（每个线程只关心自己的节点，而不需要知道其他线程的节点）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;CLHNode&gt;();</span><br><span class="line">    <span class="comment">// 原子更新器：用于原子地更新 CLHLock 对象中的 tail 字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class,</span><br><span class="line">            <span class="string">&quot;tail&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建节点并保存到 LOCAL：</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLHNode</span>();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        <span class="comment">// 2. 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, node);    </span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 等待前驱节点释放锁：前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位，等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = <span class="literal">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程对应的节点</span></span><br><span class="line">        <span class="type">CLHNode</span> <span class="variable">node</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">        <span class="comment">// 2.1 如果tail节点等于node（即当前线程是最后一个请求锁的线程）：则将tail节点更新为null；</span></span><br><span class="line">        <span class="comment">// 2.2 如果tail节点不等于node：将node的isLocked状态设置为false，表示当前线程释放了锁</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="built_in">this</span>, node, <span class="literal">null</span>)) &#123;</span><br><span class="line">            node.isLocked = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作原理小结：</p><p><strong>线程获取锁</strong>：</p><ol type="1"><li>每个线程调用<code>lock()</code>时：创建一个新的<code>CLHNode</code>节点，将其与当前线程关联；</li><li>当前线程（通过原子操作）将自身节点设置为锁的尾部<code>tail</code>；</li><li><strong>如果有前驱节点（即当前线程不是第一个请求锁的线程）：则进入自旋状态，等待前驱节点释放锁</strong>；</li><li>只有前驱节点的<code>isLocked</code>被设置为<code>false</code>时：当前节点才能获取锁并继续执行。</li></ol><p><strong>线程释放锁</strong>：</p><ol type="1"><li>当前线程调用<code>unlock()</code>时：获取自己对应的<code>CLHNode</code>节点；</li><li>如果当前线程的节点是 <code>tail</code>（最后一个请求锁的线程）：则将 <code>tail</code> 设置为 <code>null</code>，表示锁已被释放；</li><li>如果<strong>当前线程不是 <code>tail</code>：则将 <code>isLocked</code> 设置为 <code>false</code>，释放锁并允许其他线程获取锁</strong>。</li></ol><p><strong>优点</strong>：<strong>将获取锁的线程状态借助节点(node)保存,每个线程都有一份独立的节点，解决了TicketLock多处理器缓存同步的问题</strong>；每个线程都只关心前一个线程的锁状态，而不需要直接访问其他线程的节点，减少了共享内存的访问，从而减少了锁竞争； <strong>缺点</strong>：每个线程都需要一个独立的 <code>CLHNode</code> 节点，这可能导致较高的内存消耗，尤其在高并发情况下。</p><h4 id="mcslock"><code>MCSLock</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MCS:发明人名字John Mellor-Crummey和Michael Scott</span></span><br><span class="line"><span class="comment"> * 代码来源：http://ifeve.com/java_lock_see2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> &#123;</span><br><span class="line">   <span class="comment">// 每个线程在等待锁时，创建的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MCSNode</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> MCSNode next;              <span class="comment">// 指向后驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">// 当前线程是否在等待锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;MCSNode&gt; NODE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;MCSNode&gt;();</span><br><span class="line">    <span class="comment">// 队列：存储正在等待锁的线程的节点</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MCSNode queue;</span><br><span class="line">    <span class="comment">// queue原子更新器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class,</span><br><span class="line">            <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建节点，并保存到ThreadLocal中</span></span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MCSNode</span>();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        <span class="comment">// 2. 将当前线程的节点设置为队列尾部，并且返回前一个节点</span></span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">preNode</span> <span class="operator">=</span> UPDATER.getAndSet(<span class="built_in">this</span>, currentNode);</span><br><span class="line">        <span class="comment">// 3. 等待锁</span></span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果之前节点不为null，表示锁已经被其他线程持有</span></span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            <span class="comment">// 循环判断，直到当前节点的锁标志位为false</span></span><br><span class="line">            <span class="keyword">while</span> (currentNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前线程的节点</span></span><br><span class="line">        <span class="type">MCSNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> NODE.get();</span><br><span class="line">        <span class="comment">// 2. 检查当前线程是否为队尾节点：</span></span><br><span class="line">        <span class="comment">// 2.1 是队尾节点：next为null表示没有正在等待获取锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新状态并设置queue为null</span></span><br><span class="line">            <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="built_in">this</span>, currentNode, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果成功了，表示queue==currentNode,即当前节点后面没有节点了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待</span></span><br><span class="line">                <span class="comment">// 如果当前节点的后续节点为null，则需要等待其不为null</span></span><br><span class="line">                <span class="keyword">while</span> (currentNode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 不是队尾节点：唤醒后继节点</span></span><br><span class="line">            <span class="comment">// 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false（表示该线程可以获取锁），同时将当前线程的后继节点设为null</span></span><br><span class="line">            currentNode.next.isLocked = <span class="literal">false</span>;</span><br><span class="line">            currentNode.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLHLock和MCSLock的共同点是什么呢？每个线程都有一份独立的节点，都通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能；</p><p>CLHLock和MCSLock的区别是什么呢？CLHLock轮询其前驱节点的状态；而MCS则是查看当前节点的锁状态。</p><h2 id="参考">参考</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496062&amp;idx=1&amp;sn=c04e0b83f38c45d06538ebac69529ee1&amp;source=41&amp;poc_token=HF-xdGij55Vv_yP40D4XoySu5xDFY5RXNyZvZHy1">看完你就应该能明白的悲观锁和乐观锁</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36894974/article/details/102573482">看完你就明白的锁系列之自旋锁</a></p><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2496984">自旋锁：原理、实现与应用</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/81252853">面试必备之深入理解自旋锁</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io">Liuyi Wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io/posts/d1f88670.html">http://wenliuyi.github.io/posts/d1f88670.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wenliuyi.github.io" target="_blank">Liuyi Wen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WechatIMG105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/e8d1fb4.html" title="Go-channel"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go-channel</div></div><div class="info-2"><div class="info-item-1">Go-Channel Channel是Go的核心数据结构和Goroutine之间的通信方式，支持Go的高性能并发编程模型。 设计原理 不通过共享内存的方式通信，而是通过通信的方式共享内存，采用的并发模式为：CSP（通信顺序进程）。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。 怎么理解“不通过共享内存的方式通信，而是通过通信的方式共享内存”这句话呢？ 前半句指通过 sync 包里的一些组件进行并发编程；后半句指使用 channel 进行并发编程。实际上，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。 上图中的两个 Goroutine，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。 FIFO Channel的收发操作遵循“先进先出”： 先从 Channel 读取数据的 Goroutine...</div></div></div></a><a class="pagination-related" href="/posts/b1ea32a.html" title="Go-调度器"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go-调度器</div></div><div class="info-2"><div class="info-item-1">Go-调度器 多个线程可以属于同一个进程并共享内存空间。因此它们也不需要内存管理单元处理上下文的切换，线程之间的通信是基于共享的内存进行的。 虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间1，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销。 Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。 设计原理 包括以下几个版本： 单线程调度器：程序中只能存在一个活跃线程，由G-M模型组成； 单线程调度器 0.x...</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/WechatIMG105.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">乐观锁的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cas%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">CAS算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">乐观锁的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#aba%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">循环开销大</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%9A%84cas%E5%92%8Csynchronized%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">Java的CAS和synchronized使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">提出背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAc%E6%A0%97%E5%AD%90"><span class="toc-number">2.4.1.</span> <span class="toc-text">一个C++栗子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAjava%E6%A0%97%E5%AD%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">一个Java栗子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">可重入自旋锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%98%E7%A7%8D"><span class="toc-number">2.5.</span> <span class="toc-text">自旋锁的其他变种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ticketlock"><span class="toc-number">2.5.1.</span> <span class="toc-text">TicketLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clhlock"><span class="toc-number">2.5.2.</span> <span class="toc-text">CLHLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcslock"><span class="toc-number">2.5.3.</span> <span class="toc-text">MCSLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7529a079.html" title="并行训练系列：2. 数据并行下篇（ZeRO）">并行训练系列：2. 数据并行下篇（ZeRO）</a><time datetime="2025-09-17T10:00:42.000Z" title="发表于 2025-09-17 18:00:42">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3858f068.html" title="并行训练系列：2. 数据并行上篇（DP，DDP）">并行训练系列：2. 数据并行上篇（DP，DDP）</a><time datetime="2025-09-16T07:43:28.000Z" title="发表于 2025-09-16 15:43:28">2025-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ab0f7bb9.html" title="RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代">RL 系列：2. 从 Bellman 算子的角度解释策略迭代/价值迭代</a><time datetime="2025-09-15T08:22:53.000Z" title="发表于 2025-09-15 16:22:53">2025-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ba1e1693.html" title="RL 系列：1. Markov 决策过程">RL 系列：1. Markov 决策过程</a><time datetime="2025-09-08T09:29:49.000Z" title="发表于 2025-09-08 17:29:49">2025-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b1ea32a.html" title="Go 的长连接">Go 的长连接</a><time datetime="2025-09-03T03:20:39.000Z" title="发表于 2025-09-03 11:20:39">2025-09-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=(e,o)=>{n&&(window.shuoshuoComment.destroyValine=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))});const t={el:"#vcomment",appId:"bsxtUJWr1muoPS1pmoXLOPZ2-gzGzoHsz",appKey:"wm2wUYvKLEySwyRnFn7xAbJI",avatar:"monsterid",serverURLs:"",emojiMaps:"",visitor:!1,path:n?o:window.location.pathname};new Valine(t)},o=async(n,o)=>{"function"==typeof Valine||await btf.getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"),e(n,o)};n?window.shuoshuoComment={loadComment:o}:btf.loadComment(document.getElementById("vcomment"),o)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>