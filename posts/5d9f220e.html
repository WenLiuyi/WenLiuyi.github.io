<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析 | Liuyi Wen's Blog</title><meta name="author" content="Liuyi Wen"><meta name="copyright" content="Liuyi Wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="现代计算机体系结构 现代计算机体系结构如下：  多核：一台计算机上有多颗CPU，每个 CPU 有多个计算核心。CPU内部有缓存结构，外部有主存。 集群：多台计算机通过高速网络互联，每台计算机上配有至少一块高速网卡。使得不同节点之间互相访问数据就像在单个节点一样。 异构计算：CPU 和主存通常被称为主机（Host），各类专用的加速器被称为设备（Device）。当前基于 GPU 的异构计算是主流，GP"><meta property="og:type" content="article"><meta property="og:title" content="verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析"><meta property="og:url" content="http://wenliuyi.github.io/posts/5d9f220e.html"><meta property="og:site_name" content="Liuyi Wen&#39;s Blog"><meta property="og:description" content="现代计算机体系结构 现代计算机体系结构如下：  多核：一台计算机上有多颗CPU，每个 CPU 有多个计算核心。CPU内部有缓存结构，外部有主存。 集群：多台计算机通过高速网络互联，每台计算机上配有至少一块高速网卡。使得不同节点之间互相访问数据就像在单个节点一样。 异构计算：CPU 和主存通常被称为主机（Host），各类专用的加速器被称为设备（Device）。当前基于 GPU 的异构计算是主流，GP"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><meta property="article:published_time" content="2025-05-03T11:46:47.000Z"><meta property="article:modified_time" content="2025-09-08T09:28:48.409Z"><meta property="article:author" content="Liuyi Wen"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://wenliuyi.github.io/img/WechatIMG105.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析",
  "url": "http://wenliuyi.github.io/posts/5d9f220e.html",
  "image": "http://wenliuyi.github.io/img/WechatIMG105.jpg",
  "datePublished": "2025-05-03T11:46:47.000Z",
  "dateModified": "2025-09-08T09:28:48.409Z",
  "author": [
    {
      "@type": "Person",
      "name": "Liuyi Wen",
      "url": "http://wenliuyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wenliuyi.github.io/posts/5d9f220e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"VE36MEFVE6",apiKey:"f9b9ca5a3cdb9455658600dba6ae7706",indexName:"hexo-algolia indexing key",hitsPerPage:6,languages:{input_placeholder:"搜索文章",hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Liuyi Wen's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">verl框架：1. Ray集群介绍+verl中基于Ray的执行流程解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-03T11:46:47.000Z" title="发表于 2025-05-03 19:46:47">2025-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-08T09:28:48.409Z" title="更新于 2025-09-08 17:28:48">2025-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/verl/">verl</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="现代计算机体系结构">现代计算机体系结构</h2><p>现代计算机体系结构如下：</p><ul><li><strong>多核</strong>：一台计算机上有多颗CPU，每个 CPU 有多个计算核心。CPU内部有缓存结构，外部有主存。</li><li><strong>集群</strong>：多台计算机通过高速网络互联，每台计算机上配有至少一块高速网卡。使得不同节点之间互相访问数据就像在单个节点一样。</li><li><strong>异构计算</strong>：CPU 和主存通常被称为主机（Host），各类专用的加速器被称为设备（Device）。当前基于 GPU 的异构计算是主流，GPU 有区别于 CPU 的芯片微架构和编译软件栈。<ul><li>软件层面：GPU 提供了 CUDA编程接口；</li><li>硬件层面：GPU 有很多个专用计算核心，和 GPU 上的存储。</li></ul></li></ul><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/computer-arch.svg"></p><h2 id="并行程序设计方法pcam">并行程序设计方法：PCAM</h2><p>如何设计软件和算法，使得程序可以并行运行在多核或者集群上？PCAM共包括4个步骤：</p><ul><li><strong>切分</strong>：将整个问题切分为多个子问题或子任务，既包括计算部分也包括数据部分；</li><li><strong>通信</strong>：不同子任务之间通信方式，需要包括通信的数据结构、通信算法；</li><li><strong>聚集</strong>：考虑到当前所拥有的硬件性能和编程难度，将上面两步进一步整合，将细粒度的任务整合成更高效的任务；</li><li><strong>分发</strong>：将整合好的任务分发给多个处理器。</li></ul><blockquote><p>举个栗子：有一个超大矩阵，矩阵大小为 M×M，这个矩阵大到无法放在单个计算节点上计算，现在想获取这个矩阵的最大值。设计并行算法时，可以考虑如下思路：</p><ul><li>将矩阵切分成子矩阵，每个子矩阵 m×m 大小，在<strong>每台计算节点上执行 <code>max()</code> 函数</strong>求得子矩阵的最大值；</li><li>将<strong>每个子矩阵的最大值汇集到一个计算节点</strong>，在该节点再次执行一下 <code>max()</code> 求得整个矩阵的最大值；</li></ul></blockquote><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/pcam.svg"></p><h3 id="案例mapreduce">案例：MapReduce</h3><p>Google在2004年提出的MapReduce是一种经典的大数据并行计算范式。其中主要涉及四个阶段：</p><ul><li>切分（Split）：将大数据切分成很多份小数据，<strong>每份小数据可以在单个 Worker 上计算</strong>。</li><li>映射（Map）：<strong>对每个小数据执行 Map 操作</strong>，Map 是一个函数映射，程序员需要<strong>自定义 Map 函数，Map 函数输出一个键值对（Key-Value）</strong>。在词频统计的例子中，每出现一个词，计 1 次，Key 是词，Value 是 1，表示出现 1 次。</li><li>交换（Shuffle）：<strong>将相同的 Key 归结到相同的 Worker 上</strong>。这一步涉及数据交换。词频统计的例子中，将相同的词发送到同一个 Worker 上。</li><li>聚合（Reduce）：<strong>所有相同的 Key 进行聚合操作</strong>，程序员需要<strong>自定义 Reduce 函数</strong>。词频统计的例子中，之前 Shuffle 阶段将已经将相同的 Key 归结到了一起，现在只需要将所有词频求和。</li></ul><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/map-reduce.svg"></p><h3 id="性能指标">性能指标</h3><h4 id="flops">FLOPs</h4><p>FLOPS 指<strong>每秒钟能够完成多少次浮点计算</strong>。如果进行一个 n 维向量加法：a+b，所需的浮点计算次数为 n。将浮点计算次数除以时间，就是 FLOPS。</p><h4 id="加速比">加速比</h4><p>衡量并行相对于串行执行时间的缩短程度：加速比=<span class="math inline">\(\frac{t_s}{t_p}\)</span>，其中 <span class="math inline">\(t_s\)</span> 为串行程序执行时间，<span class="math inline">\(t_p\)</span> 为并行程序执行时间。</p><ul><li><strong>效率</strong>：效率=<span class="math inline">\(\frac{加速比}{N}\)</span>。其中 N 为并行程序所使用的计算核心的数目。</li></ul><p>当加速比为 N 时，串行程序可以被线性拓展到多个计算核心上，可以说并行程序获得了<strong>线性加速比</strong>，即理想情况。现实中，并行程序需要有调度器将不同的任务分发到多个 Worker 上，多个 Worker 之间需要通信，以及数据需要在多个 Worker 之间需要同步，这些步骤都会浪费时间。</p><h2 id="ray">Ray</h2><h3 id="ray结构">Ray结构</h3><p>Ray最初为强化学习设计。</p><p>当前 Ray 主要由底层的 Ray Core 和上层的各类 Ray AI (Artificial Intelligence) 生态组成：</p><ul><li>Ray Core 是一系列底层 API, 可以将 Python 函数或者 Python 类等计算任务<strong>横向扩展到多个计算节点上</strong>；</li><li>在 Ray Core 之上，Ray 封装了一些面向数据科学和人工智能的库（Ray AI Libraries），可以进行数据的处理（Ray Data）、模型训练（Ray Train）、模型的超参数调优（Ray Tune），模型推理服务（Ray Serve），强化学习（RLib）等。</li></ul><h5 id="ray-core-api">Ray Core API</h5><p>Ray Core的核心API如下：</p><ul><li><strong>Task</strong>：面向<strong>函数</strong>的接口，该函数可在集群中分布式执行；</li><li><strong>Actor</strong>：面向<strong>类</strong>的接口，该类可在集群中分布式执行；</li><li><strong>Object</strong>：分布式对象（不可变），用于在<strong>Task和Actor之间传递数据</strong>。</li></ul><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/ray-apis.svg"></p><h4 id="分布式函数remote-functionray.remote-装饰器">分布式函数（Remote Function）：<code>@ray.remote</code> 装饰器</h4><p>通过Ray API定义的Task即远程函数，可以运行在远程的Ray集群上。远程函数是<strong>无状态</strong>的：只依赖于函数的输入和输出，不依赖函数作用域之外的中间变量。那么如何将 Python 函数横向扩展到 Ray 集群上？</p><ul><li><p><strong>启动Ray集群</strong>：可使用<a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.init.html">ray.init()函数</a>，启动一个<strong>单节点的Ray集群</strong>，运行在执行这个 Python 任务的计算机上。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ray.is_initialized:</span><br><span class="line">    ray.shutdown()</span><br><span class="line">ray.init(logging_level=logging.ERROR)</span><br></pre></td></tr></table></figure></li></ul><p>通过几个栗子演示。假设使用原生的Python定义一个fibonacci函数，想让这个 Python 函数被 Ray 分布式执行，只需要<strong>在函数上增加一个 <code>@ray.remote</code> 装饰器</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fibonacci函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_fibonacci</span>(<span class="params">sequence_size</span>):</span><br><span class="line">    fibonacci = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, sequence_size):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">            fibonacci.append(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        fibonacci.append(fibonacci[i-<span class="number">1</span>] + fibonacci[i-<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(fibonacci)</span><br><span class="line"><span class="comment"># 在函数上增加一个 @ray.remote 装饰器</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_fibonacci_distributed</span>(<span class="params">sequence_size</span>):</span><br><span class="line">    <span class="keyword">return</span> generate_fibonacci(sequence_size)</span><br></pre></td></tr></table></figure><p><strong>作为 Ray 的使用者，无需关心 Task 在 Ray 集群中是如何被分布式执行的，也不需要了解这个 Task 被调度到哪些计算节点</strong>。所有这些分布式执行的细节都被 Ray 所隐藏，或者说 Ray 帮我们做了底层的分布式与调度这些工作。</p><p>使用 Ray 进行分布式扩展，函数可并行地在多个 CPU 核心上执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Ray 进行分布式扩展</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_remote</span>(<span class="params">sequence_size</span>):</span><br><span class="line">    results = ray.get([generate_fibonacci_distributed.remote(sequence_size) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(os.cpu_count())])</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><blockquote><p>原生Python函数和Ray的区别：</p><ul><li><strong>调用方式</strong>：<ul><li>原生Python函数：使用 <code>func_name()</code> 调用；</li><li>使用 Ray 时：函数定义增加 <code>@ray.remote</code> 装饰器，调用时使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.remote.html"><code>func_name.remote()</code></a> 的形式。</li></ul></li><li><strong>返回值</strong>：<ul><li>使用 Ray 时：<code>func_name.remote()</code> 返回值是 <code>ray.ObjectRef</code> <strong>类型的对象</strong>，<code>ray.ObjectRef</code> 并不是一个具体的值，而是一个 Future（尚未完成但未来会完成的计算），需要<strong>使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.get.html"><code>ray.get()</code></a> 函数获取该调用的实际返回值</strong>。</li></ul></li><li><strong>执行方式</strong>：<ul><li>原生Python函数：调用形成阻塞，等待结果返回才进行后续计算（<strong>同步执行</strong>）；<ul><li>使用 Ray 时：<strong>异步执行</strong>（<code>func_name.remote</code>非阻塞；<code>ray.get(ObjectRef)</code>阻塞）</li><li>立即返回一个 <code>ray.ObjectRef</code>，调用者不需要等待这个函数的计算真正执行完，函数的计算是在后台某个计算节点上执行的；</li><li><code>ray.get(ObjectRef)</code> 会等待后台计算结果执行完，将结果返回给调用者。</li></ul></li></ul></li></ul></blockquote><h4 id="分布式对象remote-object存储ray.put-与-ray.get">分布式对象（Remote Object）存储：<code>ray.put()</code> 与 <code>ray.get()</code></h4><p>Ray 分布式计算中涉及共享数据可被放在分布式对象存储中，这些数据被称为<strong>远程对象</strong>。我们可以使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.get.html"><code>ray.get()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.put.html"><code>ray.put()</code></a> 读写这些远程对象。与内存中的 Python 对象实例不同，Remote Object 是不可原地直接更改的。</p><p>操作 Remote Object 主要有 <code>ray.put()</code> 和 <code>ray.get()</code> 两个 API：</p><ul><li><code>ray.put()</code> ：把<strong>某个计算节点中的对象数据进行序列化</strong>，并将其<strong>写入到 Ray 集群的分布式对象存储中</strong>，返回一个 <code>RefObjectID</code>（<code>RefObjectID</code> 是<strong>指向这个 Remote Object 的指针</strong>）。我们可以通过引用这个 <code>RefObjectID</code>，在 Remote Function 或 Remote Class 中分布式地使用这个数据对象。</li><li><code>ray.get()</code> ：使用 <code>RefObjectID</code> 把数据从分布式对象存储中拉取回来，并进行<strong>反序列化</strong>。</li><li><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/put-get-object-store.svg"></li></ul><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_rand_tensor</span>(<span class="params">size: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>]</span>) -&gt; torch.tensor:</span><br><span class="line">    <span class="keyword">return</span> torch.randn(size=(size), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据：put(创建 16 个张量，每个张量大小为 (X, 8, 8))</span></span><br><span class="line">tensor_obj_ref_list = [ray.put(create_rand_tensor((i, <span class="number">8</span>, <span class="number">8</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">16</span>)]</span><br><span class="line"><span class="comment"># 读取数据：get</span></span><br><span class="line">val = ray.get(tensor_obj_ref_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h5 id="修改数据">修改数据</h5><p>Remote Ojbect 中的数据是不可修改的（Immutable），即无法对变量原地更改。在单机上，我们可以对变量进行赋值；但<strong>在 Ray 中，我们无法原地更改 Remote Object 的值</strong>。</p><p>如果想使用新数据，应该使用 Remote Function 或者 Remote Class 对 Remote Object 进行转换操作，<strong>生成新的 Remote Object</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform_tensor</span>(<span class="params">tensor: torch.tensor</span>) -&gt; torch.tensor:</span><br><span class="line">    <span class="keyword">return</span> torch.transpose(tensor, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用Remote Function更改数据</span></span><br><span class="line">transformed_object_list = [transform_tensor.remote(t_obj_ref) <span class="keyword">for</span> t_obj_ref <span class="keyword">in</span> tensor_obj_ref_list]</span><br></pre></td></tr></table></figure><h5 id="传递参数通过refobjectid">传递参数：通过<code>RefObjectID</code></h5><ol type="1"><li><p><strong>直接传递</strong>：在 Task 或者 Actor 的函数调用时，将 <code>RefObjectID</code> 作为参数传递进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;current value of argument x: <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># `x_obj_ref` 是一个 `RefObjectID`</span></span><br><span class="line">x_obj_ref = ray.put(x)</span><br><span class="line"><span class="comment"># 直接将RefObjectID作为参数传递，echo()这个 Remote Function 将自动从 `x_obj_ref` 获取 `x` 的值，该过程称为：自动反引用</span></span><br><span class="line">ray.get(echo.remote(x_obj_ref))</span><br></pre></td></tr></table></figure></li></ol><p>​ 输出：<code>(echo pid=22623) current value of argument x: [0, 1, 2, 3, 4]</code></p><ol start="2" type="1"><li><p><strong>复杂数据结构</strong>：如果 <code>RefObjectID</code> 被包裹在一个复杂的数据结构中，Ray 并不会自动获取 <code>RefObjectID</code> 对应的值，即反引用并不是自动的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ray.get(echo.remote(&#123;<span class="string">&quot;obj&quot;</span>: x_obj_ref&#125;))	<span class="comment"># 包裹在一个 dict 中</span></span><br><span class="line">ray.get(echo.remote([x_obj_ref]))					<span class="comment"># 包裹在一个 list 中</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(echo pid=<span class="number">70963</span>) current value of argument x: &#123;<span class="string">&#x27;obj&#x27;</span>: ObjectRef(00ffffffffffffffffffffffffffffffffffffff0100000010000000)&#125;</span><br><span class="line">(echo pid=<span class="number">70963</span>) current value of argument x: [ObjectRef(00ffffffffffffffffffffffffffffffffffffff0100000010000000)]</span><br></pre></td></tr></table></figure></li></ol><h5 id="底层实现">底层实现</h5><ol type="1"><li><p>Ray 集群的<strong>每个计算节点，都有一个基于共享内存的对象存储</strong>。</p></li><li><p>当某个 Remote Object 的数据量较小时（&lt;= 100 KB），它会被存储在<strong>计算节点进程内存</strong>中；当数据量较大时，它会被存储在<strong>分布式的共享内存</strong>中；当集群的共享内存的空间不够时，数据会被<strong>外溢（Spill）到持久化的存储上</strong>，比如硬盘或者S3。</p></li></ol><h4 id="分布式类actor">分布式类（Actor）</h4><p>举个栗子：</p><ol type="1"><li><p>Ray 的 Remote Class 也使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.remote.html"><code>ray.remote()</code></a> 来装饰；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_counter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value</span><br></pre></td></tr></table></figure></li><li><p>初始化一个实例：在类名 <code>Counter</code> 后面加上 <code>remote()</code>，即创建一个分布式的 Actor;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter = Counter.remote()</span><br></pre></td></tr></table></figure></li><li><p>调用实例的函数：加上 <code>remote()</code>，即<code>对象实例.函数名.remote()</code>；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj_ref = counter.increment.remote()</span><br><span class="line"><span class="built_in">print</span>(ray.get(obj_ref))</span><br></pre></td></tr></table></figure></li></ol><p>可以用同一个类创建不同的 Actor 实例：<strong>不同 Actor 实例的成员函数调用可以并行化执行；同一个 Actor 的成员函数调用顺序执行。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 10 个 Actor 实例</span></span><br><span class="line">counters = [Counter.remote() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个 Actor 进行 increment 操作</span></span><br><span class="line"><span class="comment"># 这些操作可以分布式执行</span></span><br><span class="line">results = ray.get([c.increment.remote() <span class="keyword">for</span> c <span class="keyword">in</span> counters])</span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure><blockquote><p>Actor编程模型：分布式编程的范式，基本要素是 <strong>Actor 实例</strong>，即每个 Actor 对象都是唯一的。可以把单个 Actor 实例理解成单个带地址信息的进程。</p><ul><li>Actor 存储的状态数据只能由 Actor 自己来管理，不能被其他 Actor 修改；</li><li><strong>消息驱动</strong>：给某个 Actor 发送消息，它就会对该消息进行响应，修改自身的状态或者继续给其他 Actor 发送消息。</li><li>对同一个 Actor 多次发送同样请求，多次请求是顺序执行的。</li></ul></blockquote><h5 id="栗子actor-pool">栗子：Actor Pool</h5><p>实践上，经常创建一个 Actor 资源池（Actor Pool），<a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.util.ActorPool.html"><code>ActorPool</code></a> 有点像 <code>multiprocessing.Pool</code>，包含多个 Actor，每个 Actor 功能一样，而且可以分布式地在多个计算节点上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ray.util <span class="keyword">import</span> ActorPool</span><br><span class="line"><span class="comment"># 定义一个Actor</span></span><br><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoolActor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, operands</span>):</span><br><span class="line">        (a, b) = operands</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self, operand</span>):</span><br><span class="line">        <span class="keyword">return</span> operand * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建3个Actor实例</span></span><br><span class="line">a1, a2, a3 = PoolActor.remote(), PoolActor.remote(), PoolActor.remote()</span><br><span class="line"><span class="comment"># 将创建的 Actor 添加至 ActorPool 中</span></span><br><span class="line">pool = ActorPool([a1, a2, a3])</span><br></pre></td></tr></table></figure><p>如果我们想调用 <code>ActorPool</code> 中的 Actor，可以使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.util.ActorPool.map.html"><code>map(fn, values)</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.util.ActorPool.submit.html"><code>submit(fn, value)</code></a> 方法。</p><ul><li><code>map()</code> ：<code>values</code> 是一个列表，让函数<strong>并行地分发给多个 Actor 处理</strong>；</li><li><code>submit()</code>： <code>value</code> 是单个值，<strong>每次从 <code>ActorPool</code> 中选择一个 Actor 执行</strong>。<ul><li><code>submit()</code> 的 <code>value</code> 参数只能是单个对象，不能是参数列表，如果想传入多个参数，可以把参数包裹成元组。</li></ul></li></ul><p><code>fn</code> 是一个 Lambda 表达式，或者说是一个匿名函数。这个 Lambda 表达式有两个参数：<code>actor</code> 和 <code>value</code>，<code>actor</code> 是<code>ActorPool</code> 中的 Actor，第二个参数是函数的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="built_in">map</span>(<span class="keyword">lambda</span> a, v: a.double.remote(v), [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">pool.submit(<span class="keyword">lambda</span> a, v: a.double.remote(v), <span class="number">3</span>)</span><br><span class="line">pool.submit(<span class="keyword">lambda</span> a, v: a.double.remote(v), <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><code>map()</code> 和 <code>submit()</code> 将计算任务提交到了 <code>ActorPool</code> 中，<code>ActorPool</code> 并不是直接返回结果，而是异步地分发给后台不同的 Actor 去执行。需要使用 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/ray-core/api/doc/ray.util.ActorPool.get_next.html"><code>get_next()</code></a> 阻塞地返回结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(pool.get_next())</span><br><span class="line">    <span class="built_in">print</span>(pool.get_next())</span><br><span class="line">    <span class="built_in">print</span>(pool.get_next())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="ray集群">Ray集群</h3><p>Ray 集群由一系列计算节点组成，包括两类关键的节点：<strong>头节点</strong>（Head）和<strong>工作节点</strong>（Worker）。这些节点可以部署在虚拟机、容器或者是裸金属服务器上。</p><p>头节点额外包括：GCS，即Ray 集群的全局元数据管理服务；负责存储和管理诸如哪个 Actor 被分配到哪个计算节点等元数据信息。这些<strong>元数据被所有 Worker 共享</strong>。</p><p>每个节点包括一个<strong>Driver：执行程序的入口点，指的是Python 的 <code>__main__</code> 函数</strong>。通常，<code>__main__</code> 在运行时不应该执行大规模计算，而是负责将 Task 和 Actor 调度到具备足够资源的 Worker 上。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/ray-cluster.svg"></p><p>在 Ray 分布式计算环境中，所有节点上都运行着一些关键进程。</p><ul><li><p><strong>Raylet</strong>：<strong>每个计算节点上运行着一个 Raylet</strong>， Raylet 被多个 Worker 进程所共享。Raylet 主要包含两个组件：一个是<strong>调度器</strong>，它负责资源管理和任务分配；另一个是<strong>基于共享内存的对象存储</strong>，它负责本地数据存储，各个计算节点上的对象存储共同构成了 Ray 集群的分布式对象存储。</p></li><li><p><strong>Worker</strong>：<strong>每个计算节点上运行着一个或多个 Worker 进程</strong>，这些进程负责执行计算任务。Worker 进程可以是无状态的，意味着它们可以反复执行 Task 对应的任务；它们也可以是有状态的 Actor，即执行远程类的方法。<strong>默认情况下，Worker 的数量等于其所在计算节点的 CPU 核心数</strong>。</p></li></ul><p>启动Ray集群：如果Python 代码中使用 <code>ray.init()</code> 方式，仅在本地启动了一个单机的 Ray 集群。实际上，Ray 集群包括头节点和工作节点，应该分别启动。先在头节点启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ray start --<span class="built_in">head</span> --port=6379</span><br></pre></td></tr></table></figure><p>启动工作节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ray start --address=&lt;head-node-address&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>通过<code>ray up example.yaml</code>启动：接收 yaml 文件作为参数，在 yaml 文件里定义好头节点地址、工作节点地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster_name:</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">provider:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">head_ip:</span> <span class="string">YOUR_HEAD_NODE_HOSTNAME</span></span><br><span class="line">    <span class="attr">worker_ips:</span> [<span class="string">WORKER_NODE_1_HOSTNAME</span>, <span class="string">WORKER_NODE_2_HOSTNAME</span>, <span class="string">...</span> ]</span><br></pre></td></tr></table></figure><blockquote><p>Ray 的头节点暴露三个端口号，默认分别是 6379, 8265, 10001。</p><ol type="1"><li>启动 Ray 时，设置了 Ray 头节点的端口号，默认为 <strong>6379</strong>，是<strong>头节点和工作节点之间通信的端口</strong>；</li><li>Ray 头节点启动后，提供了一个 Ray 仪表盘端口号，默认为 8265，可用来接收 Ray 命令行提交的作业；</li><li>此外，还有一个端口 10001，默认为 <code>ray.init()</code> 连接时使用。</li></ol></blockquote><h4 id="计算资源与资源组">计算资源与资源组</h4><p>Ray 可以管理计算资源，包括 CPU、内存和 GPU 等各类加速器。这里的计算资源是逻辑上的，逻辑资源与物理上的计算资源相对应。<strong>Ray 集群的各个节点启动时会探测物理计算资源，并根据一定规则映射为逻辑上的计算资源。</strong>默认规则如下：</p><ul><li><p>CPU：每个节点中的物理 CPU 个数（<code>num_cpus</code>）</p></li><li><p>GPU：每个节点中的物理 GPU 个数（<code>num_gpus</code>）</p></li><li><p>内存：每个节点可用内存的 70%（<code>memory</code>）</p><p>可自行指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ray start --num-cpus=32 --num-gpus=4</span><br></pre></td></tr></table></figure></li></ul><p>Ray集群支持<strong>自动缩放</strong>，指的是满足 Task 或 Actor 代码中定义的计算资源请求（比如，<code>task.options()</code> 请求的计算资源），而不是根据计算节点的资源实际利用情况自动缩放。主要面向以下场景：</p><ul><li>当 Ray 集群的资源不够时，创建新的工作节点。</li><li>当某个工作节点闲置或者无法启动，将该工作节点关闭。</li></ul><h5 id="资源需求">资源需求</h5><p>默认情况下：</p><ul><li><p>Ray Task使用1个逻辑CPU，既用于任务调度，也用于执行计算任务；</p></li><li><p>Ray Actor使用1个逻辑CPU进行任务调度，0 个 CPU 运行计算任务。</p><ul><li><p>如果不做设置，可能造成 Ray Actor 不需要计算资源的假象，导致大量 Actor 被调度到同一个计算节点上。可进行指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">4</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">16</span>, num_gpus=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">func.options(num_cpus=<span class="number">4</span>).remote()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="资源组placement-group">资源组（Placement Group）</h5><p>允许用户<strong>原子地</strong>使用集群上多个节点的计算资源：资源要么全部分配给用户，要么完全不分配，不会出现只分配部分资源的情况。主要适用以下场景：</p><ul><li><strong>组调度</strong>：一个作业需要一组资源，这些资源需要协同工作以完成任务。要么分配，要么不分配。如果只分配给这个作业部分资源，将无法完成整个任务。<ul><li>例如在大规模分布式训练中：可能需要多台计算节点和多块GPU，这时可以在Ray集群中申请并分配这些资源。</li></ul></li><li><strong>负载均衡</strong>：作业需要在多个节点上进行负载均衡，每个节点承担一小部分任务。Placement Group可以确保作业尽量分散到多个计算节点上。<ul><li>例如在分布式推理场景中：如果一个作业需要8块GPU，每个GPU负责加载模型并独立进行推理，为了实现负载均衡，应该将作业调度到8个计算节点上，每个节点使用1块GPU。这样做的好处是，如果一个节点发生故障，不会导致整个推理服务不可用，因为其他节点仍然可以继续工作。</li></ul></li></ul><p>关键概念：</p><ul><li><strong>资源包（Bundle）</strong>：<strong>一个键值对，定义所需的计算资源</strong>，比如 <code>&#123;"CPU": 2&#125;</code>，或 <code>&#123;"CPU": 8, "GPU": 4&#125;</code>。<strong>一个 Bundle 必须可以调度到单个计算节点</strong>；比如，一个计算节点只有 8 块 GPU，<code>&#123;"GPU": 10&#125;</code> 是不合理的。<ul><li>多个 Ray Task 或 Actor 可以运行在同一个 Bundle 上；任何使用同一个 Bundle 的 Task 或 Actor 将一直运行在该计算节点上。</li></ul></li><li><strong>资源组（Placement Group）</strong>：Placement Group 是<strong>一组 Bundle</strong>。比如，<code>&#123;"CPU": 8&#125; * 4</code> 向 Ray 集群申请 4 个 Bundle，每个 Bundle 预留 8 个 CPU。</li></ul><p>举个完整栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ray.util.placement_group <span class="keyword">import</span> (</span><br><span class="line">    placement_group,</span><br><span class="line">    placement_group_table,</span><br><span class="line">    remove_placement_group,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> ray.util.scheduling_strategies <span class="keyword">import</span> PlacementGroupSchedulingStrategy</span><br><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="comment"># 启动ray集群</span></span><br><span class="line">ray.init()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;Available Resources: &#123;&#125;&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(ray.available_resources()))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_gpus=<span class="number">2</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gpu_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;GPU ids: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ray.get_runtime_context().get_accelerator_ids()[<span class="string">&quot;GPU&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Placement Group：包括一个Bundle</span></span><br><span class="line">pg = placement_group([&#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">16</span>, <span class="string">&quot;GPU&quot;</span>: <span class="number">2</span>&#125;])</span><br><span class="line"><span class="comment"># 等待 Placement Group 创建成功</span></span><br><span class="line">ray.get(pg.ready(), timeout=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 也可以使用 ray.wait</span></span><br><span class="line">ready, unready = ray.wait([pg.ready()], timeout=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;Placement Group: &#123;&#125;&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(placement_group_table(pg)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Ray Task 调度到这个 Placement Group</span></span><br><span class="line">ray.get(gpu_task.options(</span><br><span class="line">    scheduling_strategy=PlacementGroupSchedulingStrategy(placement_group=pg)</span><br><span class="line">).remote())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除这个 Placement Group</span></span><br><span class="line">remove_placement_group(pg)</span><br></pre></td></tr></table></figure><blockquote><p><code>placement_group()</code> 接收 <code>strategy</code> 参数：</p><ul><li><p><code>STRICT_PACK</code>：所有 Bundle 都必须调度到单个计算节点。</p></li><li><p><code>PACK</code>（默认策略）：<strong>所有 Bundle 优先调度到单个计算节点</strong>，如果无法满足条件，再调度到其他计算节点，</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/pg-pack.svg"></p></li><li><p><code>STRICT_SPREAD</code>：每个 Bundle 必须调度到不同的计算节点。</p></li><li><p><code>SPREAD</code>：每个 Bundle 优先调度到不同的计算节点，如果无法满足条件，有些 Bundle 可以共用一个计算节点。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/pg-spread.svg"></p><p>对比：</p><ul><li><code>STRICT_PACK</code> 和 <code>PACK</code> 保证了数据的<strong>局部性</strong>，计算任务可以快速访问本地的数据；</li><li><code>STRICT_SPREAD</code> 和 <code>SPREAD</code> 使得计算更好地负载均衡。</li></ul></li></ul></blockquote><h4 id="ray作业">Ray作业</h4><p>Ray 作业指的是用户编写的，基于 Task、Actor 或者 Ray 各类生态（Ray Train、Ray Tune、Ray Serve、RLlib 等）的<strong>具体的计算任务</strong>。主要包括三种作业提交方式：</p><ol type="1"><li><p><strong>Ray Jobs 命令行</strong>：<code>RAY_ADDRESS</code> 根据头节点的地址设定； <code>--working-dir</code> 为工作目录，Ray 会将该目录下的内容打包，分发到 Ray 集群各个节点；ENTRYPOINT指的是需要执行的 Python 脚本，本例中，是 <code>python script.py</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAY_ADDRESS=<span class="string">&#x27;http://127.0.0.1:8265&#x27;</span> ray job submit --working-dir ./ -- python script.py</span><br></pre></td></tr></table></figure><p>依赖管理：启动作业时，设置 <code>--runtime-env-json</code>，原理是为每个作业创建一个独立的虚拟环境。</p></li><li><p><strong>Python SDK</strong>：将提交作业的各类参数写在 Python 代码中，执行 Python 代码来提交作业。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> ray.job_submission <span class="keyword">import</span> JobSubmissionClient, JobStatus</span><br><span class="line"></span><br><span class="line">client = JobSubmissionClient(<span class="string">&quot;http://127.0.0.1:8265&quot;</span>)</span><br><span class="line"><span class="comment"># submit_job()方法的作业提交是异步的：调用此方法后，Ray 会马上返回作业的 ID</span></span><br><span class="line">job_id = client.submit_job(</span><br><span class="line">    entrypoint=<span class="string">&quot;python script.py&quot;</span>,</span><br><span class="line">    runtime_env=&#123;<span class="string">&quot;working_dir&quot;</span>: <span class="string">&quot;./&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(job_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wait_until_status</span>(<span class="params">job_id, status_to_wait_for, timeout_seconds=<span class="number">5</span></span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">while</span> time.time() - start &lt;= timeout_seconds:</span><br><span class="line">        status = client.get_job_status(job_id)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;status: <span class="subst">&#123;status&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> status <span class="keyword">in</span> status_to_wait_for:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait_until_status() 函数不断向 Ray 集群请求，检查作业的当前状态</span></span><br><span class="line">wait_until_status(job_id, &#123;JobStatus.SUCCEEDED, JobStatus.STOPPED, JobStatus.FAILED&#125;)</span><br><span class="line">logs = client.get_job_logs(job_id)</span><br><span class="line"><span class="built_in">print</span>(logs)</span><br></pre></td></tr></table></figure></li><li><p><strong>Ray客户端</strong>：在 Python 中使用 <code>ray.init()</code> 函数，直接指定Ray集群的地址：<code>ray.init("ray://&lt;head-node-host&gt;:&lt;port&gt;")</code>。</p><p>在客户端与Ray集群意外断开连接的情况下，Ray会尝试在30秒后重新建立连接。如果重新连接失败，Ray将销毁所有相关的引用。可以通过设置环境变量 <code>RAY_CLIENT_RECONNECT_GRACE_PERIOD</code> 来自定义这个重连尝试的时间间隔。</p></li></ol><h3 id="ray-data">Ray Data</h3><p>Ray Data 是一个构建在 Ray Core 之上的数据处理框架，对数据提供了一个抽象类：<a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.Dataset.html"><code>ray.data.Dataset</code></a>，它封装了数据并在上面实现了常见的大数据处理原语。包括：</p><ul><li>数据的读取：比如读取 Parquet 文件等。</li><li>对数据的转换（Transformation）操作：比如 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.Dataset.map_batches.html"><code>map_batches()</code></a>。</li><li>分组聚合操作：比如 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.Dataset.groupby.html"><code>groupby()</code></a></li><li>数据在计算节点间的交换：比如 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.Dataset.random_shuffle.html"><code>random_shuffle()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.Dataset.repartition.html"><code>repartition()</code></a> 等。</li></ul><h4 id="ray.data.dataset"><code>ray.data.Dataset</code></h4><p><code>Dataset</code> 底层的基本单元是 <code>Block</code>；<code>Dataset</code> 实际上是一个分布式的 <code>ObjectRef[Block]</code>。</p><p><code>Block</code> 是一个数据结构，它基于Apache Arrow格式构建，这是一种高效率的<strong>列式存储</strong>格式，适用于在内存中处理和操作大量数据。</p><p>以下展示了一个由 3 个 <code>Block</code> 组成的 <code>Dataset</code>：可以使用 <code>from_*()</code> API 从其他系统或格式导入成 <code>Dataset</code>，比如 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.from_pandas.html"><code>from_pandas()</code></a> 、<a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.from_spark.html"><code>from_spark()</code></a>。或者使用 <code>read_*()</code> API 从持久化的文件系统重读取，比如 <a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.read_parquet.html"><code>read_parquet()</code></a>、<a target="_blank" rel="noopener" href="https://docs.ray.io/en/latest/data/api/doc/ray.data.read_json.html"><code>read_json()</code></a> 等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/Dataset.svg"></p><h4 id="数据读写">数据读写</h4><p>Ray Data 使用 <strong>Ray Task 并行地读写数据</strong>： <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/dataset-read.svg"></p><ul><li><p>数据加载：</p><table><colgroup><col style="width:4%"><col style="width:19%"><col style="width:15%"><col style="width:14%"><col style="width:21%"><col style="width:25%"></colgroup><thead><tr><th></th><th>Parquet</th><th>Text</th><th>CSV</th><th>TFRecord</th><th>二进制</th></tr></thead><tbody><tr><td>方法</td><td><code>read_parquet()</code></td><td><code>read_text()</code></td><td><code>read_csv()</code></td><td><code>read_tfrecords()</code></td><td><code>read_binary_files()</code></td></tr></tbody></table></li><li><p>行列裁剪：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyarrow <span class="keyword">as</span> pa</span><br><span class="line"></span><br><span class="line">dataset = ray.data.read_parquet(</span><br><span class="line">    dataset_path,</span><br><span class="line">    columns=[<span class="string">&quot;passenger_count&quot;</span>, <span class="string">&quot;tip_amount&quot;</span>, <span class="string">&quot;payment_type&quot;</span>],</span><br><span class="line">    <span class="built_in">filter</span>=pa.dataset.field(<span class="string">&quot;tip_amount&quot;</span>) &gt; <span class="number">6.0</span></span><br><span class="line">)</span><br><span class="line">dataset.show(limit=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>并行度：各类数据读取方法都可以设置 <code>parallelism</code> 参数，来控制底层的并行执行的过程。如果不设置 <code>parallelism</code>，Ray Data 通过以下方式试探 <code>parallelism</code>：</p><ol type="1"><li>Ray 获取集群中可用的 CPU 核数；</li><li><code>parallelism</code> 被设置为 CPU 核数的 2 倍。如果 <code>parallelism</code> 小于 8，则设置为 8；</li><li>估计每个 <code>Block</code> 的大小，如果每个 <code>Block</code> 平均大于 512 MiB，Ray 增大 <code>parallelism</code>，<strong>直到每个 <code>Block</code> 小于 512 MiB</strong>。</li></ol></li><li><p>查看数据：...</p></li></ul><h4 id="数据转换">数据转换</h4><p>略</p><h2 id="verl-ray-api">verl Ray API</h2><h3 id="基础执行单元worker">基础执行单元：Worker</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/posts/5d9f220e/class_diagram_simplified.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化后代码：原始代码位于verl/single_controller/base/worker.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>(<span class="title class_ inherited__">WorkerHelper</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        rank = os.environ.get(<span class="string">&quot;RANK&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        worker_group_prefix = os.environ.get(<span class="string">&quot;WG_PREFIX&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">None</span> <span class="keyword">not</span> <span class="keyword">in</span> [rank, worker_group_prefix] <span class="keyword">and</span> <span class="string">&#x27;ActorClass(&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cls.__name__:</span><br><span class="line">            instance._configure_before_init(<span class="string">f&quot;<span class="subst">&#123;worker_group_prefix&#125;</span>_register_center&quot;</span>, <span class="built_in">int</span>(rank))</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_configure_before_init</span>(<span class="params">self, register_center_name: <span class="built_in">str</span>, rank: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># rank=0时，配置MASTER_ADDR和MASTER_PORT环境变量，并将该信息存储在self.register_center中</span></span><br><span class="line">        <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">            master_addr, master_port = <span class="variable language_">self</span>.get_availale_master_addr_port()</span><br><span class="line">            rank_zero_info = &#123;</span><br><span class="line">                <span class="string">&quot;MASTER_ADDR&quot;</span>: master_addr,</span><br><span class="line">                <span class="string">&quot;MASTER_PORT&quot;</span>: master_port,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> os.getenv(<span class="string">&quot;WG_BACKEND&quot;</span>, <span class="literal">None</span>) == <span class="string">&quot;ray&quot;</span>:</span><br><span class="line">                <span class="keyword">from</span> verl.single_controller.base.register_center.ray <span class="keyword">import</span> create_worker_group_register_center</span><br><span class="line">                <span class="variable language_">self</span>.register_center = create_worker_group_register_center(name=register_center_name,info=rank_zero_info)</span><br><span class="line">            os.environ.update(rank_zero_info)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cuda_visible_devices=<span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        world_size = <span class="built_in">int</span>(os.environ[<span class="string">&#x27;WORLD_SIZE&#x27;</span>])</span><br><span class="line">        rank = <span class="built_in">int</span>(os.environ[<span class="string">&#x27;RANK&#x27;</span>])</span><br><span class="line">        <span class="variable language_">self</span>._rank = rank</span><br><span class="line">        <span class="variable language_">self</span>._world_size = world_size</span><br><span class="line"></span><br><span class="line">        master_addr = os.environ[<span class="string">&quot;MASTER_ADDR&quot;</span>]</span><br><span class="line">        master_port = os.environ[<span class="string">&quot;MASTER_PORT&quot;</span>]</span><br><span class="line"></span><br><span class="line">        local_world_size = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;LOCAL_WORLD_SIZE&quot;</span>, <span class="string">&quot;1&quot;</span>))</span><br><span class="line">        local_rank = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;LOCAL_RANK&quot;</span>, <span class="string">&quot;0&quot;</span>))</span><br><span class="line"></span><br><span class="line">        store = &#123;</span><br><span class="line">            <span class="string">&#x27;_world_size&#x27;</span>: world_size,</span><br><span class="line">            <span class="string">&#x27;_rank&#x27;</span>: rank,</span><br><span class="line">            <span class="string">&#x27;_local_world_size&#x27;</span>: local_world_size,</span><br><span class="line">            <span class="string">&#x27;_local_rank&#x27;</span>: local_rank,</span><br><span class="line">            <span class="string">&#x27;_master_addr&#x27;</span>: master_addr,</span><br><span class="line">            <span class="string">&#x27;_master_port&#x27;</span>: master_port</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># WorkerMeta仅是包store信息存储在实例对象中</span></span><br><span class="line">        meta = WorkerMeta(store=store)</span><br><span class="line">        <span class="comment"># 将meta(store)信息更新到当前实例的__dict__中并配置环境变量</span></span><br><span class="line">        <span class="variable language_">self</span>._configure_with_meta(meta=meta)</span><br></pre></td></tr></table></figure><p>一个栗子：自定义<code>GPUAccumulator</code>：继承<code>Worker</code>类，假设有4个GPU，则每个GPU实例化一个GPUAccumlator，其成员变量value初始化为GPU rank，然后对所有value执行加1操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPUAccumulator</span>(<span class="title class_ inherited__">Worker</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># The initial value of each rank is the same as the rank</span></span><br><span class="line">        <span class="variable language_">self</span>.value = torch.zeros(size=(<span class="number">1</span>,), device=<span class="string">&quot;cuda&quot;</span>) + <span class="variable language_">self</span>.rank</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value += x</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;rank <span class="subst">&#123;self.rank&#125;</span>, value: <span class="subst">&#123;self.value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value.cpu()</span><br><span class="line">      </span><br><span class="line">class_with_args = RayClassWithInitArgs(GPUAccumulator)</span><br><span class="line">resource_pool = RayResourcePool([<span class="number">4</span>], use_gpu=<span class="literal">True</span>)</span><br><span class="line">workergroup = RayWorkerGroup(resource_pool, class_with_args)</span><br><span class="line"><span class="built_in">print</span>(workergroup.add(x=<span class="number">1</span>)) <span class="comment"># 输出：[tensor([1.]), tensor([2.]), tensor([3.]), tensor([4.])]</span></span><br></pre></td></tr></table></figure><h4 id="初始化参数rayclasswithinitargs">初始化参数：RayClassWithInitArgs</h4><p><strong><code>RayClassWithInitArgs</code>保存通过<code>@ray.remote</code>定义的Actor类，以及一些用于异步调用该Actor时所需要的参数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_with_args = RayClassWithInitArgs(GPUAccumulator)</span><br></pre></td></tr></table></figure><h4 id="资源池rayresourcepool">资源池：<strong>RayResourcePool</strong></h4><p><strong>RayResourcePool继承自ResourcePool</strong>。</p><ol type="1"><li><strong>ResourcePool负责存储资源相关的信息</strong>：</li></ol><ul><li><p>初始化参数：</p><ul><li><p><strong>process_on_nodes</strong>: 节点进程数列表，表示每个节点上要运行的进程数量</p></li><li><p><strong>max_colocate_count</strong>: 单个节点上最大并行进程数，默认10</p></li><li><p><strong>n_gpus_per_node</strong>: 每个节点的GPU数量，默认8</p></li></ul></li><li><p>关键属性：</p><ul><li><p><code>_store</code>: 存储各节点的进程数配置</p></li><li><p><code>world_size</code>: 属性，计算所有节点的总进程数</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourcePool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, process_on_nodes=<span class="literal">None</span>, max_colocate_count: <span class="built_in">int</span> = <span class="number">10</span>, n_gpus_per_node=<span class="number">8</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> process_on_nodes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            process_on_nodes = []</span><br><span class="line">        <span class="variable language_">self</span>._store = process_on_nodes</span><br><span class="line">        <span class="variable language_">self</span>.max_colocate_count = max_colocate_count</span><br><span class="line">        <span class="variable language_">self</span>.n_gpus_per_node = n_gpus_per_node  <span class="comment"># this is left for future huawei GPU that contains 16 GPUs per node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, process_count</span>):	<span class="comment"># 添加新节点到资源池（动态扩展）</span></span><br><span class="line">        <span class="variable language_">self</span>._store.append(process_count)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">world_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>._store)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._store</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._store</span><br><span class="line">		<span class="comment"># 获取本地信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">local_world_size_list</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:	<span class="comment"># 生成每个进程对应的本地世界大小列表</span></span><br><span class="line">        nested_local_world_size_list = [[local_world_size <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(local_world_size)] <span class="keyword">for</span> local_world_size <span class="keyword">in</span> <span class="variable language_">self</span>._store]</span><br><span class="line">        <span class="keyword">return</span> [item <span class="keyword">for</span> row <span class="keyword">in</span> nested_local_world_size_list <span class="keyword">for</span> item <span class="keyword">in</span> row]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">local_rank_list</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:		<span class="comment"># 生成每个进程的本地rank列表</span></span><br><span class="line">        nested_local_rank_list = [[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(local_world_size)] <span class="keyword">for</span> local_world_size <span class="keyword">in</span> <span class="variable language_">self</span>._store]</span><br><span class="line">        <span class="keyword">return</span> [item <span class="keyword">for</span> row <span class="keyword">in</span> nested_local_rank_list <span class="keyword">for</span> item <span class="keyword">in</span> row]</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>RayResourcePool通过Ray的Placement Group实现资源池的分配</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RayResourcePool</span>(<span class="title class_ inherited__">ResourcePool</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        ......</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(process_on_nodes, max_colocate_count)</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_placement_groups</span>(<span class="params">self, strategy=<span class="string">&quot;STRICT_PACK&quot;</span>, name=<span class="literal">None</span></span>):</span><br><span class="line">      <span class="comment"># 默认使用STRICT_PACK策略：所有 Bundle 都必须调度到单个计算节点</span></span><br><span class="line">      <span class="comment"># (每个bundle包含max_colocate_count个CPU核心)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.pgs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.pgs		<span class="comment"># 缓存已创建的placement groups</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成唯一资源组名称</span></span><br><span class="line">        pg_name_prefix = name <span class="keyword">if</span> name <span class="keyword">else</span> <span class="string">f&quot;<span class="subst">&#123;self.name_prefix&#125;</span>verl_group_<span class="subst">&#123;<span class="string">&#x27;_&#x27;</span>.join([<span class="built_in">str</span>(count) <span class="keyword">for</span> count <span class="keyword">in</span> self._store])&#125;</span>:&quot;</span></span><br><span class="line">        <span class="comment"># 构建资源bundle配置</span></span><br><span class="line">        pg_scheme = [[&#123;<span class="string">&quot;CPU&quot;</span>: <span class="variable language_">self</span>.max_colocate_count, <span class="string">&quot;GPU&quot;</span>: <span class="number">1</span>&#125; <span class="keyword">if</span> <span class="variable language_">self</span>.use_gpu <span class="keyword">else</span> &#123;<span class="string">&quot;CPU&quot;</span>: <span class="variable language_">self</span>.max_colocate_count&#125; <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(process_count)] <span class="keyword">for</span> process_count <span class="keyword">in</span> <span class="variable language_">self</span>._store]</span><br><span class="line"></span><br><span class="line">        lifetime = <span class="string">&quot;detached&quot;</span> <span class="keyword">if</span> <span class="variable language_">self</span>.detached <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">				<span class="comment"># 创建placement groups</span></span><br><span class="line">        pgs = [placement_group(bundles=bundles, strategy=strategy, name=pg_name_prefix + <span class="built_in">str</span>(idx), lifetime=lifetime) <span class="keyword">for</span> idx, bundles <span class="keyword">in</span> <span class="built_in">enumerate</span>(pg_scheme)]</span><br><span class="line"></span><br><span class="line">        ray.get([pg.ready() <span class="keyword">for</span> pg <span class="keyword">in</span> pgs])	 <span class="comment"># 等待所有资源组就绪</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.pgs = pgs	<span class="comment"># 缓存结果</span></span><br><span class="line">        <span class="keyword">return</span> pgs</span><br></pre></td></tr></table></figure><p>一个栗子：</p><p>创建集群：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">from</span> ray.util.placement_group</span><br><span class="line"><span class="comment"># 创建包含8GPU、16CPU的Ray集群</span></span><br><span class="line">ray.init(num_cpus=<span class="number">16</span>, num_gpus=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>创建两个Placement Group，每个Placement Group包含4个GPU和8个CPU。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resource_pool = RayResourcePool(process_on_nodes=[<span class="number">4</span>,<span class="number">4</span>], max_colocate_count=<span class="number">2</span>, use_gpu=<span class="literal">True</span>) <span class="comment"># 创建资源池</span></span><br><span class="line">pgs = resource_pool.get_placement_groups() <span class="comment"># 创建placement group的列表</span></span><br></pre></td></tr></table></figure><p>单个Placement Group创建为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pg = placement_group(bundles=[&#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">2</span>, <span class="string">&quot;GPU&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">2</span>, <span class="string">&quot;GPU&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">2</span>, <span class="string">&quot;GPU&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">2</span>, <span class="string">&quot;GPU&quot;</span>: <span class="number">1</span>&#125;])</span><br></pre></td></tr></table></figure><p>即<code>process_on_nodes</code>指定要创建几个Placement Group，以及每个包含多少GPU；<code>max_colocate_count</code>是则bundle中单个GPU最多对应多少个CPU，因为colocate的actor至少要有1个CPU。</p><h4 id="资源调度器rayworkergroup">资源调度器：RayWorkerGroup</h4><h5 id="初始化函数__init__">初始化函数：<code>__init__</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        resource_pool: RayResourcePool = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ray_cls_with_init: RayClassWithInitArgs = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        bin_pack: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        name_prefix: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        detached=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        worker_names=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ray_wait_register_center_timeout: <span class="built_in">int</span> = <span class="number">300</span>,</span></span><br><span class="line"><span class="params">        **kwargs,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(resource_pool=resource_pool, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.ray_cls_with_init = ray_cls_with_init</span><br><span class="line">        ......</span><br><span class="line">				<span class="comment"># 分离模式：连接已存在的持久化工作者</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._is_init_with_detached_workers:</span><br><span class="line">            <span class="variable language_">self</span>._init_with_detached_workers(worker_names=worker_names)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 附着模式：基于资源池创建新工作者（基于resource_pool的信息，启动worker）</span></span><br><span class="line">            <span class="variable language_">self</span>._init_with_resource_pool(resource_pool=resource_pool, ray_cls_with_init=ray_cls_with_init, bin_pack=bin_pack, detached=detached)</span><br><span class="line">				<span class="comment"># ray_cls_with_init.clsz中的某些方法绑定到RayWorkerGroup上</span></span><br><span class="line">        <span class="keyword">if</span> ray_cls_with_init <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.(<span class="variable language_">self</span>.ray_cls_with_init.cls, func_generator)</span><br></pre></td></tr></table></figure><h5 id="启动workers_init_with_resource_pool">启动Workers：<code>_init_with_resource_pool</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_init_with_resource_pool</span>(<span class="params">self, resource_pool, ray_cls_with_init, bin_pack, detached</span>):</span><br><span class="line">				......</span><br><span class="line">    	  <span class="comment"># max_collocate_count意味着单个GPU上至多有对应几个CPU</span></span><br><span class="line">        num_gpus = <span class="number">1</span> / resource_pool.max_colocate_count</span><br><span class="line"></span><br><span class="line">        rank = -<span class="number">1</span></span><br><span class="line">        local_world_size = resource_pool.store[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> pg_idx, pg <span class="keyword">in</span> <span class="built_in">enumerate</span>(sort_placement_group_by_node_ip(pgs)):</span><br><span class="line">            <span class="keyword">assert</span> local_world_size &lt;= pg.bundle_count, <span class="string">f&quot;when generating for <span class="subst">&#123;self.name_prefix&#125;</span>, for the &quot;</span></span><br><span class="line">            <span class="keyword">for</span> local_rank <span class="keyword">in</span> <span class="built_in">range</span>(local_world_size):</span><br><span class="line">                rank += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 1. 构造worker需要的配置信息，包括环境变量等；</span></span><br><span class="line">                <span class="comment"># 2. 通过ray_cls_with_init.update_options更新这些配置信息</span></span><br><span class="line">                <span class="comment"># 3. 创建一个worker：</span></span><br><span class="line">                worker = ray_cls_with_init(placement_group=pg, placement_group_bundle_idx=local_rank, use_gpu=use_gpu, num_gpus=num_gpus)</span><br><span class="line">                <span class="variable language_">self</span>._workers.append(worker)</span><br><span class="line">                <span class="variable language_">self</span>._worker_names.append(name)</span><br><span class="line">				......</span><br></pre></td></tr></table></figure><h5 id="异步执行execute_all_async">异步执行：<code>execute_all_async</code></h5><p>在<code>_init_with_resource_pool</code>后，<code>self._workers</code>中保存着所有的<code>worker</code>。</p><p>同步执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute_all_sync</span>(<span class="params">self, method_name: <span class="built_in">str</span>, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> ray.get(<span class="variable language_">self</span>.execute_all_async(method_name, *args, **kwargs))</span><br></pre></td></tr></table></figure><p>调用异步执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute_all_async</span>(<span class="params">self, method_name: <span class="built_in">str</span>, *args, **kwargs</span>):</span><br><span class="line">        length = <span class="built_in">len</span>(<span class="variable language_">self</span>._workers)</span><br><span class="line">    		<span class="comment"># 检查参数是否为列表且长度匹配:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(<span class="built_in">isinstance</span>(arg, <span class="built_in">list</span>) <span class="keyword">for</span> arg <span class="keyword">in</span> args) <span class="keyword">and</span> <span class="built_in">all</span>(<span class="built_in">isinstance</span>(kwarg, <span class="built_in">list</span>) <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs.values()):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(<span class="built_in">len</span>(arg) == length <span class="keyword">for</span> arg <span class="keyword">in</span> args) <span class="keyword">and</span> <span class="built_in">all</span>(<span class="built_in">len</span>(kwarg) == length <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs.values()):</span><br><span class="line">                <span class="comment"># 1. 参数分片并执行:遍历每个 worker 的索引i</span></span><br><span class="line">                result = []</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                  sliced_args: 从每个位置参数 args 中取出第 i 个元素，组成新的位置参数。</span></span><br><span class="line"><span class="string">									sliced_kwargs: 从每个关键字参数 kwargs 的值中取出第 i 个元素，组成新的关键字参数。</span></span><br><span class="line"><span class="string">                  &#x27;&#x27;&#x27;</span></span><br><span class="line">                    sliced_args = <span class="built_in">tuple</span>(arg[i] <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">                    sliced_kwargs = &#123;k: v[i] <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items()&#125;</span><br><span class="line">                    result.append(<span class="variable language_">self</span>._execute_remote_single_worker(<span class="variable language_">self</span>._workers[i], method_name, *sliced_args, **sliced_kwargs))</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">				<span class="comment"># 2. 如果参数不是分片的: 对每个 worker 使用相同的 args 和 kwargs 调用方法</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">self</span>._execute_remote_single_worker(worker, method_name, *args, **kwargs) <span class="keyword">for</span> worker <span class="keyword">in</span> <span class="variable language_">self</span>._workers]</span><br></pre></td></tr></table></figure><p>但是，利用<code>execute_all_async</code>来调用worker的不太方便。所以，利用装饰器<code>register</code>和<code>_bind_worker_method</code>来令调用更加自然。</p><h5 id="worker方法绑定至workergroup_bind_worker_method">worker方法绑定至workergroup：<code>_bind_worker_method</code></h5><p><code>_bind_worker_method</code>来自基类<code>WorkerGroup</code>，参数包含<code>user_defined_cls</code>和<code>func_generator</code>。其中<code>user_defined_cls</code>就是用户自定义的worker类。</p><p><strong>函数生成器</strong> <code>func_generator</code>：<strong>动态生成一个可执行函数</strong>，用于在分布式 Worker 组（<code>WorkerGroup</code>）上执行任务。这个生成的函数会按照指定的 <strong>分发（dispatch）、执行（execute）、收集（collect）</strong> 逻辑运行，并支持阻塞和非阻塞模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_generator</span>(<span class="params">self, method_name, dispatch_fn, collect_fn, execute_fn, blocking</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;method_name: 要在 Worker 上调用的方法名（如 &quot;foo&quot;）。</span></span><br><span class="line"><span class="string">		dispatch_fn: 分发函数，负责将输入参数分发给各个 Worker。</span></span><br><span class="line"><span class="string">		collect_fn: 收集函数，负责聚合 Worker 返回的结果。</span></span><br><span class="line"><span class="string">		execute_fn: 执行函数，负责在 Worker 上真正运行方法。</span></span><br><span class="line"><span class="string">		blocking: 是否阻塞等待结果（True 表示同步，False 表示异步）。&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        args, kwargs = dispatch_fn(<span class="variable language_">self</span>, *args, **kwargs)	<span class="comment"># 1. 分发参数</span></span><br><span class="line">        padding_count = kwargs.pop(_padding_size_key, <span class="number">0</span>)	<span class="comment"># 2. 处理可能的填充</span></span><br><span class="line">        output = execute_fn(method_name, *args, **kwargs)	<span class="comment"># 3. 执行任务</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;判断是否阻塞等待结果：</span></span><br><span class="line"><span class="string">        1. 如果 blocking=True，调用 ray.get(output) 等待所有 Worker 完成计算；</span></span><br><span class="line"><span class="string">        2. 如果 blocking=False，直接返回异步引用。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> blocking:</span><br><span class="line">            output = ray.get(output)</span><br><span class="line">        <span class="comment"># 4. 收集结果</span></span><br><span class="line">        output = collect_fn(<span class="variable language_">self</span>, output)</span><br><span class="line">        <span class="comment"># 5. 移除填充（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> padding_count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(output, DataProto):</span><br><span class="line">                indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output))][:-padding_count]</span><br><span class="line">                output = output.select_idxs(indices)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(output, <span class="built_in">list</span>):</span><br><span class="line">                output = output[:-padding_count]</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_bind_worker_method</span>(<span class="params">self, user_defined_cls, func_generator</span>):</span><br><span class="line">        method_names = []</span><br><span class="line">        <span class="keyword">for</span> method_name <span class="keyword">in</span> <span class="built_in">dir</span>(user_defined_cls):	<span class="comment"># 遍历类的所有方法</span></span><br><span class="line">        		<span class="comment"># 尝试获取方法并检查是否可调用（callable），跳过不可调用的属性（如 property）</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                method = <span class="built_in">getattr</span>(user_defined_cls, method_name)</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">callable</span>(method), <span class="string">f&quot;<span class="subst">&#123;method_name&#125;</span> in <span class="subst">&#123;user_defined_cls&#125;</span> is not callable&quot;</span></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">						<span class="comment"># 检查方法是否带有特定装饰器标记MAGIC_ATTR</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(method, MAGIC_ATTR):</span><br><span class="line">              <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              获取装饰器设置的属性（attribute），并检查它是否是字典。</span></span><br><span class="line"><span class="string">							确保属性中包含 dispatch_mode（分发模式）、execute_mode（执行模式）和 blocking（是否阻塞）字段。</span></span><br><span class="line"><span class="string">              &#x27;&#x27;&#x27;</span></span><br><span class="line">                attribute = <span class="built_in">getattr</span>(method, MAGIC_ATTR)</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(attribute, <span class="type">Dict</span>), <span class="string">f&quot;attribute must be a dictionary. Got <span class="subst">&#123;<span class="built_in">type</span>(attribute)&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">assert</span> <span class="string">&quot;dispatch_mode&quot;</span> <span class="keyword">in</span> attribute, <span class="string">&quot;attribute must contain dispatch_mode in its key&quot;</span></span><br><span class="line">                dispatch_mode = attribute[<span class="string">&quot;dispatch_mode&quot;</span>]</span><br><span class="line">                execute_mode = attribute[<span class="string">&quot;execute_mode&quot;</span>]</span><br><span class="line">                blocking = attribute[<span class="string">&quot;blocking&quot;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取分发函数（dispatch_fn 和 collect_fn）</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(dispatch_mode, Dispatch):</span><br><span class="line">                    fn = get_predefined_dispatch_fn(dispatch_mode=dispatch_mode)</span><br><span class="line">                    dispatch_fn = fn[<span class="string">&quot;dispatch_fn&quot;</span>]</span><br><span class="line">                    collect_fn = fn[<span class="string">&quot;collect_fn&quot;</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(dispatch_mode, <span class="built_in">dict</span>)</span><br><span class="line">                    <span class="keyword">assert</span> <span class="string">&quot;dispatch_fn&quot;</span> <span class="keyword">in</span> dispatch_mode</span><br><span class="line">                    <span class="keyword">assert</span> <span class="string">&quot;collect_fn&quot;</span> <span class="keyword">in</span> dispatch_mode</span><br><span class="line">                    dispatch_fn = dispatch_mode[<span class="string">&quot;dispatch_fn&quot;</span>]</span><br><span class="line">                    collect_fn = dispatch_mode[<span class="string">&quot;collect_fn&quot;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment">#  获取执行函数（execute_fn）</span></span><br><span class="line">                execute_mode = get_predefined_execute_fn(execute_mode=execute_mode)</span><br><span class="line">                wg_execute_fn_name = execute_mode[<span class="string">&quot;execute_fn_name&quot;</span>]</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    execute_fn = <span class="built_in">getattr</span>(<span class="variable language_">self</span>, wg_execute_fn_name)</span><br><span class="line">                    <span class="keyword">assert</span> <span class="built_in">callable</span>(execute_fn), <span class="string">&quot;execute_fn must be callable&quot;</span></span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;execute_fn <span class="subst">&#123;wg_execute_fn_name&#125;</span> is invalid&quot;</span>)</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 生成并绑定新方法：</span></span><br><span class="line">                <span class="comment"># 利用func_generator将dispatch_fn、collect_fn组装到method_name上</span></span><br><span class="line">                func = func_generator(</span><br><span class="line">                    <span class="variable language_">self</span>,</span><br><span class="line">                    method_name,</span><br><span class="line">                    dispatch_fn=dispatch_fn,</span><br><span class="line">                    collect_fn=collect_fn,</span><br><span class="line">                    execute_fn=execute_fn,</span><br><span class="line">                    blocking=blocking,</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="built_in">setattr</span>(<span class="variable language_">self</span>, method_name, func)</span><br><span class="line">                    method_names.append(method_name)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Fail to set method_name <span class="subst">&#123;method_name&#125;</span>&quot;</span>) <span class="keyword">from</span> e</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method_names</span><br></pre></td></tr></table></figure><p>一个栗子：</p><ol type="1"><li><p>自定义分发函数： <strong>将 2 个输入参数扩展到所有 Worker</strong>（<code>world_size</code> 个 Worker）</p><ul><li>例如，如果 <code>world_size=4</code>，输入 <code>x=[1, 2]</code> 会被扩展为 <code>x=[1, 2, 1, 2]</code>，使得每个 Worker 都能接收一个参数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_to_all_dispatch_fn</span>(<span class="params">worker_group, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(arg) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(worker_group.world_size - <span class="number">2</span>):</span><br><span class="line">            arg.append(arg[i % <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(v) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(worker_group.world_size - <span class="number">2</span>):</span><br><span class="line">            v.append(v[i % <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> args, kwargs</span><br></pre></td></tr></table></figure></li><li><p><code>TestActor</code>（Worker 类）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestActor</span>(<span class="title class_ inherited__">Worker</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>._x = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, y</span>):		<span class="comment"># 普通方法：直接计算 self._x + y</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._x + y</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用 @register 装饰器，指定分发模式 ALL_TO_ALL 和执行模式 RANK_ZERO：</span></span><br><span class="line"><span class="string">    只会在 rank=0 的 Worker 上执行&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">    @register(<span class="params">dispatch_mode=Dispatch.ALL_TO_ALL, execute_mode=Execute.RANK_ZERO</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo_rank_zero</span>(<span class="params">self, x, y</span>):	</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._x + y + x</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用自定义分发函数 two_to_all_dispatch_fn和收集函数 collect_all_to_all</span></span><br><span class="line"><span class="string">    输入 x 和 y 会被 two_to_all_dispatch_fn 扩展后分发给所有 Worker&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">    @register(<span class="params">dispatch_mode=&#123;<span class="string">&quot;dispatch_fn&quot;</span>: two_to_all_dispatch_fn, <span class="string">&quot;collect_fn&quot;</span>: collect_all_to_all&#125;</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo_custom</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._x + y + x</span><br><span class="line">class_with_args = RayClassWithInitArgs(cls=TestActor, x=<span class="number">2</span>)</span><br><span class="line">worker_group = RayWorkerGroup(resource_pool, class_with_args)</span><br><span class="line">output_ref = worker_group.foo_custom(x=[<span class="number">1</span>, <span class="number">2</span>], y=[<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;每个 Worker 计算 self._x + y + x：</span></span><br><span class="line"><span class="string">Worker 0: 2 + 5 + 1 = 8</span></span><br><span class="line"><span class="string">Worker 1: 2 + 6 + 2 = 10</span></span><br><span class="line"><span class="string">Worker 2: 2 + 5 + 1 = 8</span></span><br><span class="line"><span class="string">Worker 3: 2 + 6 + 2 = 10&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> output_ref == [<span class="number">8</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;只有 rank=0 的 Worker 执行计算：2 + 2 + 1 = 5&#x27;&#x27;&#x27;</span></span><br><span class="line">output_ref = worker_group.foo_rank_zero(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> output_ref == <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考">参考</h2><p><a target="_blank" rel="noopener" href="https://scale-py.godaai.org/index.html">Python 数据科学加速</a></p><p><a target="_blank" rel="noopener" href="https://scale-py.godaai.org/index.html">Ray Tutorial</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29997527557">【AI Infra】【RLHF框架】一、VeRL中基于Ray的执行流程源码解析</a></p><p><a target="_blank" rel="noopener" href="https://github.com/volcengine">volcengine</a>/<a target="_blank" rel="noopener" href="https://github.com/volcengine/verl">verl</a></p><p><a target="_blank" rel="noopener" href="https://github.com/volcengine/verl/blob/main/examples/ray/tutorial.ipynb">tutorial.ipynb</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io">Liuyi Wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wenliuyi.github.io/posts/5d9f220e.html">http://wenliuyi.github.io/posts/5d9f220e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wenliuyi.github.io" target="_blank">Liuyi Wen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WechatIMG105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/48646366.html" title="FSDP设计解读"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">FSDP设计解读</div></div><div class="info-2"><div class="info-item-1">Meta官方文档 FSDP(Fully Sharded Data Parallelism)将AI模型的参数分片至多个数据并行的workers上，可选择性地将训练中的计算移至CPU上。每个worker上microbatch的数据是不同的。 分片（Shard）：官方文档：Scaling services with Shard Manager 通常数据并行训练要求在每个GPU上，保存模型副本（引入冗余）；模型并行训练在workers（GPUs）之间增添了额外的通信负担，用于同步激活值。 激活值（activations）： 神经网络中每一层的输入输出都是一个线性求和的过程，下一层的输出只是承接了上一层输入函数的线性变换，所以如果没有激活函数，那么无论构造的神经网络多么复杂，有多少层，最后的输出都是输入的线性组合，纯粹的线性组合并不能够解决更为复杂的问题。常见的激活函数都是非线性的，因此向神经元引入非线性元素，使得神经网络可以逼近其他的任何非线性函数，这样可以使得神经网络应用到更多非线性模型中。 常见激活函数：参见Activation Functions — All You Need...</div></div></div></a><a class="pagination-related" href="/posts/2ac460b1.html" title="verl框架：2. 对比OpenRLHF+colocate思路解析"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">verl框架：2. 对比OpenRLHF+colocate思路解析</div></div><div class="info-2"><div class="info-item-1">SPMD-&gt;MPMD SPMD设计范式：单程序多数据，所有进程/线程执行同一个程序的拷贝，通过环境变量差异自主确定行为模式，无需中心调度节点。主流并行框架（DDP/DeepSpeed/Megatron）均基于SPMD范式。 优点：SPMD由于没有controller，完全由worker自驱，在运行时更为高效； 缺点：由于各个worker上需要运行相同程序，灵活性不如single-controller模式；需要考虑各个rank之间的通信，增加编程复杂度。 经典代码如下： 123456import torchimport osprint(os.environ[&#x27;RANK&#x27;], os.environ[&#x27;WORLD_SIZE&#x27;], os.environ[&#x27;MASTER_ADDR&#x27;],...</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/WechatIMG105.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">Liuyi Wen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WenLiuyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The Journey Is the Reward.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">现代计算机体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95pcam"><span class="toc-number">2.</span> <span class="toc-text">并行程序设计方法：PCAM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8Bmapreduce"><span class="toc-number">2.1.</span> <span class="toc-text">案例：MapReduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">2.2.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flops"><span class="toc-number">2.2.1.</span> <span class="toc-text">FLOPs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-number">2.2.2.</span> <span class="toc-text">加速比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ray"><span class="toc-number">3.</span> <span class="toc-text">Ray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ray%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">Ray结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ray-core-api"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">Ray Core API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%87%BD%E6%95%B0remote-functionray.remote-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">分布式函数（Remote Function）：@ray.remote 装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1remote-object%E5%AD%98%E5%82%A8ray.put-%E4%B8%8E-ray.get"><span class="toc-number">3.1.2.</span> <span class="toc-text">分布式对象（Remote Object）存储：ray.put() 与 ray.get()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">修改数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E9%80%9A%E8%BF%87refobjectid"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">传递参数：通过RefObjectID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B1%BBactor"><span class="toc-number">3.1.3.</span> <span class="toc-text">分布式类（Actor）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%97%E5%AD%90actor-pool"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">栗子：Actor Pool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ray%E9%9B%86%E7%BE%A4"><span class="toc-number">3.2.</span> <span class="toc-text">Ray集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E4%B8%8E%E8%B5%84%E6%BA%90%E7%BB%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">计算资源与资源组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%9C%80%E6%B1%82"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">资源需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%BB%84placement-group"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">资源组（Placement Group）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ray%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">Ray作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ray-data"><span class="toc-number">3.3.</span> <span class="toc-text">Ray Data</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ray.data.dataset"><span class="toc-number">3.3.1.</span> <span class="toc-text">ray.data.Dataset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.3.2.</span> <span class="toc-text">数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">数据转换</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#verl-ray-api"><span class="toc-number">4.</span> <span class="toc-text">verl Ray API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83worker"><span class="toc-number">4.1.</span> <span class="toc-text">基础执行单元：Worker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0rayclasswithinitargs"><span class="toc-number">4.1.1.</span> <span class="toc-text">初始化参数：RayClassWithInitArgs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%B1%A0rayresourcepool"><span class="toc-number">4.1.2.</span> <span class="toc-text">资源池：RayResourcePool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8rayworkergroup"><span class="toc-number">4.1.3.</span> <span class="toc-text">资源调度器：RayWorkerGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0__init__"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">初始化函数：__init__</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8workers_init_with_resource_pool"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">启动Workers：_init_with_resource_pool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8Cexecute_all_async"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">异步执行：execute_all_async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#worker%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E8%87%B3workergroup_bind_worker_method"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">worker方法绑定至workergroup：_bind_worker_method</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7824989e.html" title="从 TCP 粘包到分帧">从 TCP 粘包到分帧</a><time datetime="2025-09-26T10:04:55.000Z" title="发表于 2025-09-26 18:04:55">2025-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/eecc19a2.html" title="并行训练系列：5. Megatron 之分布式环境初始化">并行训练系列：5. Megatron 之分布式环境初始化</a><time datetime="2025-09-25T09:41:56.000Z" title="发表于 2025-09-25 17:41:56">2025-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/d7906c2a.html" title="并行训练系列：4. 张量并行（TP）">并行训练系列：4. 张量并行（TP）</a><time datetime="2025-09-18T15:53:50.000Z" title="发表于 2025-09-18 23:53:50">2025-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7529a079.html" title="并行训练系列：3. 数据并行下篇（DeepSeed-ZeRO）">并行训练系列：3. 数据并行下篇（DeepSeed-ZeRO）</a><time datetime="2025-09-17T10:00:42.000Z" title="发表于 2025-09-17 18:00:42">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3858f068.html" title="并行训练系列：2. 数据并行上篇（DP，DDP）">并行训练系列：2. 数据并行上篇（DP，DDP）</a><time datetime="2025-09-16T07:43:28.000Z" title="发表于 2025-09-16 15:43:28">2025-09-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Liuyi Wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"all"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,e=(e,o)=>{n&&(window.shuoshuoComment.destroyValine=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))});const t={el:"#vcomment",appId:"bsxtUJWr1muoPS1pmoXLOPZ2-gzGzoHsz",appKey:"wm2wUYvKLEySwyRnFn7xAbJI",avatar:"monsterid",serverURLs:"",emojiMaps:"",visitor:!1,path:n?o:window.location.pathname};new Valine(t)},o=async(n,o)=>{"function"==typeof Valine||await btf.getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"),e(n,o)};n?window.shuoshuoComment={loadComment:o}:btf.loadComment(document.getElementById("vcomment"),o)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>